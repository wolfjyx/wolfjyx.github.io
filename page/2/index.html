<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>wolfjyx&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="wolfjyx&#39;s blog">
<meta property="og:url" content="http://wolfjyx.github.com/page/2/index.html">
<meta property="og:site_name" content="wolfjyx&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wolfjyx&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="wolfjyx&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wolfjyx&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">博客的博，博客的客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://wolfjyx.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-threejs解读 webGLRender" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/11/threejs解读 webGLRender/" class="article-date">
  <time datetime="2018-12-11T14:58:14.720Z" itemprop="datePublished">2018-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/11/threejs解读 webGLRender/">threejs解读 webGLRender</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WebGLRender"><a href="#WebGLRender" class="headerlink" title="WebGLRender"></a>WebGLRender</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用WebGL渲染场景</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebGLRenderer( parameters : Object )</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>canvas</strong> - 绘制输出的canvas。这对应于下面的domElement属性。如果没有传值，则将创建新的canvas元素。</p>
</li>
<li><p><strong>context</strong> - 可用于将渲染器添加到现有的RenderingContext。默认值为null</p>
</li>
<li><strong>precision</strong> - 着色器精度。可以是“highp”，“mediump”或“lowp”。如果设备支持，则默认为“highp”</li>
<li><strong>alpha</strong> 画布是否包含alpha（透明度）缓冲区。默认值为false</li>
<li><strong>premultipliedAlpha</strong> 渲染器是否会假设颜色具有预乘alpha。默认为true</li>
<li><strong>antialias</strong> 是否执行抗锯齿,默认值为false</li>
<li><strong>stencil</strong> 绘图缓冲区是否具有至少8位的模板缓冲区。默认为true</li>
<li><strong>preserveDrawingBuffer</strong> 在手动清除或覆盖之前是否保留缓冲区。默认值为false</li>
<li><strong>powerPreference</strong> 向用户代理提供一个提示，指示适用于此WebGL上下文的GPU配置。可以是“high-performance”，“low-power”或“default”。默认为“default”</li>
<li><strong>depth</strong> 绘图缓冲区是否具有至少16位的深度缓冲区。 默认为true</li>
<li><strong>logarithmicDepthBuffer</strong> 是否使用对数深度缓冲区。 如果在单个场景中处理规模的巨大差异，则可能需要使用它。 默认值为false</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="autoClear-Boolean"><a href="#autoClear-Boolean" class="headerlink" title="autoClear: Boolean"></a>autoClear: Boolean</h3><p>定义渲染器是否应在渲染帧之前自动清除其输出</p>
<h3 id="autoClearColor-Boolean"><a href="#autoClearColor-Boolean" class="headerlink" title="autoClearColor: Boolean"></a>autoClearColor: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除颜色缓冲区, 默认为true</p>
<h3 id="autoClearDepth-Boolean"><a href="#autoClearDepth-Boolean" class="headerlink" title="autoClearDepth: Boolean"></a>autoClearDepth: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除深度缓冲区, 默认为true</p>
<h3 id="autoClearStencil-Boolean"><a href="#autoClearStencil-Boolean" class="headerlink" title="autoClearStencil: Boolean"></a>autoClearStencil: Boolean</h3><p>如果autoClear为true，则定义渲染器是否应清除模板缓冲区, 默认为true</p>
<h3 id="capabilities-Object"><a href="#capabilities-Object" class="headerlink" title="capabilities: Object"></a>capabilities: Object</h3><p>包含当前RenderingContext功能详细信息d的对象<br>// TODO 对象属性待补充  </p>
<h3 id="clippingPlanes-Array"><a href="#clippingPlanes-Array" class="headerlink" title="clippingPlanes : Array"></a>clippingPlanes : Array</h3><p>用户定义的在世界坐标系的裁剪平面对象。这些平面全局可用。空间中的点和该平面的点积为负将被裁剪掉。默认为 [].</p>
<h3 id="context-WebGLRenderingContext"><a href="#context-WebGLRenderingContext" class="headerlink" title="context : WebGLRenderingContext"></a>context : WebGLRenderingContext</h3><p>渲染器默认通过HTMLCanvasElement.getContext（）方法其domElement获取RenderingContext上下文。<br>您可以手动创建它，但它必须与domElement对应才能渲染到屏幕</p>
<h3 id="domElement：DOMElement"><a href="#domElement：DOMElement" class="headerlink" title="domElement：DOMElement"></a>domElement：DOMElement</h3><p>canvas元素。<br>这是由构造函数中的渲染器自动创建的（如果调用WebGLRenderer没有传入canvas）; 你只需将它添加到你的页面就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild（renderer.domElement）;</span><br></pre></td></tr></table></figure></p>
<h3 id="extensions-Object"><a href="#extensions-Object" class="headerlink" title="extensions : Object"></a>extensions : Object</h3><p><strong>extensions.get</strong>方法的封装，用于检查是否支持各种WebGL扩展。</p>
<h3 id="gammaFactor-Float"><a href="#gammaFactor-Float" class="headerlink" title="gammaFactor: Float"></a>gammaFactor: Float</h3><p> 默认是</p>
<h3 id="gammaInput：Boolean"><a href="#gammaInput：Boolean" class="headerlink" title="gammaInput：Boolean"></a>gammaInput：Boolean</h3><p>如果设置，则所有纹理和颜色都是预乘伽马因子值。 默认值为false</p>
<h3 id="gammaOutput：Boolean"><a href="#gammaOutput：Boolean" class="headerlink" title="gammaOutput：Boolean"></a>gammaOutput：Boolean</h3><p>如果设置，则所有纹理和颜色需要以预乘伽马输出。 默认值为false</p>
<h3 id="info-Object"><a href="#info-Object" class="headerlink" title="info: Object"></a>info: Object</h3><p>一个关于显卡内存和渲染过程统计信息的对象。便于调试和分析。该对象包含如下字段</p>
<ul>
<li>memory:<ul>
<li>geometries</li>
<li>textures</li>
</ul>
</li>
<li>render:<ul>
<li>calls</li>
<li>vertices</li>
<li>faces</li>
<li>points</li>
</ul>
</li>
<li>programs</li>
</ul>
<p>默认情况下，这些数据会在每次渲染调用时重置，但在使用一个或多个镜像时，最好使用自定义模式重置它们：</p>
<pre><code>renderer.info.autoReset = false;
renderer.info.reset();
</code></pre><h3 id="localClippingEnabled-Boolean"><a href="#localClippingEnabled-Boolean" class="headerlink" title="localClippingEnabled : Boolean"></a>localClippingEnabled : Boolean</h3><p>定义渲染器是否遵循对象级剪切平面。 默认值为false</p>
<h3 id="maxMorphTargets-Integer"><a href="#maxMorphTargets-Integer" class="headerlink" title="maxMorphTargets : Integer"></a>maxMorphTargets : Integer</h3><p>着色器中允许的最大变形目标数。标准材料仅允许8个变形目标。默认值为8</p>
<h3 id="maxMorphNormals-Integer"><a href="#maxMorphNormals-Integer" class="headerlink" title="maxMorphNormals : Integer"></a>maxMorphNormals : Integer</h3><p>着色器中允许的最大变形法线数。标准材料仅允许4个变形法线。默认值为4</p>
<h3 id="physicallyCorrectLights-Boolean"><a href="#physicallyCorrectLights-Boolean" class="headerlink" title="physicallyCorrectLights : Boolean"></a>physicallyCorrectLights : Boolean</h3><p>是否使用物理上正确的照明模式。 默认值为false</p>
<h3 id="properties-Object"><a href="#properties-Object" class="headerlink" title="properties : Object"></a>properties : Object</h3><p>由渲染器在内部使用，以跟踪各种子对象属性</p>
<h3 id="renderLists-WebGLRenderLists"><a href="#renderLists-WebGLRenderLists" class="headerlink" title="renderLists : WebGLRenderLists"></a>renderLists : WebGLRenderLists</h3><p>在内部用于处理场景对象渲染的排序</p>
<p>shadowMap : WebGLShadowMap<br>如果使用，它包含阴影贴图的引用</p>
<h3 id="shadowMap-enabled-Boolean"><a href="#shadowMap-enabled-Boolean" class="headerlink" title="shadowMap.enabled : Boolean"></a>shadowMap.enabled : Boolean</h3><p>如果为true,在场景中使用阴影贴图。 默认值为false</p>
<h3 id="shadowMap-autoUpdate-Boolean"><a href="#shadowMap-autoUpdate-Boolean" class="headerlink" title="shadowMap.autoUpdate : Boolean"></a>shadowMap.autoUpdate : Boolean</h3><p>启用场景中阴影的自动更新。 默认为true<br>如果不需要动态光照/阴影，则可以在实例化渲染器时将其设置为false</p>
<h3 id="shadowMap-needsUpdate-Boolean"><a href="#shadowMap-needsUpdate-Boolean" class="headerlink" title="shadowMap.needsUpdate : Boolean"></a>shadowMap.needsUpdate : Boolean</h3><p>设置为true时，场景中的阴影贴图将在下一个渲染调用中更新,默认值为false<br>如果禁用了阴影贴图的自动更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">则需要将其设置为true，然后进行渲染调用以更新场景中的阴影</span><br><span class="line"></span><br><span class="line">### shadowMap.type : Integer</span><br><span class="line">定义阴影贴图类型  </span><br><span class="line">选项有**THREE.BasicShadowMap**，**THREE.PCFShadowMap**（默认），**THREE.PCFSoftShadowMap**</span><br><span class="line"></span><br><span class="line">### sortObjects : Boolean</span><br><span class="line">定义渲染器是否应对对象进行排序。 默认为true  </span><br><span class="line">注意：排序用于尝试正确渲染具有一定透明度的对象。 根据定义，排序对象可能无法在所有情况下使用。 根据应用的需要，可能需要关闭排序并使用其他方法来处理透明度渲染，例如， 手动确定每个对象的渲染顺序</span><br><span class="line"></span><br><span class="line">### state : Object</span><br><span class="line">包含用于设置WebGLRenderer.context状态的各种属性的函数</span><br><span class="line"></span><br><span class="line">### toneMapping: Constant</span><br><span class="line">默认为**LinearToneMapping**</span><br><span class="line"></span><br><span class="line">### toneMappingExposur： Number</span><br><span class="line">色调映射的曝光级别。 默认值为1</span><br><span class="line"></span><br><span class="line">### toneMappingWhitePoint : Number</span><br><span class="line">色调映射白点。 默认值为1</span><br><span class="line"></span><br><span class="line">## 方法</span><br><span class="line">### allocTextureUnit : Integer</span><br><span class="line">尝试分配纹理单元以供着色器使用。 如果尝试分配比GPU支持更多的纹理单元，则会发出警告。 这主要用于内部</span><br><span class="line"></span><br><span class="line">### clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : null</span><br><span class="line"></span><br><span class="line">告诉渲染器清除其颜色，深度或模板绘制缓冲区。 此方法将颜色缓冲区初始化为当前的清除色。</span><br><span class="line">参数默认为true</span><br><span class="line"></span><br><span class="line">### clearColor ( ) : null</span><br><span class="line">清除颜色缓冲区。 相当于调用```clear（true，false，false）</span><br></pre></td></tr></table></figure></p>
<h3 id="clearDepth-null"><a href="#clearDepth-null" class="headerlink" title="clearDepth(): null"></a>clearDepth(): null</h3><p>清除深度缓冲区。相当于调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### clearStencil ( ) : null</span><br><span class="line">清除模板缓冲区。相当于调用```clear（false，false，true）</span><br></pre></td></tr></table></figure></p>
<h3 id="compile-scene-Scene-camera-Camera-null"><a href="#compile-scene-Scene-camera-Camera-null" class="headerlink" title="compile ( scene : Scene, camera : Camera ) : null"></a>compile ( scene : Scene, camera : Camera ) : null</h3><p>使用相机编译场景中的所有材质。 这对于在第一次渲染之前预编译着色器很有用</p>
<h3 id="copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null"><a href="#copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null" class="headerlink" title="copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null"></a>copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null</h3><p>将当前WebGLFramebuffer中的像素复制到2D纹理中</p>
<h3 id="copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null"><a href="#copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null" class="headerlink" title="copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null"></a>copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null</h3><p>将纹理的所有像素复制到从给定位置开始的现有纹理</p>
<h3 id="dispose-null"><a href="#dispose-null" class="headerlink" title="dispose(): null"></a>dispose(): null</h3><p>处理当前渲染上下文</p>
<h3 id="extensions-get-extensionName-String-Object"><a href="#extensions-get-extensionName-String-Object" class="headerlink" title="extensions.get ( extensionName : String ) : Object"></a>extensions.get ( extensionName : String ) : Object</h3><p>用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息（如果可用）。 此方法可以检查以下扩展名：</p>
<pre><code>- WEBGL_depth_texture
- EXT_texture_filter_anisotropic
- WEBGL_compressed_texture_s3tc
- WEBGL_compressed_texture_pvrtc
- WEBGL_compressed_texture_etc1
</code></pre><h3 id="forceContextLoss-null"><a href="#forceContextLoss-null" class="headerlink" title="forceContextLoss ( ) : null"></a>forceContextLoss ( ) : null</h3><p>模拟WebGL上下文的丢失。 这需要支持WEBGL_lose_context扩展</p>
<h3 id="getClearAlpha-Float"><a href="#getClearAlpha-Float" class="headerlink" title="getClearAlpha () : Float"></a>getClearAlpha () : Float</h3><p>返回具有当前clear alpha的float。 范围从0到1</p>
<h3 id="getClearColor-Color"><a href="#getClearColor-Color" class="headerlink" title="getClearColor () : Color"></a>getClearColor () : Color</h3><p>返回具有当前清除色的THREE.Color实例</p>
<h3 id="getContext-WebGLRenderingContext"><a href="#getContext-WebGLRenderingContext" class="headerlink" title="getContext () : WebGLRenderingContext"></a>getContext () : WebGLRenderingContext</h3><p>返回当前WebGL上下文</p>
<h3 id="getContextAttributes-WebGLContextAttributes"><a href="#getContextAttributes-WebGLContextAttributes" class="headerlink" title="getContextAttributes () : WebGLContextAttributes"></a>getContextAttributes () : WebGLContextAttributes</h3><p>返回描述在创建WebGL上下文时设置的属性的对象</p>
<h3 id="getRenderTarget-RenderTarget"><a href="#getRenderTarget-RenderTarget" class="headerlink" title="getRenderTarget () : RenderTarget"></a>getRenderTarget () : RenderTarget</h3><p>返回当前的RenderTarget（如果有）</p>
<h3 id="getCurrentViewport-RenderTarget"><a href="#getCurrentViewport-RenderTarget" class="headerlink" title="getCurrentViewport () : RenderTarget"></a>getCurrentViewport () : RenderTarget</h3><p>返回当前视口</p>
<h3 id="getDrawingBufferSize-Object"><a href="#getDrawingBufferSize-Object" class="headerlink" title="getDrawingBufferSize () : Object"></a>getDrawingBufferSize () : Object</h3><p>返回包含渲染器绘图缓冲区宽度和高度的对象，单位px</p>
<h3 id="getPixelRatio-number"><a href="#getPixelRatio-number" class="headerlink" title="getPixelRatio () : number"></a>getPixelRatio () : number</h3><p>返回当前设备像素比率</p>
<h3 id="getSize-Object"><a href="#getSize-Object" class="headerlink" title="getSize () : Object"></a>getSize () : Object</h3><p>返回包含渲染器输出画布的宽度和高度的对象（单位px)</p>
<h3 id="resetGLState-null"><a href="#resetGLState-null" class="headerlink" title="resetGLState ( ) : null"></a>resetGLState ( ) : null</h3><p>将GL状态重置为默认值。 如果WebGL上下文丢失，则在内部调用</p>
<h3 id="readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null"><a href="#readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null" class="headerlink" title="readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null"></a>readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null</h3><p>将renderTarget中的像素数据读入的缓冲区。这是WebGLRenderingContext.readPixels（）的封装函数</p>
<h3 id="render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null"><a href="#render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null" class="headerlink" title="render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null"></a>render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null</h3><p>使用相机渲染场景<br>渲染到r<strong>enderTarget</strong>或canvas<br>如果<strong>forceClear</strong>为true，则即使<strong>autoClear</strong>属性为false，也会在渲染之前清除深度，模板和颜色缓冲区<br>即使将<strong>forceClear</strong>设置为true，也可以通过将<strong>autoClearColor</strong>，<strong>autoClearStencil</strong>或<strong>autoClearDepth</strong>属性设置为false来阻止清除某些缓冲区</p>
<h3 id="renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null"><a href="#renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null" class="headerlink" title="renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null"></a>renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null</h3><p>使用相机和指定材质渲染缓冲几何集合</p>
<h3 id="renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null"><a href="#renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null" class="headerlink" title="renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null"></a>renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null</h3><p>object - Object3D实例<br>program - shaderProgram实例<br>着色 -  Material实例   </p>
<p>渲染立即缓冲区。 由renderImmediateObject调用</p>
<h3 id="setAnimationLoop-callback-Function-null"><a href="#setAnimationLoop-callback-Function-null" class="headerlink" title="setAnimationLoop ( callback : Function ) : null"></a>setAnimationLoop ( callback : Function ) : null</h3><p>callback - 将在每个可用帧中调用该函数。 如果传递<code>null</code>，它将停止任何已经在进行的动画   </p>
<p>可以用来代替requestAnimationFrame的内置函数。 对于WebVR项目，必须使用此功能</p>
<h3 id="setClearAlpha-alpha-Float-null"><a href="#setClearAlpha-alpha-Float-null" class="headerlink" title="setClearAlpha ( alpha : Float ) : null"></a>setClearAlpha ( alpha : Float ) : null</h3><p>设置清除的alpha。 有效输入是介于0.0和1.0之间的浮点数</p>
<h3 id="setClearColor-color-Color-alpha-Float-null"><a href="#setClearColor-color-Color-alpha-Float-null" class="headerlink" title="setClearColor ( color : Color, alpha : Float ) : null"></a>setClearColor ( color : Color, alpha : Float ) : null</h3><p>设置清除色和不透明度</p>
<h3 id="setPixelRatio-value-number-null"><a href="#setPixelRatio-value-number-null" class="headerlink" title="setPixelRatio ( value : number ) : null"></a>setPixelRatio ( value : number ) : null</h3><p>设置设备像素比率。 这通常用于HiDPI设备，以防止画面模糊。</p>
<h3 id="setRenderTarget-renderTarget-WebGLRenderTarget-null"><a href="#setRenderTarget-renderTarget-WebGLRenderTarget-null" class="headerlink" title="setRenderTarget ( renderTarget : WebGLRenderTarget ) : null"></a>setRenderTarget ( renderTarget : WebGLRenderTarget ) : null</h3><p>renderTarget - 需要激活的renderTarget（可选）</p>
<p>此方法设置活动的rendertarget。 如果省略该参数，则将画布设置为活动的rendertarget</p>
<h3 id="setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null"><a href="#setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null" class="headerlink" title="setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null"></a>setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null</h3><p>将裁剪区域设置为（x，y）到（x + width，y + height）</p>
<h3 id="setScissorTest-boolean-Boolean-null"><a href="#setScissorTest-boolean-Boolean-null" class="headerlink" title="setScissorTest ( boolean : Boolean ) : null"></a>setScissorTest ( boolean : Boolean ) : null</h3><p>启用或禁用裁剪测试。 启用此选项后，只有定义的裁剪区域内的像素才会受到其他渲染器操作的影响</p>
<h3 id="setSize-width-Integer-height-Integer-updateStyle-Boolean-null"><a href="#setSize-width-Integer-height-Integer-updateStyle-Boolean-null" class="headerlink" title="setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null"></a>setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null</h3><p>将输出画布的大小调整为（width，height），并考虑设备像素比率，将视口调整为从（0,0）开始适应该尺寸的大小。 将updateStyle设置为false可防止对输出画布进行任何样式更改</p>
<h3 id="setTexture2D-texture-Texture-slot-number-null"><a href="#setTexture2D-texture-Texture-slot-number-null" class="headerlink" title="setTexture2D ( texture : Texture, slot : number ) : null"></a>setTexture2D ( texture : Texture, slot : number ) : null</h3><p>texture - 需要设置的纹理<br>slot - 指示纹理应使用哪个槽的数字  </p>
<p>此方法将正确的纹理设置为WebGL着色器的正确插槽。 可以找到槽号作为采样器的均匀值</p>
<h3 id="setTextureCube-cubeTexture-CubeTexture-slot-Number-null"><a href="#setTextureCube-cubeTexture-CubeTexture-slot-Number-null" class="headerlink" title="setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null"></a>setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null</h3><p>texture - 需要设置的cubeTexture。<br>slot - 指示纹理应使用哪个槽的数字。</p>
<p>此方法将正确的纹理设置为WebGL着色器的正确插槽， 可以找到槽号作为采样器的均匀值</p>
<p>setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null<br>将视口设置为从（x，y）到（x + width，y + height）</p>
<h1 id="WebGLRenderTarget"><a href="#WebGLRenderTarget" class="headerlink" title="WebGLRenderTarget"></a>WebGLRenderTarget</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>显卡为后台渲染场景的缓冲区，它用于不同的效果，例如在渲染图像显示在屏幕进行后期处理</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebGLRenderTarget(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>
<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="width-number"><a href="#width-number" class="headerlink" title="width : number"></a>width : number</h3><p>渲染目标的宽度</p>
<h3 id="height-number"><a href="#height-number" class="headerlink" title="height : number"></a>height : number</h3><p>渲染目标的高度</p>
<h3 id="scissor-Vector4"><a href="#scissor-Vector4" class="headerlink" title="scissor : Vector4"></a>scissor : Vector4</h3><p>渲染目标视口内的矩形区域。 区域外的部分将被裁剪</p>
<h3 id="scissorTest-boolean"><a href="#scissorTest-boolean" class="headerlink" title="scissorTest : boolean"></a>scissorTest : boolean</h3><p>是否激活裁剪测试</p>
<h3 id="viewport-Vector4"><a href="#viewport-Vector4" class="headerlink" title="viewport : Vector4"></a>viewport : Vector4</h3><p>渲染目标的视口</p>
<h3 id="texture"><a href="#texture" class="headerlink" title="texture"></a>texture</h3><p>此纹理实例保存渲染的像素,将其用作输入以进行进一步处理</p>
<h3 id="depthBuffer-boolean"><a href="#depthBuffer-boolean" class="headerlink" title="depthBuffer : boolean"></a>depthBuffer : boolean</h3><p>渲染到深度缓冲区。 默认为true</p>
<h3 id="stencilBuffer"><a href="#stencilBuffer" class="headerlink" title="stencilBuffer"></a>stencilBuffer</h3><p>渲染到深度缓冲区。 默认为true</p>
<h3 id="depthTexture-DepthTexture"><a href="#depthTexture-DepthTexture" class="headerlink" title="depthTexture : DepthTexture"></a>depthTexture : DepthTexture</h3><p>如果设置，则场景深度将呈现给此纹理。 默认值为null</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="setSize-width-Number-height-Number-null"><a href="#setSize-width-Number-height-Number-null" class="headerlink" title="setSize ( width : Number, height : Number ) : null"></a>setSize ( width : Number, height : Number ) : null</h3><p>设置渲染目标的尺寸</p>
<h3 id="clone-WebGLRenderTarget"><a href="#clone-WebGLRenderTarget" class="headerlink" title="clone () : WebGLRenderTarget"></a>clone () : WebGLRenderTarget</h3><p>创建渲染目标的克隆</p>
<h3 id="copy-source-WebGLRenderTarget-WebGLRenderTarget"><a href="#copy-source-WebGLRenderTarget-WebGLRenderTarget" class="headerlink" title="copy ( source : WebGLRenderTarget ) : WebGLRenderTarget"></a>copy ( source : WebGLRenderTarget ) : WebGLRenderTarget</h3><p>采用source中渲染目标的设置到该渲染目标</p>
<h3 id="dispose-null-1"><a href="#dispose-null-1" class="headerlink" title="dispose () : null"></a>dispose () : null</h3><p>调用dispose事件</p>
<h1 id="WebGLRenderTargetCube"><a href="#WebGLRenderTargetCube" class="headerlink" title="WebGLRenderTargetCube"></a>WebGLRenderTargetCube</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>使用立方体相机(CubeCamera)对象来作为WebGL渲染器目标(WebGLRenderTarget)</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebGLRenderTargetCube(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>
<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><h3 id="activeCubeFace-integer"><a href="#activeCubeFace-integer" class="headerlink" title="activeCubeFace : integer"></a>activeCubeFace : integer</h3><p>对应于立方体侧（PX 0，NX 1，PY 2，NY 3，PZ 4，NZ 5），由CubeCamera内部使用和设置</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承自<strong>WebGLRenderTarget</strong></p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>继承自<strong>WebGLRenderTarget</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/11/threejs解读 webGLRender/" data-id="cjpjvf0e500005yjihv9nn3h4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-threejs/">js threejs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-threejs 解读  scene" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/10/threejs 解读  scene/" class="article-date">
  <time datetime="2018-12-10T14:03:28.637Z" itemprop="datePublished">2018-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/threejs 解读  scene/">threejs 解读  scene</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>scene用来创建场景</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h2><p>创建一个scene对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scence()</span><br></pre></td></tr></table></figure></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="fog"><a href="#fog" class="headerlink" title="fog"></a>fog</h3><p>fog实例，定义场景中的雾状背景。默认是null</p>
<h3 id="overrideMaterial"><a href="#overrideMaterial" class="headerlink" title="overrideMaterial"></a>overrideMaterial</h3><p>如果不为null,它将使用其材质强制覆盖场景中所有对象。默认为null</p>
<h3 id="autoUpdate"><a href="#autoUpdate" class="headerlink" title="autoUpdate"></a>autoUpdate</h3><p>如果是ture,则每一帧自动检测矩阵更新.如果false,则需要手动维护矩阵更新。默认为true</p>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>如果不为null，则设置渲染场景时使用的背景，并始终先渲染。 可以设置为<strong>Color</strong>，<strong>Texture</strong>或<strong>CubeTexture</strong>。 默认为null</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h3><p>以JSON格式返回场景数据</p>
<h1 id="Fog"><a href="#Fog" class="headerlink" title="Fog"></a>Fog</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>此类包含定义线性雾的参数，即密度随着距离的增加呈线性增长</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>创建Fog对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fog( color : Integer, near : Float, far : Float )</span><br></pre></td></tr></table></figure></p>
<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>
<h1 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h1><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>
<h3 id="near"><a href="#near" class="headerlink" title="near"></a>near</h3><p>开始施雾的最小距离。距离当前相机小于near单位的对象，将不会受到雾的影响。默认为1</p>
<h3 id="far"><a href="#far" class="headerlink" title="far"></a>far</h3><p>结束施雾的最大距离。距离当前相机大于far单位的对象，将不会受到雾的影响。默认为1000</p>
<h1 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h1><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>
<h3 id="toJSON-1"><a href="#toJSON-1" class="headerlink" title="toJSON"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>
<h1 id="FogExp2"><a href="#FogExp2" class="headerlink" title="FogExp2"></a>FogExp2</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>此类包含定义指数雾的参数，即密度随着距离的增加呈指数增长</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>创建FogExp2对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FogExp2( color : Integer, density : Float )</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><h2 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h2><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>
<h2 id="color-1"><a href="#color-1" class="headerlink" title="color"></a>color</h2><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>
<h2 id="density"><a href="#density" class="headerlink" title="density"></a>density</h2><p>定义雾密度增加的速度，默认0.00025</p>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><h3 id="clone-1"><a href="#clone-1" class="headerlink" title="clone"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>
<h3 id="toJSON-2"><a href="#toJSON-2" class="headerlink" title="toJSON"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/10/threejs 解读  scene/" data-id="cjpie0t5i0000rsjinaoc4c3g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-threejs/">js threejs</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javascript &amp; ECMAScript &amp; es" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/javascript & ECMAScript & es/" class="article-date">
  <time datetime="2018-12-09T13:44:41.036Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/javascript & ECMAScript & es/">javascript &amp; ECMAScript &amp; es</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…"><a href="#JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…" class="headerlink" title="JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…"></a>JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能</p>
<p>JavaScript由三部分组成  </p>
<ol>
<li>ECMAScript  </li>
<li>DOM  </li>
<li>BOM</li>
</ol>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身</p>
<p><strong>ECMA</strong><br>Ecma国际（Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。</p>
<p>Ecma国际是一家和企业密切相连的组织，所以 Ecma国际制定的规范都是由各类企业来做主要的制定和推广</p>
<p><strong>TC39</strong><br>在ECMA国际，每个标准都会有一个 TC 来负责，而一个 TC 中可能会有不同的 TG 来负责不同的工作。而负责 ECMA262，也就是我们所说的 ECMAScript 的就是 TC39（以前叫 TC39-TG1）。<br><strong><em>TC（Technical Committees）</em></strong><br><strong><em>TG（Task Groups）</em></strong></p>
<p>要讲清ECMAScript，回顾历史。<br>1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。<br>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p><strong>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现</strong></p>
<p>ECMAScript 作为一门脚本程序设计语言标准，并不只有 javascript 这一种实现，它也有很多的方言实现。比如有下面这些语言：</p>
<p>JavaScript</p>
<p>Ejscript</p>
<p>JScript .NET</p>
<p>ActionScript</p>
<p>DMDScript</p>
<p>CriScript</p>
<p>InScript</p>
<h2 id="ES2015…"><a href="#ES2015…" class="headerlink" title="ES2015…"></a>ES2015…</h2><p><strong>ES2015</strong><br><strong>ECMAScript 2015</strong><br>ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。  </p>
<p><strong>ECMAScript 2016</strong><br>第七版 ECMAScript 修订，只加了Array.prototype.includes、Exponentiation Operator(求冥运算)</p>
<p><strong>ECMAScript 2017</strong><br>第八版 ECMAScript 修订<br>新增<br>Object.values/Object.entries<br>字符串填充    padStart()和padEnd()<br>Object.getOwnPropertyDescriptor<br>尾随逗号<br>异步函数async<br>共享内存和原子操作  </p>
<p><strong>ECMAScript 2018</strong><br>异步迭代<br>Promise.finally()<br>Rest/Spread 属性: ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符<br>正则表达式命名捕获组（Regular Expression Named Capture Groups）<br>正则表达式反向断言（lookbehind）<br>正则表达式dotAll模式<br>正则表达式 Unicode 转义<br>非转义序列的模板字符串</p>
<p><strong>ECMAScript Proposals</strong><br>被考虑加入未来版本 ECMAScript标准的特性与语法提案，他们需要经历五个阶段：</p>
<table>
<thead>
<tr>
<th>stage</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stage 0</td>
<td>strawman（稻草人）</td>
<td>任何人都可以提交pull request到<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">GitHub - tc39/ecma262: Status, process, and documents for ECMA262</a></td>
</tr>
<tr>
<td>Stage 1</td>
<td>Proposal（提议）</td>
<td>TC39制定成员作为 champion，TC39审阅通过，有实现的 Demo 或者 Polyfill初步描写标准的语义语法算法复杂度解决的问题等</td>
</tr>
<tr>
<td>Stage 2</td>
<td>Draft（草案）</td>
<td>有两个或两个以上的实现（包括babel这类的转译实现）使用正式的语言描述该语法，api等</td>
</tr>
<tr>
<td>Stage 3</td>
<td>Candidate（候选）</td>
<td>至少2个实现，可以为实验性实现，ECMAScript spec editor 通过审核，TC39 review 通过，文本编写完成</td>
</tr>
<tr>
<td>Stage 4</td>
<td>Finished （完成）</td>
<td>编写 test 262 测试用例，通过两个实现该特性的内核测试，ECMAScript spec editor 通过审核，开发者表示支持和认可</td>
</tr>
</tbody>
</table>
<p>对于有些人来说，前端的更新总是很突兀，很让人迷茫。</p>
<p>但是其实不是的。变化总是一点一点发生的。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/tc39/proposals" target="_blank" rel="noopener">GitHub - tc39/proposals: Tracking ECMAScript Proposals</a></p>
<p>我们可以在 TC39 的 Github 仓库中找到完成了，废弃的，以及正在进行中的提案。</p>
<p>多去关注这些东西，对于很多新事物的到来，我们也就不会有多惊讶了。</p>
<p><strong>其他ECMA标准</strong><br>和 ECMAScript 有关的标准有 ECMA262，ECMA290，ECMA327，ECMA357，ECMA402，ECMA404，ECMA414等等。</p>
<p>其中290，327，357等等没有推广开来，被废弃。</p>
<p>ECMA 262 是语言规范本身。</p>
<p>ECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。</p>
<p>ECMA 404 是 JSON 规范。</p>
<p>ECMA 414 则规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402和404。</p>
<h2 id="ES6…"><a href="#ES6…" class="headerlink" title="ES6…"></a>ES6…</h2><table>
<thead>
<tr>
<th>ES</th>
<th>ECMAScript</th>
</tr>
</thead>
<tbody>
<tr>
<td> ES6</td>
<td>ECMAScript 2015</td>
</tr>
<tr>
<td> ES7</td>
<td>ECMAScript 2016</td>
</tr>
<tr>
<td> ES8</td>
<td>ECMAScript 2017</td>
</tr>
<tr>
<td> ES9</td>
<td>ECMAScript 2018</td>
</tr>
</tbody>
</table>
<p> ES1：1997 年 6 月  ——  <br> ES2：1998 年 6 月  ——<br> ES3：1999 年 12月  ——  <br> ES4： 2007 年 10月  <strong>未通过</strong>  ——<br> ES5： 2009年12月  ——<br> ES5.1  2011年6月  ——</p>
<p><strong>ES4&amp;ES3.1</strong><br>在制定ES4的时候，是分成了两个工作组同时工作的。</p>
<p>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</p>
<p>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</p>
<p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新</p>
<p>最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，然后将一部分比较激进的部分放置到 ES.NEXT 中，命名为 Harmony（和谐），留待以后再进行商榷。接下来，ECMAScript  3.1 变成了 ECMAScript 5，而 ES.NEXT 中的那些特性，则有着相当一部分被ECMAScript 6，也就是 ECMAScript 2015 所吸收了。所以说虽然 ECMAScript 4 被废弃了，但是它终究还是通过另一种方式活了下来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/09/javascript & ECMAScript & es/" data-id="cjpgxwr8w00007gjizq4xa710" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-head-meta" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/06/head-meta/" class="article-date">
  <time datetime="2018-12-06T15:30:01.296Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/06/head-meta/">head-meta</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用 HTML5 doctype，不区分大小写 </p>
<pre><code>&lt;!DOCTYPE html&gt; 
</code></pre><p>单一的 zh 和 zh-CN 均属于废弃用法。<br>问题主要在于，zh 现在不是语言code了，而是macrolang，能作为语言code的是cmn（国语）、yue（粤语）、wuu（吴语）等。<br>通常建议写成 zh-cmn 而不是光写 cmn，主要是考虑兼容性（至少可匹配 zh），有不少软件和框架还没有据此更新。zh-CN 的问题还在于，其实多数情况下标记的是简体中文，但是不恰当的使用了地区<br>所以其实应该使用 zh-Hans / zh-Hant 来表示简体和繁体。</p>
<pre><code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;
</code></pre><p>  声明文档使用的字符编码   </p>
<pre><code>&lt;meta charset=&apos;utf-8&apos;&gt;
</code></pre><p>  优先使用 IE 最新版本和 Chrome  </p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;
</code></pre><p>页面描述    </p>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;
</code></pre><p> 页面关键词 </p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;
</code></pre><p> 网页作者 </p>
<pre><code>&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;
</code></pre><p> 搜索引擎抓取</p>
<pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
</code></pre><p> 为移动设备添加 viewport</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;
</code></pre><p>  <code>width=device-width</code> 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 <a href="http://bigc.at/ios-webapp-viewport-meta.orz" target="_blank" rel="noopener">http://bigc.at/ios-webapp-viewport-meta.orz</a> </p>
<p>  iOS 设备 begin<br>   添加到主屏后的标题（iOS 6 新增）</p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;
</code></pre><p>   是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 </p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;
</code></pre><p> 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</p>
<pre><code>&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;
</code></pre><p>设置苹果工具栏颜色<br>    <meta name="apple-mobile-web-app-status-bar-style" content="black"></p>
<p>忽略页面中的数字识别为电话，忽略email识别 </p>
<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;
</code></pre><p> 启用360浏览器的极速模式(webkit)<br>    <meta name="renderer" content="webkit"></p>
<p>避免IE使用兼容模式 </p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
</code></pre><p>不让百度转码 </p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;
</code></pre><p> 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</p>
<pre><code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;
</code></pre><p>微软的老式浏览器 </p>
<pre><code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;
</code></pre><p>   uc强制竖屏 </p>
<pre><code>&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;
</code></pre><p>  QQ强制竖屏</p>
<pre><code>&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;
</code></pre><p>   UC强制全屏</p>
<pre><code>&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;
</code></pre><p> QQ强制全屏 </p>
<pre><code>&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;
</code></pre><p>   UC应用模式</p>
<pre><code>&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;
</code></pre><p>   QQ应用模式</p>
<pre><code>&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;
</code></pre><p>  windows phone 点击无高光 </p>
<pre><code>&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre><p> iOS 图标 begin<br> iPhone 和 iTouch，默认 57x57 像素，必须有 </p>
<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;
</code></pre><p>Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有</p>
<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;
</code></pre><p>Retina iPad，144x144 像素，可以没有，但推荐有 </p>
<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;
</code></pre><p>iOS 图标</p>
<p>  iOS 启动画面 begin<br>  iPad 竖屏 768 x 1004（标准分辨率）</p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;
</code></pre><p>iPad 竖屏 1536x2008（Retina）</p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;
</code></pre><p>iPad 横屏 1024x748（标准分辨率）</p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;
</code></pre><p>iPad 横屏 2048x1496（Retina） </p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;
</code></pre><p> iPhone/iPod Touch 竖屏 320x480 (标准分辨率)</p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;
</code></pre><p>iPhone/iPod Touch 竖屏 640x960 (Retina) </p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;
</code></pre><p>iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) </p>
<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;
</code></pre><p> Windows 8 磁贴颜色</p>
<pre><code>&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;
</code></pre><p> Windows 8 磁贴图标 </p>
<pre><code>&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;
</code></pre><p>  添加 RSS 订阅<br>    <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"></p>
<p>添加 favicon icon<br>    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"></p>
<p> sns 社交标签 begin<br> 参考微博API </p>
<pre><code>&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;
</code></pre><p>sns 社交标签 end</p>
<pre><code>&lt;title&gt;标题&lt;/title&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/06/head-meta/" data-id="cjou118i20000xijgczp7dy6a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/head/">head</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-css杂记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/05/css杂记/" class="article-date">
  <time datetime="2018-12-05T14:43:52.402Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/05/css杂记/">css 杂记（持续补充）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><ul>
<li><strong>作用</strong><ul>
<li>让块元素水平居中</li>
<li>让元素之间留有间距</li>
<li>处理特殊的first，last</li>
<li>布局</li>
</ul>
</li>
<li><strong>要点</strong> <ul>
<li>margin折叠</li>
<li>margin百分比</li>
<li>margin的auto值</li>
<li>margin和相对偏移的异同</li>
<li>IE6浮动双margin Bug</li>
<li>IE6浮动相邻元素3px Bug  </li>
</ul>
</li>
</ul>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>一般auto计算值取决于可用空间</p>
<h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>默认在writing-mode:horizontal-tb和direction：ltr，百分比参照父级的宽度</p>
<h3 id="margin折叠"><a href="#margin折叠" class="headerlink" title="margin折叠"></a>margin折叠</h3><ul>
<li>垂直边毗邻  <ul>
<li>元素的上外边距和其属于常流中的第一个孩子的上外边距</li>
<li>元素的下外边距和其属于常流中的下一个兄弟的上外边距</li>
<li>属于常流中的最后一个孩子的下外边距和其父亲的下外边距</li>
<li>元素的上下外边距，如果该元素没有建立新的块级格式上下文，且min-height的计算值为0或auto，且没有属于常流中的孩子</li>
</ul>
</li>
</ul>
<h3 id="IE6浮动双倍margin-bug"><a href="#IE6浮动双倍margin-bug" class="headerlink" title="IE6浮动双倍margin bug"></a>IE6浮动双倍margin bug</h3><ul>
<li>解决方案<ol>
<li><code>_margin-left:*/2</code></li>
<li><code>_display:inline</code>  </li>
</ol>
</li>
</ul>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><ul>
<li>元素的层叠级别为整型，描述在相同层叠上下文中元素在z轴上的呈现顺序</li>
<li>同一层叠上下文中，层叠级别大的显示在上，相同层叠级别时，遵循后来居上的原则</li>
<li>不同层叠的上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关</li>
<li>当定位元素没有显式定义z-index值时，不会创建新的局部层叠上下文</li>
<li>子元素有可能和祖先的兄弟会长祖先兄弟的子元素处在同一个层叠上下文中</li>
<li>当opacity值小于1时，该元素会创建新的局部层叠上下文，</li>
<li>当opacity值小于1时，该元素拥有层叠级别相当于z-index：0或auto，但不能定义z-index，除非本身是定位元素</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/05/css杂记/" data-id="cjpba9hbq0000qkjini862bdy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-freemark" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/freemark/" class="article-date">
  <time datetime="2018-12-04T13:47:12.095Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/freemark/">freemark</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h1><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>  基于模板的，用来生成输出文本的通用工具<br>  适用于MVC模式，分离思想<br>  并非web的应用框架，只是框架中的一个组件，其引擎本身并不知道http协议或者servlet</p>
<h2 id="freemark-模板"><a href="#freemark-模板" class="headerlink" title="freemark 模板"></a>freemark 模板</h2><ul>
<li><code>${...}</code> interpolations 插值 </li>
<li><code>&lt;#&gt; &lt;/#&gt;</code> tags 标签  （<code>&lt;@&gt; &lt;/@&gt;</code> 自定义标签)</li>
<li><code>&lt;#--  --&gt;</code> comments 注释</li>
<li><code>&lt;table&gt;&lt;/tabel&gt;</code> directives 指令  </li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p>条件<br><code>&lt;#if boolean&gt;&lt;#else&gt;&lt;/#if&gt;</code></p>
<h3 id="list指令"><a href="#list指令" class="headerlink" title="list指令"></a>list指令</h3><p>循环<br><code>&lt;#list Array as array&gt;&lt;/#list&gt;</code></p>
<h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3><p>插入其他文件到当前模板<br><code>&lt;#include &quot;&quot;/&gt;</code></p>
<h3 id="处理不存在的变量"><a href="#处理不存在的变量" class="headerlink" title="处理不存在的变量"></a>处理不存在的变量</h3><p>变量不存在时使用default代替  </p>
<p><code>${...}!&quot;default&quot;</code>  </p>
<p>使用？？和if指令，变量不存在忽略代码段  </p>
<p><code>&lt;#if argument??&gt;&lt;/if&gt;</code></p>
<p><code>argument1.argument2.argument3!0</code><br>若argument1或argument2不存在，则模板处理会以“未定义变量”错误停止<br>通过<code>（argument1.argument2.argument3）!0</code> 方式防止这种错误</p>
<h3 id="用户自定义指令"><a href="#用户自定义指令" class="headerlink" title="用户自定义指令"></a>用户自定义指令</h3><p>如果能够实现，用自定义指令而不用函数/方法。<br>输出（返回值）的是标记（HTML,XML 等）。<br>主要原因是函数的返回结果可以自动进行 XML 转义<br>（这是因为${…}的特性），<br>而用户自定义指令的输出则不是<br>（这是<br>因为&lt;@…&gt;的特性所致，它的输出假定为是标记，因此就不再转义）。</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p><strong>特殊字符</strong> 原生字符 <code>${r&quot;${foo}&quot;}</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/04/freemark/" data-id="cjp9ssssn000050ji7jo2pidl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/freemark-模板/">freemark 模板</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器渲染" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/浏览器渲染/" class="article-date">
  <time datetime="2018-12-03T15:03:31.878Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/浏览器渲染/">浏览器渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从浏览器角度谈渲染"><a href="#从浏览器角度谈渲染" class="headerlink" title="从浏览器角度谈渲染"></a>从浏览器角度谈渲染</h2><ul>
<li>之前更多的优化是从页面资源的数量，传输是否采用了压缩，JS、cSS，是否进行了精简，缓存有没有合理的使用</li>
<li>这次从另一个角度谈页面的渲染，浏览器是如何工作的，要把页面渲染出来，浏览器需要做什么，哪些过程比较耗时</li>
<li>浏览器工作原理<img src="http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib1uAwicF98dVY5j2dib36rQkOw6lnb7Jls3Gd1BBbp5bhk81Q4qkfOFnO7hyXO1bFNdCg6cDVvasj5A/0?wx_fmt=jpeg" alt="浏览器工作原理"><ul>
<li>加载HTML</li>
<li>解析HTML，生成DOM</li>
<li>加载CSS，JS</li>
<li>解析CSS，生成CSSOM</li>
<li>JS引擎执行JS</li>
<li>合并DOM和CSSOM，生成Render Tree</li>
<li>根据Render Tree 进行布局</li>
<li>绘制每个层中的元素</li>
<li>合并图层</li>
</ul>
</li>
</ul>
<ul>
<li>方案：加快完成DOM+CSSOM-Layout-Paint-Composite的整个过程<ul>
<li>分割css<br>对不同的浏览终端，同一终端的不同模式，提供不同的规则（通俗讲屏幕大小和宽高比）把媒体查询放在link上，根据终端情况加载不同的css文件</li>
</ul>
</li>
</ul>
<ul>
<li>css规则的优先级<br>css权重计算的无形增加<br><strong>css选择器解析从右往左还是从左往右？？</strong><br>过多的嵌套规则，会导致复杂的，无必要的深层次规则（SASS，LESS开发过程中尤为明显）<br>css规则越复杂，构建Render Tree时，浏览器花费的时间越长  </li>
</ul>
<ul>
<li><p>使用GPU加速<br> 很多的动画定时的执行，会导致浏览器的重新布局  </p>
<pre><code>      @keyframes my {
     20% {
      top: 10px;
      }

  50% {
      top: 120px;
  }

  80% {
      top: 10px;
  }
} 
</code></pre><p> 这些执行可以放到GPU加速执行  </p>
<pre><code> @keyframes my {
  20% {
      transform: translateY(10px);
  }

  50% {
      transform: translateY(120px);
  }

  80% {
      transform: translateY(10px);
  }
}
</code></pre></li>
</ul>
<pre><code>jQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 

jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。

jQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bu    
**setTimeOut和FAF（单人淋浴间和大澡堂）**    
</code></pre><p>–</p>
<pre><code>var startingTop = 0;
        setInterval(function() {
            element.style.top = (startingTop += 1/60);
        }, 16);


        function tick () {
            element.style.top = (startingTop += 1/60);
        }
        window.requestAnimationFrame(tick);
</code></pre><p>–<br>  requestAnimationFrame<br>  setTimeout间隔设置过小，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。    </p>
<p>  而requestAnimationFrame就是为了这个而出现的。所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧  </p>
<p>  优势：向下兼容 、相比于css3动画应用更广、动画效果更多</p>
<p>  CSS transition 的动画逻辑是由浏览器来执行，所以它的性能能够比 jQuery 动画好。它的优势体现在：</p>
<p>通过优化 DOM 操作，避免内存消耗来减少卡顿<br>使用与 RAF 类似的机制<br>强制使用硬件加速 （通过 GPU 来提高动画性能）  </p>
<ul>
<li><p>异步JavaScript<br>js执行会阻塞DOM构建的过程，Js中可能存在dom操作 async异步  </p>
<p>js可能会不断的重新布局，重新绘制  </p>
<pre><code>1.访问元素的某些属性  
2.通过JavaScript修改元素的CSS属性  
3.在onScroll中做耗时的任务  
4.在其他Event Handler中做耗时的任务  
5.图片的预处理  
6.过多的动画  
7.过多的数据处理  
</code></pre><p>元素的一些属性和方法，当被访问或调用的时候，会触发浏览器的布局和绘制，布局基本上会影响页面的大部分元素，导致耗时长  </p>
<p>为了避免之前提到的布局颠簸，我们需要批量访问和更新DOM。</p>
<pre><code>    var currentTop,
    currentLeft;
/* 有 layout thrashing. */
currentTop = element.style.top; /* 访问 */
element.style.top = currentTop + 1; /* 更新 */

currentLeft = element.style.left; /* 访问 */
element.style.left = currentLeft + 1; /* 更新 */

/* 没有 layout thrashing. */
currentTop = element.style.top; /* 访问 */
currentLeft = element.style.left; /* 访问 */

element.style.top = currentTop + 1; /* 更新 */
element.style.left = currentLeft + 1; /* 更新 */
</code></pre><p>计算offset 时，浏览器需要重新计算（重新布局），然后才能返回最新的值 </p>
<pre><code>       for(var i = 0; i &lt; list.length; i++) {
  list[i].style.width = parent.offsetWidth + &apos;px&apos;;
}   
</code></pre></li>
</ul>
<pre><code>var parentWidth = parent.offsetWidth;
for(var i = 0; i &lt; list.length; i++) {
  list[i].style.width = parentWidth + &apos;px&apos;;
}
</code></pre><ul>
<li>css样式修改  </li>
<li>修改布局相关属性，会触发Layout-Paint-Composite</li>
<li>修改绘制相关属性，会触发Paint-Composite</li>
<li><p>其他属性，某些特别属性可在不同层中单独绘制，在合并图层，就是直接Composite  （transform，opacity）</p>
<p>在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。</p>
<p><strong>类比电梯</strong></p>
<pre><code>// 防抖动函数
</code></pre><p>   function debounce(func, wait, immediate) {</p>
<pre><code>var timeout;
return function() {
    var context = this, args = arguments;
    var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
    };
    var callNow = immediate &amp;&amp; !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
};
</code></pre><p>   };</p>
<p>   var myEfficientFn = debounce(function() {</p>
<pre><code>// 滚动中的真正的操作
</code></pre><p>   }, 250);</p>
<p>   // 绑定监听</p>
<h2 id="window-addEventListener-‘resize’-myEfficientFn"><a href="#window-addEventListener-‘resize’-myEfficientFn" class="headerlink" title="   window.addEventListener(‘resize’, myEfficientFn);"></a>   window.addEventListener(‘resize’, myEfficientFn);</h2><pre><code>   // 简单的节流函数
function throttle(func, wait, mustRun) {
    var timeout,
        startTime = new Date();

    return function() {
        var context = this,
            args = arguments,
            curTime = new Date();

        clearTimeout(timeout);
        // 如果达到了规定的触发时间间隔，触发 handler
        if(curTime - startTime &gt;= mustRun){
            func.apply(context,args);
            startTime = curTime;
        // 没达到触发间隔，重新设定定时器
        }else{
            timeout = setTimeout(func, wait);
        }
    };
</code></pre><p>   };<br>   // 实际想绑定在 scroll 事件上的 handler<br>   function realFunc(){</p>
<pre><code>console.log(&quot;Success&quot;);
</code></pre><p>   }<br>   // 采用了节流函数<br>   window.addEventListener(‘scroll’,throttle(realFunc,500,1000));</p>
</li>
</ul>
<pre><code>pointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。
</code></pre><p>will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。  </p>
<p><strong>类比萨里机长</strong></p>
<p>值得注意的是，用好这个属性并不是很容易：  </p>
<p>不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。  </p>
<p>不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。  </p>
<p>给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。</p>
<p><strong>Unable to preventDefault inside passive event listener due to target being treated as passive</strong></p>
<p>   window.addEventListener(“touchstart”, func, {passive: true} );</p>
<p>   window, document , body</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/12/03/浏览器渲染/" data-id="cjp8g36rk0000ntji9mvtv4cs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/浏览器/">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器与内核" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/27/浏览器与内核/" class="article-date">
  <time datetime="2018-11-27T14:14:58.200Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/27/浏览器与内核/">浏览器与内核</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h2><p>IE内核<br>IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色</p>
<p>国内很多的双核浏览器的其中一核便是 Trident</p>
<p>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML</p>
<h2 id="Gecko"><a href="#Gecko" class="headerlink" title="Gecko"></a>Gecko</h2><p>Firefox 内核  </p>
<h2 id="Webkit"><a href="#Webkit" class="headerlink" title="Webkit"></a>Webkit</h2><p>safari<br>早期chrome  </p>
<h2 id="Chromium-Blink"><a href="#Chromium-Blink" class="headerlink" title="Chromium/Blink"></a>Chromium/Blink</h2><p>chrome<br>chromium fork 自开源引擎 webkit</p>
<h2 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h2><p>早期oprea  </p>
<h2 id="关于移动端"><a href="#关于移动端" class="headerlink" title="关于移动端"></a>关于移动端</h2><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>
<p>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/11/27/浏览器与内核/" data-id="cjoztpcqa00002jjgqwxyq0u8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/浏览器/">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-跨域" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/跨域/" class="article-date">
  <time datetime="2018-11-26T15:04:04.999Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/跨域/">跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>协议，域名，端口任何一项不同都会引起跨域问题<br>注意： 下面讨论的解决方案都是针对于域名引起的跨域的，协议和端口的跨域前端无能为力  </p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><h2 id="1-document-domain-iframe"><a href="#1-document-domain-iframe" class="headerlink" title="1.document.domain + iframe"></a>1.document.domain + iframe</h2><p>只有主域相同才能使用  </p>
<pre><code>//parent.domain.com/a.html
document.doman = &apos;domain.com&apos;
var ifr = document.createElement(&apos;iframe&apos;)
ifr.src = &apos;child.domain.com/b.html&apos;
ifr.display = none;
document.body.appendChild(ifr);
ifr.onload = function () {
    var doc = ifr.contentDocument || ifr.contentWindow.document
    //doc 
     ifr.onload = null;
}
</code></pre><p>–</p>
<pre><code>//child.domain.com/b.html
document.domain = &apos;domain.com&apos;
</code></pre><h2 id="2-动态创建script"><a href="#2-动态创建script" class="headerlink" title="2.动态创建script"></a>2.动态创建script</h2><pre><code>function loadScript(url, func) {
  var head = document.head || document.getElementByTagName(&apos;head&apos;)[0];
  var script = document.createElement(&apos;script&apos;);
  script.src = url;

  script.onload = script.onreadystatechange = function(){
    if(!this.readyState || this.readyState==&apos;loaded&apos; || this.readyState==&apos;complete&apos;){
      func();
      script.onload = script.onreadystatechange = null;
    }
  };

  head.insertBefore(script, null);
}
window.baidu = {
  sug: function(data){
    console.log(data);
  }
}
loadScript(&apos;http://suggestion.baidu.com/su?wd=w&apos;,function(){console.log(&apos;loaded&apos;)});    
</code></pre><h2 id="3-loaction-hash-iframe"><a href="#3-loaction-hash-iframe" class="headerlink" title="3.loaction.hash+ iframe"></a>3.loaction.hash+ iframe</h2><pre><code>    //a.com/a.html
function startRequest(){
    var ifr = document.createElement(&apos;iframe&apos;);
    ifr.style.display = &apos;none&apos;;
    ifr.src = &apos;http://b.com/b.html#paramdo&apos;;
        document.body.appendChild(ifr);
}

function checkHash() {
    try {
        var data = location.hash ? location.hash.substring(1) : &apos;&apos;;
        if (console.log) {
            console.log(&apos;Now the data is &apos;+data);
        }
    } catch(e) {};
}
setInterval(checkHash, 2000);
</code></pre><p>–<br>    //b.com/b.html<br>    //模拟一个简单的参数处理操作<br>    switch(location.hash){<br>        case ‘#paramdo’:<br>            callBack();<br>            break;<br>        case ‘#paramset’:<br>            //do something……<br>            break;<br>    }</p>
<pre><code>function callBack(){
    try {
        parent.location.hash = &apos;somedata&apos;;
    } catch (e) {
        // ie、chrome的安全机制无法修改parent.location.hash，
        // 所以要利用一个中间的cnblogs域下的代理iframe
        var ifrproxy = document.createElement(&apos;iframe&apos;);
        ifrproxy.style.display = &apos;none&apos;;
        ifrproxy.src = &apos;http://a.com/c.html#somedata&apos;;    // 注意该文件在&quot;a.com&quot;域下
        document.body.appendChild(ifrproxy);
    }
}    
</code></pre><p>–<br>    //<a href="http://a.com/c.html" target="_blank" rel="noopener">http://a.com/c.html</a><br>    parent.parent.location.hash = self.location.hash.substring(1);</p>
<h2 id="4-window-name-iframe"><a href="#4-window-name-iframe" class="headerlink" title="4.window.name + iframe"></a>4.window.name + iframe</h2><p>window.name :name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB)  </p>
<pre><code>    //a.com/a/html
            function proxy(url,func) {
    var isFirst = true;
    var ifr = document.createElement(&apos;iframe&apos;);
    loadFunc = function() {
        console.log(1,isFirst)
        if(isFirst) {
            ifr.src = &apos;a.com/cs1.html&apos;;
            isFirst = false;
        } else {
            console.log(&apos;name&apos;,ifr.contentWindow.name)
            func(ifr.contentWindow.name);
            document.body.removeChild(ifr);
            ifr.src = null;
            ifr = &apos;&apos;;
        }

    }
     ifr.src = url;
    ifr.style.display = &apos;none&apos;;
    if(ifr.attachEvent){ ifr.attachEvent(&apos;onload&apos;, loadFunc);
}else {ifr.onload = loadFunc;}
     document.body.appendChild(ifr);
}

 proxy(&apos;http://www.baidu.com/&apos;, function(data){
      console.log(&apos;data&apos;,data);
    });
</code></pre><h2 id="5-postMessage"><a href="#5-postMessage" class="headerlink" title="5.    postMessage"></a>5.    postMessage</h2><pre><code>a.com/index.html中的代码：
&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function() {
    var ifr = document.getElementById(&apos;ifr&apos;);
       var targetOrigin = &apos;http://b.com&apos;;
     // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样
      // 若写成&apos;http://c.com&apos;就不会执行postMessage了
       ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);
};
&lt;/script&gt;

//b.com/index.html
window.addEventListener(&apos;message&apos;, function(event){
        // 通过origin属性判断消息来源地址
        if (event.origin == &apos;http://a.com&apos;) {
            alert(event.data);    // 弹出&quot;I was there!&quot;
            alert(event.source);  
            // 对a.com、index.html中window对象的引用
            // 但由于同源策略，这里event.source不可以访问window对象
        }
    }, false);
</code></pre><h2 id="6-CORS"><a href="#6-CORS" class="headerlink" title="6.CORS"></a>6.CORS</h2><h2 id="7-JSONP"><a href="#7-JSONP" class="headerlink" title="7.JSONP"></a>7.JSONP</h2><pre><code>    function handleResponse(response){
    console.log(&apos;The responsed data is: &apos;+response.data);
}
var script = document.createElement(&apos;script&apos;);
script.src = &apos;http://www.baidu.com/json/?callback=handleResponse&apos;;
document.body.insertBefore(script, document.body.firstChild);
/*handleResonse({&quot;data&quot;: &quot;zhe&quot;})*/
//原理如下：
//当我们通过script标签请求时
//后台就会根据相应的参数(json,handleResponse)
//来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))
//最后这个返回的json数据(代码)就会被放在当前js文件中被执行
//至此跨域通信完成
</code></pre><h2 id="8-web-socket"><a href="#8-web-socket" class="headerlink" title="8.web socket"></a>8.web socket</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/11/26/跨域/" data-id="cjoyft7bp0000nljgn33pwduk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex&amp;grid" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/22/flex&grid/" class="article-date">
  <time datetime="2018-11-22T14:45:53.235Z" itemprop="datePublished">2018-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/22/flex&grid/">flex &amp; grid 布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><ul>
<li><strong>容器的声明</strong><br>Flex是Flexible Box的缩写，意为”弹性布局”<br>任何容器，我们均可以将它指定为flex布局，行内元素也可以使用Flex布局，Webkit内核的浏览器，必须加上-webkit前缀<br>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效</li>
</ul>
<pre><code>  .box{
    display:flex;
    }


  .box{  
  display:inline-flex;
  }

  .box{
  display:-webkit-flex;
  display:flex;
}
</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> <img src="http://oczira72b.bkt.clouddn.com/grid-flex-2.png" alt=""><br> 采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）<br> 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ol>
<li><p><strong>flex-direction</strong><br>该属性决定主轴的方向</p>
<pre><code>     .box {
  flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-5.jpg" alt=""></p>
</li>
<li><p><strong>flex-wrap</strong><br>如果一条轴线排不下，如何换行  </p>
<pre><code>.box{
     flex-wrap: nowrap | wrap | wrap-reverse;
   }
</code></pre><p> nowrap为默认值，代表不换行。<br> wrap代表换行，但默认为第一行在上方。<br> wrap-reverse代表换行，但默认为第一行在下方。     </p>
</li>
<li><strong>flex-flow</strong><br>flex-flow属性是<strong>flex-direction</strong>属性和<strong>flex-wrap</strong>属性的简写形式，默认值为<strong>row nowrap</strong></li>
</ol>
<pre><code> .box {
  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}
</code></pre><ol start="4">
<li><p><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上的对齐方式。</p>
<pre><code>   .box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre><p>flex-start为默认值，代表项目在主轴上向起始方向对齐<br>flex-end代表项目在主轴上向结束方向对齐<br>center代表项目在主轴上居中对齐<br>space-between代表项目在主轴上两端对齐，但第一个项目在主轴的起始位置，最后一个项目在主轴的结束位置<br>space-around代表项目在主轴上等分间距，但第一个项目与最后一个项目距离主轴的两端保持一定的距离，这个距离为项目之间间距的1/2<br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-7.jpg" alt=""></p>
</li>
<li><p><strong>align-items</strong><br>align-items属性定义项目在交叉轴上如何对齐。</p>
<pre><code>.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-8.jpg" alt=""><br>flex-start代表项目在交叉轴上向起始方向对齐。<br>flex-end代表项目在交叉轴上向结束方向对齐。<br>center代表项目在交叉轴上居中对齐。<br>baseline代表项目在交叉轴上向项目的第一行文字的基线对齐。<br>stretch代表项目在交叉轴上拉伸对齐。 </p>
</li>
<li><p><strong>align-content</strong><br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code>.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
</code></pre><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-9.jpg" alt="">  </p>
</li>
</ol>
<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ol>
<li><p><strong>order</strong><br>order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0  </p>
<pre><code>  .item {
  order: &lt;integer&gt;;
}
</code></pre><p> <img src="http://oczira72b.bkt.clouddn.com/grid-flex-10.jpg" alt=""> </p>
</li>
</ol>
<p>2.<strong>flex-grow</strong><br>  flex-grow定义了项目的放大比例。如果所有伸缩项目的flex-grow设置了1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了flex-grow值为2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。</p>
<p>ps：负值对该属性无效。  </p>
<pre><code>.item {
    flex-grow: &lt;number&gt;; /* default 0 */
}
</code></pre><p> <img src="http://oczira72b.bkt.clouddn.com/grid-flex-11.jpg" alt=""></p>
<ol start="3">
<li><strong>flex-shrink</strong><br>类似于flex-grow，flex-shrink定义了项目的缩小比例。其默认值为1  </li>
</ol>
<p>如果所有项目的flex-shrink都为1，当空间不足时，都将等比例缩小  </p>
<p>如果所有项目都为1，但其中一个项目的flex-shrink为0，即代表空间不足时，该项目缩小0倍，即为不缩小  </p>
<p>ps：负值对该属性不起作用。<br> <img src="http://oczira72b.bkt.clouddn.com/grid-flex-12.jpg" alt=""></p>
<ol start="4">
<li><p><strong>flex-basis</strong><br>flex-basis定义了在分配多余空间之前，项目占据的主轴空间。览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<pre><code>  .item {
    flex-basis: &lt;length&gt; | auto; /* default auto */
}
</code></pre></li>
</ol>
<p>利用flex-basis，我们可以很容易实现页面布局中的常见问题：两栏/三栏布局</p>
<pre><code>    &lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;
&lt;/div&gt;


        .box {
    display: flex;
    height: 200px;
        }
        .left {
            background-color: yellow;
            flex-basis: 200px;
    /* flex-basis定义该项目在分配主轴空间之前提前获得200px的空间 */
            flex-grow: 0;
            /* flex-grow定义该项目不分配剩余空间 */
        }
        .main {
            background-color: green;
            flex-grow: 1;
            /* flex-grow定义main占满剩余空间 */
        }
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-13.jpg" alt=""></p>
<p>5.<strong>flex</strong><br>flex是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<pre><code>.item {
    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
}
</code></pre><ol start="6">
<li><strong>align-self</strong><br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。    </li>
</ol>
<h1 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>grid 布局。是一个基于网格的二维布局系统。grid是第一个专门为了解决那些我们一直使用 hack 手段而导致的页面布局问题而创建的CSS模块。<br>一个grid容器的内容：  </p>
<ul>
<li>可以将应用程序分割成不同的空间  </li>
<li>可以定义子项的大小、位置以及层级。</li>
<li>与表格类似的是：可以让Web设计师根据元素按列或行对齐排列。</li>
<li>可以定位自己的位置，这样他们可以重叠和类似元素定位。</li>
<li>可以通过结合CSS的媒体查询属性，根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容  </li>
</ul>
<p><strong>浏览器支持</strong><br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-25.jpg" alt=""></p>
<p>采用grid布局的元素，称为grid容器（grid container）。它的所有子元素自动成为容器成员，称为grid项目（grid item）。</p>
<p>分隔的线组成了网格的结构。它们可以是垂直的（“列网格线”）或者水平的（“行网格线”），也可以在行或列的任一边。下面的例子中黄色的线是一个列网格线的例子。<br><strong>网格线</strong><br>每条网格线具有默认的编号，从左到右和从上到下分别为1,2,3……<br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-3.jpg" alt=""><br><strong>网格单元</strong><br>网格单元是指两根毗邻的行网格线和列网格线中间的位置，它是一个单独的网格“单元”，如图所示，网格单元是指第 1 和 2 根行网格线和第 2 和 3 根列网格线中间的位置。<br><img src="http://oczira72b.bkt.clouddn.com/flex-grid-4.png" alt=""><br><strong>网格轨迹</strong><br>网格轨迹是指两根毗邻线中间的位置，可以认为是网格的行或者列<br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-26.png" alt=""><br><strong>网格区域</strong><br>网格区域是指 4 根网格线包围的空间，一个网格空间可能由任意数量的网格单元构成<br><img src="http://oczira72b.bkt.clouddn.com/grid-flex-27.png" alt="">  </p>
<h2 id="容器的属性-1"><a href="#容器的属性-1" class="headerlink" title="容器的属性"></a>容器的属性</h2><ol>
<li><p><strong>disaplay</strong><br>display属性定义了一个网格容器，容器是展现为行内或块状由所给定的值而决定，此时，他的所有子元素进入grid文档流，称为grid项目 </p>
<pre><code>.box {
    display: grid | inline-grid | subgrid;
}
</code></pre><p>grid定义了一个网格容器，它以块级元素的形式显示<br>inline-grid定义了一个网格容器，它以内联元素的形式显示<br>subgrid定义了一个网格容器，这个网格容器是其父级网格容器的一个子项。它的行和列的大小从父级网格容器中获取  </p>
</li>
<li><p><strong>grid-template-columns | grid-template-rows</strong><br>grid-template-rows和grid-template-columns定义了一个网格的列数、行数以及网格的大小。</p>
<pre><code>.box {
        grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;
        grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;
    }
</code></pre><p>定义网格单元的宽高，其单位可以是一个长度(如px、em、rem、vw、vh)或百分比，也可以是网格中自由空间的份数(单位为fr)<br>定义网格线的名称，它不是必须值。可以一个你选择的任意名字，当没有显示设定时，它的名字以数字表示。  </p>
<pre><code>.box {
    grid-template-columns: 40px 50px auto 50px 40px;
    grid-template-rows: 25% 100px auto;
}
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-28.png" alt=""></p>
<pre><code>.box {
    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];
    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];
}
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-29.png" alt=""></p>
</li>
</ol>
<p>一根网格线可以有多个名字，例如在下面的例子中第二根线有两个名字：row1-end 和 row2-start，命名方式以空格来作为间隔。</p>
<pre><code>.box{
    grid-template-rows:[row1-start] 25% [row1-end row-start] 25% [row-end];
    }
</code></pre><p>定义了容器的重复部分，你可以使用CSS的repeat()方法来生成多个相同值：</p>
<pre><code>.box {
    grid-template-columns: repeat(3, 20px [col-start]) 5%;
}

.box {
    grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;
}
</code></pre><p>fr是一个特殊的单位，它可以类似于设定flex-grow时，给网格容器中的自由空间设置为一个份数，举个例子，下面的例子将把网格容器的每个子项设置为三分之一</p>
<pre><code>.box {
    grid-template-columns: 1fr 1fr 1fr;
}
</code></pre><p>也是类似于flex-grow，自由空间是在固定子项确定后开始计算的（这里就如同flex-basis提前给予宽高那样），在下面的例子中自由空间是fr单位的总和但不包括50px：<br>            .box {<br>                grid-template-columns: 1fr 50px 1fr 1fr;<br>            }</p>
<ol start="3">
<li><p><strong>grid-template-areas</strong><br>grid-template-areas可以配合gird-area定义一个显示的网格区域。<br>grid-template-areas定义网格区域，然后使用grid-area调用声明好的网格区域名称来放置对应的网格项目  </p>
<pre><code> &lt;section class=&quot;grid&quot;&gt;
    &lt;div class=&quot;title&quot;&gt;title&lt;/div&gt;
    &lt;div class=&quot;nav&quot;&gt;nav&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;
    &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt;
    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;
&lt;/section&gt;  
.grid {
        display: grid;
        grid-template-columns: 100px 100px 100px 100px 100px;
        grid-template-rows: 100px 100px 100px 100px;
        grid-template-areas: &apos;title title title title aside&apos;
                              &apos;nav main main main aside&apos;
                              &apos;nav main main main aside&apos;
                              &apos;footer footer footer footer footer&apos;;
        font-size: 30px;
        text-align: center;
    }
    .title {
        grid-area: title;
        background-color: blue;
    }
    .nav {
        grid-area: nav;
        background-color: yellow;
    }
    .main {
        grid-area: main;
        background-color: gray;
    }
    .aside {
        grid-area: aside;
        background-color: green;
    }
    .footer {
        grid-area: footer;
        background-color: pink;
    }
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-30.jpg" alt="">   </p>
</li>
<li><p><strong>grid-column-gap|grid-row-gap</strong><br>grid-column-gap和grid-row-gap定义了网格之间的间距</p>
<pre><code>   .box {
    grid-template-columns: 100px 50px 100px;
    grid-template-rows: 80px auto 80px;
    grid-column-gap: 10px;
    grid-row-gap: 15px;
}
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-31.png" alt=""> </p>
</li>
</ol>
<p>5.<strong>justify-items</strong><br>justify-items定义了网格子项的内容和列轴对齐方式，即水平方向上的对齐方式  </p>
<pre><code>.box {
    justify-items: start | end | center | stretch;
}
</code></pre><p>start代表内容和网格区域的左边对齐<br>end代表内容和网格区域的右边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的宽度  </p>
<ol start="6">
<li><p><strong>align-items</strong><br>类似于justify-items，align-items定义了网格子项的内容和行轴对齐方式，即垂直方向上的对齐方式。</p>
<pre><code> .box {
    align-items: start | end | center | stretch;
}
</code></pre></li>
</ol>
<p>start代表内容和网格区域的上边对齐<br>end代表内容和网格区域的下边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的高度  </p>
<ol start="7">
<li><p><strong>justity-content|align-content</strong><br>justify-content属性定义了网格和网格容器列轴对齐方式  </p>
<pre><code>  .box {
    justify-content|align-content: start | end | center | stretch | space-around | space-between | space-evenly;
}
</code></pre><p>start代表网格在网格容器(左|上）边对齐<br>end代表网格在网格容器(右|下)边对齐<br>center代表网格在网格容器中间对齐<br>stretch改变网格子项的容量让其填充整个网格容器宽度<br>space-around代表在每个网格子项中间放置均等的空间，在始末两端只有一半大小<br>space-between代表在每个网格子项中间放置均等的空间，在始末两端没有空间<br>space-evenly代表在每个网格子项中间放置均等的空间，包括始末两端  </p>
</li>
<li><p><strong>grid-auto-columns|grid-auto-rows</strong><br>grid-auto-columns与grid-auto-rows可以指定隐式网格。</p>
<pre><code>   &lt;div class=&quot;grid&quot;&gt;
    &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;
    &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;
    &lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt;
    &lt;div class=&quot;box4&quot;&gt;box4&lt;/div&gt;
&lt;/div&gt;
      .grid {
        display: grid;
        grid-template-columns: 200px;
        grid-template-rows: 200px;
        text-align: center;
        font-size: 30px;
    }
    .box1 {
        background-color: pink;
        grid-column: 1;
        grid-row: 1;
    }
    .box2 {
        background-color: yellow;
        grid-column: 2;
        grid-row: 1;
    }
    .box3 {
        background-color: gray;
        grid-column: 1;
        grid-column: 2;
    }
    .box4 {
        background-color: blue;
        grid-column: 2;
        grid-row: 2;
    }
</code></pre></li>
</ol>
<p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-54.jpg" alt=""><br>通过grid-auto-columns与grid-auto-rows属性，创建一个隐式的2×2的网格  </p>
<pre><code>grid-auto-columns: 300px;
grid-auto-rows: 300px;
</code></pre><p><img src="http://oczira72b.bkt.clouddn.com/grid-flex-55.jpg" alt="">  </p>
<ol start="9">
<li><p><strong>grid-auto-flow</strong><br>grid布局自身具有的自动布局算法会将网格子项自动放置起来，而grid-auto-flow属性控制自动布局算法如何工作</p>
<pre><code>.box {
 grid-auto-flow: row | column | row dense | column dense
</code></pre><p> }</p>
</li>
</ol>
<p>row为默认值，代表自动布局算法在每一行中依次填充，只有必要时才会添加新行。<br>column代表自动布局算法在每一列中依次填充，只有必要时才会添加新行。<br>dense代表告诉自动布局算法如果更小的子项出现时尝试在网格中填补漏洞。<br>10 <strong>grid</strong><br>grid为以下属性的合并写法：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns，grid-auto-flow。它也可以设置grid-column-gap和grid-row-gap。  </p>
<pre><code>.box {
    grid: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [/ &lt;grid-auto-columns&gt;]];
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://wolfjyx.github.com/2018/11/22/flex&grid/" data-id="cjosppz0t0000ggjgaewxck5n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex/">flex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/grid/">grid</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/">flex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freemark-模板/">freemark 模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/">grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/head/">head</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-threejs/">js threejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webstrom-IDE/">webstrom IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/electron/" style="font-size: 10px;">electron</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/freemark-模板/" style="font-size: 10px;">freemark 模板</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/grid/" style="font-size: 10px;">grid</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/js-threejs/" style="font-size: 20px;">js threejs</a> <a href="/tags/webstrom-IDE/" style="font-size: 10px;">webstrom IDE</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/27/Json web token/">JOSN WEB TOKEN</a>
          </li>
        
          <li>
            <a href="/2019/01/20/linux  命令/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/20/vim 手册/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/13/git简介/">git 简介</a>
          </li>
        
          <li>
            <a href="/2019/01/03/electron 调用 dll 文件/">electron 调用 dll 文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 wolfjyx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>