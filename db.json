{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1542812734631},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1542812734631},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1542812734631},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1542812734631},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1542812734631},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1542812734639},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1542812728768},{"_id":"source/_posts/yeoman.md","hash":"073e519156c2f444dd9b2182c2e8b15cd3df44d3","modified":1542814129834},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1542812734631},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1542812734632},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1542812734632},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1542812734632},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1542812734632},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1542812734633},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1542812734633},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1542812734633},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1542812734633},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1542812734633},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1542812734633},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1542812734633},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1542812734638},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1542812734638},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1542812734638},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1542812734639},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1542812734639},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1542812734639},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1542812734639},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1542812734640},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1542812734634},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1542812734635},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1542812734635},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1542812734635},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1542812734635},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1542812734637},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1542812734637},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1542812734637},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1542812734637},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1542812734637},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1542812734638},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1542812734640},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1542812734643},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1542812734652},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1542812734652},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1542812734652},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1542812734653},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1542812734653},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1542812734653},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1542812734653},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1542812734655},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1542812734656},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1542812734656},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1542812734657},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1542812734636},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1542812734636},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1542812734636},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1542812734636},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1542812734636},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1542812734636},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1542812734641},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1542812734641},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1542812734641},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1542812734642},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1542812734642},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1542812734641},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1542812734642},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1542812734642},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1542812734642},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1542812734643},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1542812734643},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1542812734643},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1542812734645},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1542812734644},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1542812734649},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1542812734654},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1542812734654},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1542812734654},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1542812734654},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1542812734655},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1542812734655},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1542812734648},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1542812734647},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1542812734651},{"_id":"public/2018/11/21/yeoman/index.html","hash":"73788eaf471d788148fff5102fe6286762fb2c1e","modified":1546351817274},{"_id":"public/2018/11/21/hello-world/index.html","hash":"3af6bc9f02ed213d12c3b494af57abb162e44377","modified":1546351817274},{"_id":"public/archives/index.html","hash":"a597b1aed39e9a86ed78bebca1ce65a07c6387e0","modified":1546351817274},{"_id":"public/archives/2018/index.html","hash":"f1fbcdd6dd9d9a86b54c9baacbf28e0794464456","modified":1546351817274},{"_id":"public/archives/2018/11/index.html","hash":"d30e5c0952088b6fb108247b600fddf659e094a4","modified":1546351817274},{"_id":"public/index.html","hash":"ead61b33d9da282f3ce61dc98ec48d557af1d84e","modified":1546351817276},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1542814649066},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1542814649066},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1542814649066},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1542814649066},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1542814649066},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1542814649066},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1542814649067},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1542814649067},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1542814649067},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1542814649067},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1542814649605},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1542814649610},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1542814649613},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1542814649613},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1542814649613},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1542814649613},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1542814649613},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1542814649614},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1542814649614},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1542814649614},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1542814649614},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1542814649616},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1542814649616},{"_id":"source/_posts/lex&grid.markdown","hash":"c46f2587489a7444c30ff2a30dd5a17cd816f207","modified":1542897953235},{"_id":"public/archives/2018/07/index.html","hash":"e7a2d2ad23e0029b42d72c0dfa6ebaa2a442391f","modified":1542897792940},{"_id":"public/tags/css/index.html","hash":"8e956fda18de165c58c5a70c66dfc4da075a08e3","modified":1546351817274},{"_id":"public/tags/前端开发/index.html","hash":"92cb53af391f764ef951610fe62a0eb65a4258a2","modified":1542897792940},{"_id":"public/tags/flex/index.html","hash":"1c2f1a28fe9a7b9350381f1e2842f23866cafd99","modified":1546351817274},{"_id":"public/tags/grid/index.html","hash":"03cd7cd42ed4ac5f2cd9791fd042acd754e29c4e","modified":1546351817275},{"_id":"public/2018/07/12/lex&grid/index.html","hash":"0f82ff4851eea90289a31ebfbe64c99e23eda0be","modified":1542897792941},{"_id":"public/2018/11/22/lex&grid/index.html","hash":"d9e21e411131d1fa46e22cd8813022ae041957a2","modified":1542897957360},{"_id":"source/_posts/flex&grid.markdown","hash":"c46f2587489a7444c30ff2a30dd5a17cd816f207","modified":1542897953235},{"_id":"public/2018/11/22/flex&grid/index.html","hash":"818f58e0ce88ae065ae18e6a708348962f1ec3a2","modified":1546351817275},{"_id":"source/_posts/head-meta.md","hash":"18079633094cd3f41720daafa03df2d0a6c3c0cd","modified":1544110201296},{"_id":"public/2017/08/24/head-meta/index.html","hash":"e88d3cf293b4bb38ef5d1de49e8d424cbdf45d5b","modified":1544021043319},{"_id":"public/archives/2017/index.html","hash":"a43e7a70ff96f8eaa815132f66acb9c83641137a","modified":1544021043319},{"_id":"public/archives/2017/08/index.html","hash":"4a439fd2d6bfe47d8e14e4ce84ab9f44fe7b52ac","modified":1544021043319},{"_id":"source/_posts/跨域.md","hash":"d95246aa6d0f78888c7fbac5c99d17512da4c8b6","modified":1543244644999},{"_id":"public/2017/08/24/跨域/index.html","hash":"3e2d5f5cbb54d978dd5a2206e54fc3b9c1167612","modified":1543244301185},{"_id":"public/2018/11/26/跨域/index.html","hash":"36b2a813650af5da2cc8969e632df3adab20e241","modified":1546351817274},{"_id":"source/_posts/浏览器与内核.md","hash":"d610f3ce884c2ab3b23af88918eca774276ac6a8","modified":1543328098200},{"_id":"public/2018/11/27/浏览器与内核/index.html","hash":"b61527db5e6f81b80b69df4ba7e7dd595bd47130","modified":1546351817273},{"_id":"public/tags/浏览器/index.html","hash":"a567ee056ba8eca93acaa8ec703bb430822f6b6a","modified":1546351817275},{"_id":"source/_posts/浏览器渲染.md","hash":"8b4d7733143e9ce9872d93f7acb575df0a1d5987","modified":1543849411879},{"_id":"public/archives/2018/12/index.html","hash":"d224f522310fb59c259440a51a5572eb18372202","modified":1546351817274},{"_id":"public/2018/12/03/浏览器渲染/index.html","hash":"576b1a834b22da12195d2af42af5c183e513deac","modified":1546351817275},{"_id":"source/_posts/freemark.md","hash":"6cc99fe4345aeabecf29adda1fc3a01e32c5dec9","modified":1543931232095},{"_id":"public/2018/12/04/freemark/index.html","hash":"dae641f7f855a775585cdc329a1d62d929257619","modified":1546351817273},{"_id":"public/tags/freemark-模板/index.html","hash":"1eddc543a7137e3b528ef7f750adf6f672a00cb2","modified":1546351817275},{"_id":"source/_posts/css杂记.md","hash":"cfb909c4f0c7513c3076e6be9fe3525b0954a95d","modified":1544021032402},{"_id":"public/2018/12/05/css杂记/index.html","hash":"df20f30d99886f7e94018da101e62f6e4c97b046","modified":1546351817252},{"_id":"public/2018/12/06/head-meta/index.html","hash":"40e35b80d878fac6f386a1e8910fc4a61f97f66a","modified":1546351817275},{"_id":"public/tags/head/index.html","hash":"5d31b5a8102cd7110ec20464c08a4b9602dd036e","modified":1546351817275},{"_id":"source/_posts/javascript & ECMAScript & es.md","hash":"4290587e03c09bf5e57628a81adf1dfd28b282d2","modified":1544363081036},{"_id":"public/2018/12/09/javascript & ECMAScript & es/index.html","hash":"27b2e78e8248486ab6551e06720bad77fa19f020","modified":1546351817275},{"_id":"public/tags/javascript/index.html","hash":"55ce2c954d7685921c14ae52de4e103e38e2446e","modified":1546351817275},{"_id":"source/_posts/threejs 解读  scene.md","hash":"68925e3cb8bb9b1ad93ff86091c2a0e0d7f7e406","modified":1544450608638},{"_id":"public/2018/12/10/threejs 解读  scene/index.html","hash":"ba962973c9bc5201673fe2e9953a977ac64f2ba1","modified":1546351817251},{"_id":"public/page/2/index.html","hash":"30172e9d5cc74a0fede16540af88be16546ff6e6","modified":1546351817276},{"_id":"public/archives/page/2/index.html","hash":"874b2030ad361c6f52c98b94fb33ccdb7aa2aebb","modified":1546351817274},{"_id":"public/archives/2018/page/2/index.html","hash":"11e5730bc4c0bee777c4f1f1428a600572fcb91e","modified":1546351817274},{"_id":"public/tags/js-threejs/index.html","hash":"75979da28059dc381184159a424caabea28e677a","modified":1546351817275},{"_id":"source/_posts/threejs解读 webGLRender.md","hash":"2dac12a44419bba4deaa57529dea0cc73b334f23","modified":1544540294720},{"_id":"public/2018/12/11/threejs解读 webGLRender/index.html","hash":"d2386adb960c356b64a4b16a248f8eadf349e746","modified":1546351817275},{"_id":"source/_posts/threejs 解读  camera.md","hash":"45d7ab778485c27e8b808d383f905fa2e516766a","modified":1544942833504},{"_id":"public/2018/12/16/threejs 解读  camera/index.html","hash":"03f897c81836bae4713c9c869a7673bb7b0e7c0a","modified":1546351817275},{"_id":"source/_posts/threejs 解读 materilas.md","hash":"c0cd2ca7bb1819c5a7800e855df966dc42251cfd","modified":1545057503516},{"_id":"public/2018/12/17/threejs 解读 materilas/index.html","hash":"615d7778c0541af7e5cbe11f7f185a49ae145162","modified":1546351817275},{"_id":"source/_posts/threejs 解读 light.md","hash":"7986666bd22c4cba1697970fe09ed46312923ee1","modified":1545666507770},{"_id":"public/2018/12/24/threejs 解读 light/index.html","hash":"46eabd5dcf354b349f06ce7edec96b5cde31da38","modified":1546351817275},{"_id":"source/_posts/threejs 解读 geometry.md","hash":"aff22022291e8e26225f80552ff6bdaf87673c6e","modified":1545922171774},{"_id":"public/archives/2018/12/page/2/index.html","hash":"5613a05a2237fc20df7760604ae2facbb7b4a6e8","modified":1546351817274},{"_id":"public/2018/12/27/threejs 解读 geometry/index.html","hash":"220d4d9273f696a7cd4f58d1881bdf34c3c19586","modified":1546351817275},{"_id":"source/_posts/webstrom- 快捷键.md","hash":"6c384b2077ae8e1acde5b26bcb5eb3f3a030d7c4","modified":1546351803019},{"_id":"public/archives/2019/index.html","hash":"7c8f1bcd3e4e4d1e508b0cf012f25ba6c794aeb9","modified":1546351817281},{"_id":"public/archives/2019/01/index.html","hash":"540691f1c5e75e76c8b59cb44f8af99825bcff3f","modified":1546351817281},{"_id":"public/tags/webstrom-IDE/index.html","hash":"53ff498ac53b6bc8b1101887b2af4481859e54c1","modified":1546351817282},{"_id":"public/2019/01/01/webstrom- 快捷键/index.html","hash":"5ae2caa96bdd8d6ccd0945989b3c81e235b161f0","modified":1546351817282}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-11-21T15:05:28.768Z","updated":"2018-11-21T15:05:28.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjorc09rn0000z8jg7iukk7c9","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"yeoman","date":"2018-11-21T15:28:17.000Z","_content":"\n\n# 设置开发环境\n## 1.1 安装条件\n安装yeoman之前，你需要先安装如下内容\n\n* Nodejs v4 或者更高版本\n* npm\n* git\n\n通过以下命令检查是否安装 Node 环境以及 npm 管理工具。\n\n\t$ node -v && npm -v\n\nnpm 默认随 Node 一起安装。有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令更新 npm\n\n\t$ npm install -g npm@latest\n\n通过以下命名检查是否安装git\n\n\t$ git --version\n\n## 1.2 安装yeoman工具箱\n如果已经安装了 node 环境，可以通过以下命令安装 Yeoman\n\n\t$ npm install -g yo\n\n##1.3 确认安装\n首先确认 Yeoman 是否正确安装\n\n\t$ yo --version\n\n# 安装Yeoman生成器\n在传统的 web开发中，你需要花大量时间为你的 webapp 设置模板代码、下载依赖包以及手动创建文件目录结构。Yeoman 的生成器会帮你搞定这一切\n\n2.1安装生成器\n你可以通过 npm 命令安装 Yeoman 生成器，目前可用的生成器超过了 3500 个，大多数都是开源社区贡献的。\n\n通过以下命令安装 generator-webpack-simple-static\n\n\t$ npm install -g generator-webpack-simple-static\n该命令将安装生成器所需的node包。\n\n和使用 npm install 一样，你可以通过 Yeoman 的交互菜单搜索 generators。\n\n运行 yo 然后选择 Install a generator 来搜索发布的生成器。\n\n# 使用生成器搭建app\n我们已经使用多次“脚手架”这个词，但是你可能还不知道它是什么意思。在 Yeoman的 语境中，脚手架材料表示通过一些配置为你的 webapp 生成文件。在这一步中，你会看到 Yeoman 如何为你喜欢的库及框架生成文件，以及使用如 webpack/babel/Sass 等一些额外的库的配置。\n\n3.1 创建项目文件夹\n\n\t$ mkdir mytodo && cd mytodo\n生成器生成的脚手架文件会放在这个文件夹中。\n\n3.2 通过 Yeoman 菜单使用生成器\n再次运行 yo\n\n\t$ yo\n如果你已经安装了多个 generator，你需要从中选择一个。选中 generator-webpack-simple-static，按回车 enter 运行生成器。\n","source":"_posts/yeoman.md","raw":"---\ntitle: yeoman\ndate: 2018-11-21 23:28:17\ntags:\n---\n\n\n# 设置开发环境\n## 1.1 安装条件\n安装yeoman之前，你需要先安装如下内容\n\n* Nodejs v4 或者更高版本\n* npm\n* git\n\n通过以下命令检查是否安装 Node 环境以及 npm 管理工具。\n\n\t$ node -v && npm -v\n\nnpm 默认随 Node 一起安装。有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令更新 npm\n\n\t$ npm install -g npm@latest\n\n通过以下命名检查是否安装git\n\n\t$ git --version\n\n## 1.2 安装yeoman工具箱\n如果已经安装了 node 环境，可以通过以下命令安装 Yeoman\n\n\t$ npm install -g yo\n\n##1.3 确认安装\n首先确认 Yeoman 是否正确安装\n\n\t$ yo --version\n\n# 安装Yeoman生成器\n在传统的 web开发中，你需要花大量时间为你的 webapp 设置模板代码、下载依赖包以及手动创建文件目录结构。Yeoman 的生成器会帮你搞定这一切\n\n2.1安装生成器\n你可以通过 npm 命令安装 Yeoman 生成器，目前可用的生成器超过了 3500 个，大多数都是开源社区贡献的。\n\n通过以下命令安装 generator-webpack-simple-static\n\n\t$ npm install -g generator-webpack-simple-static\n该命令将安装生成器所需的node包。\n\n和使用 npm install 一样，你可以通过 Yeoman 的交互菜单搜索 generators。\n\n运行 yo 然后选择 Install a generator 来搜索发布的生成器。\n\n# 使用生成器搭建app\n我们已经使用多次“脚手架”这个词，但是你可能还不知道它是什么意思。在 Yeoman的 语境中，脚手架材料表示通过一些配置为你的 webapp 生成文件。在这一步中，你会看到 Yeoman 如何为你喜欢的库及框架生成文件，以及使用如 webpack/babel/Sass 等一些额外的库的配置。\n\n3.1 创建项目文件夹\n\n\t$ mkdir mytodo && cd mytodo\n生成器生成的脚手架文件会放在这个文件夹中。\n\n3.2 通过 Yeoman 菜单使用生成器\n再次运行 yo\n\n\t$ yo\n如果你已经安装了多个 generator，你需要从中选择一个。选中 generator-webpack-simple-static，按回车 enter 运行生成器。\n","slug":"yeoman","published":1,"updated":"2018-11-21T15:28:49.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjorc09rs0001z8jgho2whtqj","content":"<h1 id=\"设置开发环境\"><a href=\"#设置开发环境\" class=\"headerlink\" title=\"设置开发环境\"></a>设置开发环境</h1><h2 id=\"1-1-安装条件\"><a href=\"#1-1-安装条件\" class=\"headerlink\" title=\"1.1 安装条件\"></a>1.1 安装条件</h2><p>安装yeoman之前，你需要先安装如下内容</p>\n<ul>\n<li>Nodejs v4 或者更高版本</li>\n<li>npm</li>\n<li>git</li>\n</ul>\n<p>通过以下命令检查是否安装 Node 环境以及 npm 管理工具。</p>\n<pre><code>$ node -v &amp;&amp; npm -v\n</code></pre><p>npm 默认随 Node 一起安装。有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令更新 npm</p>\n<pre><code>$ npm install -g npm@latest\n</code></pre><p>通过以下命名检查是否安装git</p>\n<pre><code>$ git --version\n</code></pre><h2 id=\"1-2-安装yeoman工具箱\"><a href=\"#1-2-安装yeoman工具箱\" class=\"headerlink\" title=\"1.2 安装yeoman工具箱\"></a>1.2 安装yeoman工具箱</h2><p>如果已经安装了 node 环境，可以通过以下命令安装 Yeoman</p>\n<pre><code>$ npm install -g yo\n</code></pre><p>##1.3 确认安装<br>首先确认 Yeoman 是否正确安装</p>\n<pre><code>$ yo --version\n</code></pre><h1 id=\"安装Yeoman生成器\"><a href=\"#安装Yeoman生成器\" class=\"headerlink\" title=\"安装Yeoman生成器\"></a>安装Yeoman生成器</h1><p>在传统的 web开发中，你需要花大量时间为你的 webapp 设置模板代码、下载依赖包以及手动创建文件目录结构。Yeoman 的生成器会帮你搞定这一切</p>\n<p>2.1安装生成器<br>你可以通过 npm 命令安装 Yeoman 生成器，目前可用的生成器超过了 3500 个，大多数都是开源社区贡献的。</p>\n<p>通过以下命令安装 generator-webpack-simple-static</p>\n<pre><code>$ npm install -g generator-webpack-simple-static\n</code></pre><p>该命令将安装生成器所需的node包。</p>\n<p>和使用 npm install 一样，你可以通过 Yeoman 的交互菜单搜索 generators。</p>\n<p>运行 yo 然后选择 Install a generator 来搜索发布的生成器。</p>\n<h1 id=\"使用生成器搭建app\"><a href=\"#使用生成器搭建app\" class=\"headerlink\" title=\"使用生成器搭建app\"></a>使用生成器搭建app</h1><p>我们已经使用多次“脚手架”这个词，但是你可能还不知道它是什么意思。在 Yeoman的 语境中，脚手架材料表示通过一些配置为你的 webapp 生成文件。在这一步中，你会看到 Yeoman 如何为你喜欢的库及框架生成文件，以及使用如 webpack/babel/Sass 等一些额外的库的配置。</p>\n<p>3.1 创建项目文件夹</p>\n<pre><code>$ mkdir mytodo &amp;&amp; cd mytodo\n</code></pre><p>生成器生成的脚手架文件会放在这个文件夹中。</p>\n<p>3.2 通过 Yeoman 菜单使用生成器<br>再次运行 yo</p>\n<pre><code>$ yo\n</code></pre><p>如果你已经安装了多个 generator，你需要从中选择一个。选中 generator-webpack-simple-static，按回车 enter 运行生成器。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设置开发环境\"><a href=\"#设置开发环境\" class=\"headerlink\" title=\"设置开发环境\"></a>设置开发环境</h1><h2 id=\"1-1-安装条件\"><a href=\"#1-1-安装条件\" class=\"headerlink\" title=\"1.1 安装条件\"></a>1.1 安装条件</h2><p>安装yeoman之前，你需要先安装如下内容</p>\n<ul>\n<li>Nodejs v4 或者更高版本</li>\n<li>npm</li>\n<li>git</li>\n</ul>\n<p>通过以下命令检查是否安装 Node 环境以及 npm 管理工具。</p>\n<pre><code>$ node -v &amp;&amp; npm -v\n</code></pre><p>npm 默认随 Node 一起安装。有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令更新 npm</p>\n<pre><code>$ npm install -g npm@latest\n</code></pre><p>通过以下命名检查是否安装git</p>\n<pre><code>$ git --version\n</code></pre><h2 id=\"1-2-安装yeoman工具箱\"><a href=\"#1-2-安装yeoman工具箱\" class=\"headerlink\" title=\"1.2 安装yeoman工具箱\"></a>1.2 安装yeoman工具箱</h2><p>如果已经安装了 node 环境，可以通过以下命令安装 Yeoman</p>\n<pre><code>$ npm install -g yo\n</code></pre><p>##1.3 确认安装<br>首先确认 Yeoman 是否正确安装</p>\n<pre><code>$ yo --version\n</code></pre><h1 id=\"安装Yeoman生成器\"><a href=\"#安装Yeoman生成器\" class=\"headerlink\" title=\"安装Yeoman生成器\"></a>安装Yeoman生成器</h1><p>在传统的 web开发中，你需要花大量时间为你的 webapp 设置模板代码、下载依赖包以及手动创建文件目录结构。Yeoman 的生成器会帮你搞定这一切</p>\n<p>2.1安装生成器<br>你可以通过 npm 命令安装 Yeoman 生成器，目前可用的生成器超过了 3500 个，大多数都是开源社区贡献的。</p>\n<p>通过以下命令安装 generator-webpack-simple-static</p>\n<pre><code>$ npm install -g generator-webpack-simple-static\n</code></pre><p>该命令将安装生成器所需的node包。</p>\n<p>和使用 npm install 一样，你可以通过 Yeoman 的交互菜单搜索 generators。</p>\n<p>运行 yo 然后选择 Install a generator 来搜索发布的生成器。</p>\n<h1 id=\"使用生成器搭建app\"><a href=\"#使用生成器搭建app\" class=\"headerlink\" title=\"使用生成器搭建app\"></a>使用生成器搭建app</h1><p>我们已经使用多次“脚手架”这个词，但是你可能还不知道它是什么意思。在 Yeoman的 语境中，脚手架材料表示通过一些配置为你的 webapp 生成文件。在这一步中，你会看到 Yeoman 如何为你喜欢的库及框架生成文件，以及使用如 webpack/babel/Sass 等一些额外的库的配置。</p>\n<p>3.1 创建项目文件夹</p>\n<pre><code>$ mkdir mytodo &amp;&amp; cd mytodo\n</code></pre><p>生成器生成的脚手架文件会放在这个文件夹中。</p>\n<p>3.2 通过 Yeoman 菜单使用生成器<br>再次运行 yo</p>\n<pre><code>$ yo\n</code></pre><p>如果你已经安装了多个 generator，你需要从中选择一个。选中 generator-webpack-simple-static，按回车 enter 运行生成器。</p>\n"},{"title":"flex & grid 布局","_content":"\n\n# Flex\n## 背景\n布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n## flex布局\n* **容器的声明**  \n Flex是Flexible Box的缩写，意为\"弹性布局\"  \n 任何容器，我们均可以将它指定为flex布局，行内元素也可以使用Flex布局，Webkit内核的浏览器，必须加上-webkit前缀  \n 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效\n  \n  \n\t\t      .box{\n\t\t        display:flex;\n\t\t        }\n\t\t     \n\t\t     \n\t\t\t  .box{  \n\t\t\t  display:inline-flex;\n\t\t\t  }\n\t\t\t  \n\t\t\t  .box{\n\t\t\t  display:-webkit-flex;\n\t\t\t  display:flex;\n\t\t    }\n\t\t        \n          \n## 概念\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-2.png)  \n 采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）  \n 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size\n \n## 容器的属性\n1. **flex-direction**  \n   该属性决定主轴的方向\n \n \t\t\t.box {\n  \t\tflex-direction: row | row-reverse | column | column-reverse;\n\t\t}\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-5.jpg)\n \n2. **flex-wrap**  \n   如果一条轴线排不下，如何换行  \n   \n\t     .box{\n\t\t\t  flex-wrap: nowrap | wrap | wrap-reverse;\n\t\t\t}\n\t\t\n\tnowrap为默认值，代表不换行。  \n\twrap代表换行，但默认为第一行在上方。  \n\twrap-reverse代表换行，但默认为第一行在下方。\t \n3. **flex-flow**  \n flex-flow属性是**flex-direction**属性和**flex-wrap**属性的简写形式，默认值为**row nowrap**\n \n \n\t\t .box {\n\t\t  flex-flow: <flex-direction> || <flex-wrap>;\n\t\t}\n\t\t\n4. **justify-content**  \n   justify-content属性定义了项目在主轴上的对齐方式。\n   \n   \t\t\t\t.box {\n\t\t\t\t  justify-content: flex-start | flex-end | center | space-between | space-around;\n\t\t\t\t}\nflex-start为默认值，代表项目在主轴上向起始方向对齐  \nflex-end代表项目在主轴上向结束方向对齐  \ncenter代表项目在主轴上居中对齐  \nspace-between代表项目在主轴上两端对齐，但第一个项目在主轴的起始位置，最后一个项目在主轴的结束位置  \nspace-around代表项目在主轴上等分间距，但第一个项目与最后一个项目距离主轴的两端保持一定的距离，这个距离为项目之间间距的1/2  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-7.jpg)\n\n5. **align-items**  \n  align-items属性定义项目在交叉轴上如何对齐。\n\n\t\t\t.box {\n\t\t\t  align-items: flex-start | flex-end | center | baseline | stretch;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-8.jpg)  \nflex-start代表项目在交叉轴上向起始方向对齐。  \nflex-end代表项目在交叉轴上向结束方向对齐。  \ncenter代表项目在交叉轴上居中对齐。  \nbaseline代表项目在交叉轴上向项目的第一行文字的基线对齐。  \nstretch代表项目在交叉轴上拉伸对齐。 \n \n6. **align-content**  \n  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n\t\t.box {\n\t\t  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\t\t}\nflex-start：与交叉轴的起点对齐。  \nflex-end：与交叉轴的终点对齐。  \ncenter：与交叉轴的中点对齐。  \nspace-between：与交叉轴两端对齐，轴线之间的间隔平均分布。  \nspace-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。  \nstretch（默认值）：轴线占满整个交叉轴。  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-9.jpg)  \n\n## 项目的属性\n1. **order**  \n  order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0  \n  \n\t\t\t\t  .item {\n\t\t\t\t  order: <integer>;\n\t\t\t\t}\n\t![](http://oczira72b.bkt.clouddn.com/grid-flex-10.jpg) \n\t\n2.**flex-grow**  \n  flex-grow定义了项目的放大比例。如果所有伸缩项目的flex-grow设置了1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了flex-grow值为2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。\n\nps：负值对该属性无效。  \n\n\t\t\t\t.item {\n\t\t\t\t    flex-grow: <number>; /* default 0 */\n\t\t\t\t}\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-11.jpg)\n \n 3. **flex-shrink**  \n 类似于flex-grow，flex-shrink定义了项目的缩小比例。其默认值为1  \n\n如果所有项目的flex-shrink都为1，当空间不足时，都将等比例缩小  \n\n如果所有项目都为1，但其中一个项目的flex-shrink为0，即代表空间不足时，该项目缩小0倍，即为不缩小  \n\nps：负值对该属性不起作用。\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-12.jpg)\n \n4. **flex-basis**  \n  flex-basis定义了在分配多余空间之前，项目占据的主轴空间。览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n  \n\t\t  .item {\n\t\t    flex-basis: <length> | auto; /* default auto */\n\t\t}\n\t\t\n利用flex-basis，我们可以很容易实现页面布局中的常见问题：两栏/三栏布局\n\n\t\t\t<div class=\"box\">\n\t\t    <div class=\"left\">left</div>\n\t\t    <div class=\"main\">main</div>\n\t\t</div>\n\t\t\n\t\t\n\t\t\t\t.box {\n\t\t    display: flex;\n\t\t    height: 200px;\n\t\t\t\t}\n\t\t\t\t.left {\n\t\t\t\t    background-color: yellow;\n\t\t\t\t    flex-basis: 200px;\n\t\t\t/* flex-basis定义该项目在分配主轴空间之前提前获得200px的空间 */\n\t\t\t\t    flex-grow: 0;\n\t\t\t\t    /* flex-grow定义该项目不分配剩余空间 */\n\t\t\t\t}\n\t\t\t\t.main {\n\t\t\t\t    background-color: green;\n\t\t\t\t    flex-grow: 1;\n\t\t\t\t    /* flex-grow定义main占满剩余空间 */\n\t\t\t\t}\n\t\t\t\t\n![](http://oczira72b.bkt.clouddn.com/grid-flex-13.jpg)\n\n5.**flex** \nflex是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n\t\t\t.item {\n\t\t\t    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\t\t\t}\n6. **align-self**  \n   align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。    \n    \n \n# Grid  \n## 概念\ngrid 布局。是一个基于网格的二维布局系统。grid是第一个专门为了解决那些我们一直使用 hack 手段而导致的页面布局问题而创建的CSS模块。  \n一个grid容器的内容：  \n\n* 可以将应用程序分割成不同的空间  \n* 可以定义子项的大小、位置以及层级。\n* 与表格类似的是：可以让Web设计师根据元素按列或行对齐排列。\n* 可以定位自己的位置，这样他们可以重叠和类似元素定位。\n* 可以通过结合CSS的媒体查询属性，根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容  \n\n**浏览器支持**\n![](http://oczira72b.bkt.clouddn.com/grid-flex-25.jpg)\n\n采用grid布局的元素，称为grid容器（grid container）。它的所有子元素自动成为容器成员，称为grid项目（grid item）。\n\n分隔的线组成了网格的结构。它们可以是垂直的（“列网格线”）或者水平的（“行网格线”），也可以在行或列的任一边。下面的例子中黄色的线是一个列网格线的例子。  \n**网格线**  \n每条网格线具有默认的编号，从左到右和从上到下分别为1,2,3......\n![](http://oczira72b.bkt.clouddn.com/grid-flex-3.jpg)\n**网格单元**  \n网格单元是指两根毗邻的行网格线和列网格线中间的位置，它是一个单独的网格“单元”，如图所示，网格单元是指第 1 和 2 根行网格线和第 2 和 3 根列网格线中间的位置。    \n![](http://oczira72b.bkt.clouddn.com/flex-grid-4.png)  \n**网格轨迹**    \n网格轨迹是指两根毗邻线中间的位置，可以认为是网格的行或者列  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-26.png)  \n**网格区域**  \n网格区域是指 4 根网格线包围的空间，一个网格空间可能由任意数量的网格单元构成  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-27.png)  \n\n\n## 容器的属性\n\n1. **disaplay**\ndisplay属性定义了一个网格容器，容器是展现为行内或块状由所给定的值而决定，此时，他的所有子元素进入grid文档流，称为grid项目 \n\n\t\t\t\t.box {\n\t\t\t\t    display: grid | inline-grid | subgrid;\n\t\t\t\t}\ngrid定义了一个网格容器，它以块级元素的形式显示  \ninline-grid定义了一个网格容器，它以内联元素的形式显示  \nsubgrid定义了一个网格容器，这个网格容器是其父级网格容器的一个子项。它的行和列的大小从父级网格容器中获取  \n\n2. **grid-template-columns | grid-template-rows**  \ngrid-template-rows和grid-template-columns定义了一个网格的列数、行数以及网格的大小。\n\n\t\t\t.box {\n\t\t\t\t    grid-template-columns: <track-size> ... | <line-name> <track-size> ...;\n\t\t\t\t    grid-template-rows: <track-size> ... | <line-name> <track-size> ...;\n\t\t\t\t}\n定义网格单元的宽高，其单位可以是一个长度(如px、em、rem、vw、vh)或百分比，也可以是网格中自由空间的份数(单位为fr)  \n定义网格线的名称，它不是必须值。可以一个你选择的任意名字，当没有显示设定时，它的名字以数字表示。  \n\n\t\t\t.box {\n\t\t\t    grid-template-columns: 40px 50px auto 50px 40px;\n\t\t\t    grid-template-rows: 25% 100px auto;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-28.png)\n\n\t\t.box {\n\t\t    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n\t\t    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-29.png)\n\n一根网格线可以有多个名字，例如在下面的例子中第二根线有两个名字：row1-end 和 row2-start，命名方式以空格来作为间隔。\n\n     .box{\n         grid-template-rows:[row1-start] 25% [row1-end row-start] 25% [row-end];\n         }\n         \n定义了容器的重复部分，你可以使用CSS的repeat()方法来生成多个相同值：\n\t\t\n\t\t.box {\n\t\t    grid-template-columns: repeat(3, 20px [col-start]) 5%;\n\t\t}\n\t\t\t\t\n\t\t.box {\n\t\t    grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;\n\t\t}\n\t\t\nfr是一个特殊的单位，它可以类似于设定flex-grow时，给网格容器中的自由空间设置为一个份数，举个例子，下面的例子将把网格容器的每个子项设置为三分之一\n\n\t\t.box {\n    \t\tgrid-template-columns: 1fr 1fr 1fr;\n\t\t}\n\t\t\n也是类似于flex-grow，自由空间是在固定子项确定后开始计算的（这里就如同flex-basis提前给予宽高那样），在下面的例子中自由空间是fr单位的总和但不包括50px：\n\t\t\t.box {\n\t\t\t    grid-template-columns: 1fr 50px 1fr 1fr;\n\t\t\t}\n\t\t\t\n3. **grid-template-areas**  \n   grid-template-areas可以配合gird-area定义一个显示的网格区域。  \n   grid-template-areas定义网格区域，然后使用grid-area调用声明好的网格区域名称来放置对应的网格项目  \n   \n         <section class=\"grid\">\n\t\t    <div class=\"title\">title</div>\n\t\t    <div class=\"nav\">nav</div>\n\t\t    <div class=\"main\">main</div>\n\t\t    <div class=\"aside\">aside</div>\n\t\t    <div class=\"footer\">footer</div>\n\t\t</section>  \n\t\t.grid {\n\t\t\t    display: grid;\n\t\t\t    grid-template-columns: 100px 100px 100px 100px 100px;\n\t\t\t    grid-template-rows: 100px 100px 100px 100px;\n\t\t\t    grid-template-areas: 'title title title title aside'\n\t\t\t                          'nav main main main aside'\n\t\t\t                          'nav main main main aside'\n\t\t\t                          'footer footer footer footer footer';\n\t\t\t    font-size: 30px;\n\t\t\t    text-align: center;\n\t\t\t}\n\t\t\t.title {\n\t\t\t    grid-area: title;\n\t\t\t    background-color: blue;\n\t\t\t}\n\t\t\t.nav {\n\t\t\t    grid-area: nav;\n\t\t\t    background-color: yellow;\n\t\t\t}\n\t\t\t.main {\n\t\t\t    grid-area: main;\n\t\t\t    background-color: gray;\n\t\t\t}\n\t\t\t.aside {\n\t\t\t    grid-area: aside;\n\t\t\t    background-color: green;\n\t\t\t}\n\t\t\t.footer {\n\t\t\t    grid-area: footer;\n\t\t\t    background-color: pink;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-30.jpg)   \n\n4. **grid-column-gap|grid-row-gap**  \n   grid-column-gap和grid-row-gap定义了网格之间的间距\n   \n\t\t   .box {\n\t\t    grid-template-columns: 100px 50px 100px;\n\t\t    grid-template-rows: 80px auto 80px;\n\t\t    grid-column-gap: 10px;\n\t\t    grid-row-gap: 15px;\n\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-31.png) \n\n5.**justify-items**  \njustify-items定义了网格子项的内容和列轴对齐方式，即水平方向上的对齐方式  \n\n\t\t\t.box {\n\t\t\t    justify-items: start | end | center | stretch;\n\t\t\t}\nstart代表内容和网格区域的左边对齐  \nend代表内容和网格区域的右边对齐  \ncenter代表内容和网格区域的中间对齐  \nstretch为默认值，代表填充整个网格区域的宽度  \n\n6. **align-items**  \n  类似于justify-items，align-items定义了网格子项的内容和行轴对齐方式，即垂直方向上的对齐方式。\n  \n\t\t\t .box {\n\t\t\t    align-items: start | end | center | stretch;\n\t\t\t}\n\t\t\t  \nstart代表内容和网格区域的上边对齐  \nend代表内容和网格区域的下边对齐  \ncenter代表内容和网格区域的中间对齐  \nstretch为默认值，代表填充整个网格区域的高度  \n\n7. **justity-content|align-content**\n  justify-content属性定义了网格和网格容器列轴对齐方式  \n  \n  \t\t\t.box {\n\t\t\t    justify-content|align-content: start | end | center | stretch | space-around | space-between | space-evenly;\n\t\t\t}\nstart代表网格在网格容器(左|上）边对齐  \nend代表网格在网格容器(右|下)边对齐  \ncenter代表网格在网格容器中间对齐  \nstretch改变网格子项的容量让其填充整个网格容器宽度  \nspace-around代表在每个网格子项中间放置均等的空间，在始末两端只有一半大小  \nspace-between代表在每个网格子项中间放置均等的空间，在始末两端没有空间  \nspace-evenly代表在每个网格子项中间放置均等的空间，包括始末两端  \n\n8. **grid-auto-columns|grid-auto-rows**  \n   grid-auto-columns与grid-auto-rows可以指定隐式网格。\n   \t\t\n   \t\t<div class=\"grid\">\n\t\t    <div class=\"box1\">box1</div>\n\t\t    <div class=\"box2\">box2</div>\n\t\t    <div class=\"box3\">box3</div>\n\t\t    <div class=\"box4\">box4</div>\n\t\t</div>\n  \t\t\t.grid {\n\t\t\t    display: grid;\n\t\t\t    grid-template-columns: 200px;\n\t\t\t    grid-template-rows: 200px;\n\t\t\t    text-align: center;\n\t\t\t    font-size: 30px;\n\t\t\t}\n\t\t\t.box1 {\n\t\t\t    background-color: pink;\n\t\t\t    grid-column: 1;\n\t\t\t    grid-row: 1;\n\t\t\t}\n\t\t\t.box2 {\n\t\t\t    background-color: yellow;\n\t\t\t    grid-column: 2;\n\t\t\t    grid-row: 1;\n\t\t\t}\n\t\t\t.box3 {\n\t\t\t    background-color: gray;\n\t\t\t    grid-column: 1;\n\t\t\t    grid-column: 2;\n\t\t\t}\n\t\t\t.box4 {\n\t\t\t    background-color: blue;\n\t\t\t    grid-column: 2;\n\t\t\t    grid-row: 2;\n\t\t\t}\n\n![](http://oczira72b.bkt.clouddn.com/grid-flex-54.jpg)  \n通过grid-auto-columns与grid-auto-rows属性，创建一个隐式的2×2的网格  \n\n\t\t\t\tgrid-auto-columns: 300px;\n\t\t\t\tgrid-auto-rows: 300px;\n![](http://oczira72b.bkt.clouddn.com/grid-flex-55.jpg)  \n9. **grid-auto-flow**    \n   grid布局自身具有的自动布局算法会将网格子项自动放置起来，而grid-auto-flow属性控制自动布局算法如何工作\n \n\t   .box {\n\t    grid-auto-flow: row | column | row dense | column dense\n\t}\n\t\nrow为默认值，代表自动布局算法在每一行中依次填充，只有必要时才会添加新行。  \ncolumn代表自动布局算法在每一列中依次填充，只有必要时才会添加新行。  \ndense代表告诉自动布局算法如果更小的子项出现时尝试在网格中填补漏洞。  \n10 **grid**  \ngrid为以下属性的合并写法：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns，grid-auto-flow。它也可以设置grid-column-gap和grid-row-gap。  \n\n\t.box {\n\t    grid: none | <grid-template-rows> / <grid-template-columns> | <grid-auto-flow> [<grid-auto-rows> [/ <grid-auto-columns>]];\n\t}\n","source":"_posts/flex&grid.markdown","raw":"---\ntitle:      \"flex & grid 布局\"\ntags:\n    - css\n    - flex\n    - grid\n---\n\n\n# Flex\n## 背景\n布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n## flex布局\n* **容器的声明**  \n Flex是Flexible Box的缩写，意为\"弹性布局\"  \n 任何容器，我们均可以将它指定为flex布局，行内元素也可以使用Flex布局，Webkit内核的浏览器，必须加上-webkit前缀  \n 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效\n  \n  \n\t\t      .box{\n\t\t        display:flex;\n\t\t        }\n\t\t     \n\t\t     \n\t\t\t  .box{  \n\t\t\t  display:inline-flex;\n\t\t\t  }\n\t\t\t  \n\t\t\t  .box{\n\t\t\t  display:-webkit-flex;\n\t\t\t  display:flex;\n\t\t    }\n\t\t        \n          \n## 概念\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-2.png)  \n 采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）  \n 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size\n \n## 容器的属性\n1. **flex-direction**  \n   该属性决定主轴的方向\n \n \t\t\t.box {\n  \t\tflex-direction: row | row-reverse | column | column-reverse;\n\t\t}\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-5.jpg)\n \n2. **flex-wrap**  \n   如果一条轴线排不下，如何换行  \n   \n\t     .box{\n\t\t\t  flex-wrap: nowrap | wrap | wrap-reverse;\n\t\t\t}\n\t\t\n\tnowrap为默认值，代表不换行。  \n\twrap代表换行，但默认为第一行在上方。  \n\twrap-reverse代表换行，但默认为第一行在下方。\t \n3. **flex-flow**  \n flex-flow属性是**flex-direction**属性和**flex-wrap**属性的简写形式，默认值为**row nowrap**\n \n \n\t\t .box {\n\t\t  flex-flow: <flex-direction> || <flex-wrap>;\n\t\t}\n\t\t\n4. **justify-content**  \n   justify-content属性定义了项目在主轴上的对齐方式。\n   \n   \t\t\t\t.box {\n\t\t\t\t  justify-content: flex-start | flex-end | center | space-between | space-around;\n\t\t\t\t}\nflex-start为默认值，代表项目在主轴上向起始方向对齐  \nflex-end代表项目在主轴上向结束方向对齐  \ncenter代表项目在主轴上居中对齐  \nspace-between代表项目在主轴上两端对齐，但第一个项目在主轴的起始位置，最后一个项目在主轴的结束位置  \nspace-around代表项目在主轴上等分间距，但第一个项目与最后一个项目距离主轴的两端保持一定的距离，这个距离为项目之间间距的1/2  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-7.jpg)\n\n5. **align-items**  \n  align-items属性定义项目在交叉轴上如何对齐。\n\n\t\t\t.box {\n\t\t\t  align-items: flex-start | flex-end | center | baseline | stretch;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-8.jpg)  \nflex-start代表项目在交叉轴上向起始方向对齐。  \nflex-end代表项目在交叉轴上向结束方向对齐。  \ncenter代表项目在交叉轴上居中对齐。  \nbaseline代表项目在交叉轴上向项目的第一行文字的基线对齐。  \nstretch代表项目在交叉轴上拉伸对齐。 \n \n6. **align-content**  \n  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n\t\t.box {\n\t\t  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\t\t}\nflex-start：与交叉轴的起点对齐。  \nflex-end：与交叉轴的终点对齐。  \ncenter：与交叉轴的中点对齐。  \nspace-between：与交叉轴两端对齐，轴线之间的间隔平均分布。  \nspace-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。  \nstretch（默认值）：轴线占满整个交叉轴。  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-9.jpg)  \n\n## 项目的属性\n1. **order**  \n  order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0  \n  \n\t\t\t\t  .item {\n\t\t\t\t  order: <integer>;\n\t\t\t\t}\n\t![](http://oczira72b.bkt.clouddn.com/grid-flex-10.jpg) \n\t\n2.**flex-grow**  \n  flex-grow定义了项目的放大比例。如果所有伸缩项目的flex-grow设置了1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了flex-grow值为2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。\n\nps：负值对该属性无效。  \n\n\t\t\t\t.item {\n\t\t\t\t    flex-grow: <number>; /* default 0 */\n\t\t\t\t}\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-11.jpg)\n \n 3. **flex-shrink**  \n 类似于flex-grow，flex-shrink定义了项目的缩小比例。其默认值为1  \n\n如果所有项目的flex-shrink都为1，当空间不足时，都将等比例缩小  \n\n如果所有项目都为1，但其中一个项目的flex-shrink为0，即代表空间不足时，该项目缩小0倍，即为不缩小  \n\nps：负值对该属性不起作用。\n ![](http://oczira72b.bkt.clouddn.com/grid-flex-12.jpg)\n \n4. **flex-basis**  \n  flex-basis定义了在分配多余空间之前，项目占据的主轴空间。览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n  \n\t\t  .item {\n\t\t    flex-basis: <length> | auto; /* default auto */\n\t\t}\n\t\t\n利用flex-basis，我们可以很容易实现页面布局中的常见问题：两栏/三栏布局\n\n\t\t\t<div class=\"box\">\n\t\t    <div class=\"left\">left</div>\n\t\t    <div class=\"main\">main</div>\n\t\t</div>\n\t\t\n\t\t\n\t\t\t\t.box {\n\t\t    display: flex;\n\t\t    height: 200px;\n\t\t\t\t}\n\t\t\t\t.left {\n\t\t\t\t    background-color: yellow;\n\t\t\t\t    flex-basis: 200px;\n\t\t\t/* flex-basis定义该项目在分配主轴空间之前提前获得200px的空间 */\n\t\t\t\t    flex-grow: 0;\n\t\t\t\t    /* flex-grow定义该项目不分配剩余空间 */\n\t\t\t\t}\n\t\t\t\t.main {\n\t\t\t\t    background-color: green;\n\t\t\t\t    flex-grow: 1;\n\t\t\t\t    /* flex-grow定义main占满剩余空间 */\n\t\t\t\t}\n\t\t\t\t\n![](http://oczira72b.bkt.clouddn.com/grid-flex-13.jpg)\n\n5.**flex** \nflex是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n\t\t\t.item {\n\t\t\t    flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\t\t\t}\n6. **align-self**  \n   align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。    \n    \n \n# Grid  \n## 概念\ngrid 布局。是一个基于网格的二维布局系统。grid是第一个专门为了解决那些我们一直使用 hack 手段而导致的页面布局问题而创建的CSS模块。  \n一个grid容器的内容：  \n\n* 可以将应用程序分割成不同的空间  \n* 可以定义子项的大小、位置以及层级。\n* 与表格类似的是：可以让Web设计师根据元素按列或行对齐排列。\n* 可以定位自己的位置，这样他们可以重叠和类似元素定位。\n* 可以通过结合CSS的媒体查询属性，根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容  \n\n**浏览器支持**\n![](http://oczira72b.bkt.clouddn.com/grid-flex-25.jpg)\n\n采用grid布局的元素，称为grid容器（grid container）。它的所有子元素自动成为容器成员，称为grid项目（grid item）。\n\n分隔的线组成了网格的结构。它们可以是垂直的（“列网格线”）或者水平的（“行网格线”），也可以在行或列的任一边。下面的例子中黄色的线是一个列网格线的例子。  \n**网格线**  \n每条网格线具有默认的编号，从左到右和从上到下分别为1,2,3......\n![](http://oczira72b.bkt.clouddn.com/grid-flex-3.jpg)\n**网格单元**  \n网格单元是指两根毗邻的行网格线和列网格线中间的位置，它是一个单独的网格“单元”，如图所示，网格单元是指第 1 和 2 根行网格线和第 2 和 3 根列网格线中间的位置。    \n![](http://oczira72b.bkt.clouddn.com/flex-grid-4.png)  \n**网格轨迹**    \n网格轨迹是指两根毗邻线中间的位置，可以认为是网格的行或者列  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-26.png)  \n**网格区域**  \n网格区域是指 4 根网格线包围的空间，一个网格空间可能由任意数量的网格单元构成  \n![](http://oczira72b.bkt.clouddn.com/grid-flex-27.png)  \n\n\n## 容器的属性\n\n1. **disaplay**\ndisplay属性定义了一个网格容器，容器是展现为行内或块状由所给定的值而决定，此时，他的所有子元素进入grid文档流，称为grid项目 \n\n\t\t\t\t.box {\n\t\t\t\t    display: grid | inline-grid | subgrid;\n\t\t\t\t}\ngrid定义了一个网格容器，它以块级元素的形式显示  \ninline-grid定义了一个网格容器，它以内联元素的形式显示  \nsubgrid定义了一个网格容器，这个网格容器是其父级网格容器的一个子项。它的行和列的大小从父级网格容器中获取  \n\n2. **grid-template-columns | grid-template-rows**  \ngrid-template-rows和grid-template-columns定义了一个网格的列数、行数以及网格的大小。\n\n\t\t\t.box {\n\t\t\t\t    grid-template-columns: <track-size> ... | <line-name> <track-size> ...;\n\t\t\t\t    grid-template-rows: <track-size> ... | <line-name> <track-size> ...;\n\t\t\t\t}\n定义网格单元的宽高，其单位可以是一个长度(如px、em、rem、vw、vh)或百分比，也可以是网格中自由空间的份数(单位为fr)  \n定义网格线的名称，它不是必须值。可以一个你选择的任意名字，当没有显示设定时，它的名字以数字表示。  \n\n\t\t\t.box {\n\t\t\t    grid-template-columns: 40px 50px auto 50px 40px;\n\t\t\t    grid-template-rows: 25% 100px auto;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-28.png)\n\n\t\t.box {\n\t\t    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n\t\t    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-29.png)\n\n一根网格线可以有多个名字，例如在下面的例子中第二根线有两个名字：row1-end 和 row2-start，命名方式以空格来作为间隔。\n\n     .box{\n         grid-template-rows:[row1-start] 25% [row1-end row-start] 25% [row-end];\n         }\n         \n定义了容器的重复部分，你可以使用CSS的repeat()方法来生成多个相同值：\n\t\t\n\t\t.box {\n\t\t    grid-template-columns: repeat(3, 20px [col-start]) 5%;\n\t\t}\n\t\t\t\t\n\t\t.box {\n\t\t    grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;\n\t\t}\n\t\t\nfr是一个特殊的单位，它可以类似于设定flex-grow时，给网格容器中的自由空间设置为一个份数，举个例子，下面的例子将把网格容器的每个子项设置为三分之一\n\n\t\t.box {\n    \t\tgrid-template-columns: 1fr 1fr 1fr;\n\t\t}\n\t\t\n也是类似于flex-grow，自由空间是在固定子项确定后开始计算的（这里就如同flex-basis提前给予宽高那样），在下面的例子中自由空间是fr单位的总和但不包括50px：\n\t\t\t.box {\n\t\t\t    grid-template-columns: 1fr 50px 1fr 1fr;\n\t\t\t}\n\t\t\t\n3. **grid-template-areas**  \n   grid-template-areas可以配合gird-area定义一个显示的网格区域。  \n   grid-template-areas定义网格区域，然后使用grid-area调用声明好的网格区域名称来放置对应的网格项目  \n   \n         <section class=\"grid\">\n\t\t    <div class=\"title\">title</div>\n\t\t    <div class=\"nav\">nav</div>\n\t\t    <div class=\"main\">main</div>\n\t\t    <div class=\"aside\">aside</div>\n\t\t    <div class=\"footer\">footer</div>\n\t\t</section>  \n\t\t.grid {\n\t\t\t    display: grid;\n\t\t\t    grid-template-columns: 100px 100px 100px 100px 100px;\n\t\t\t    grid-template-rows: 100px 100px 100px 100px;\n\t\t\t    grid-template-areas: 'title title title title aside'\n\t\t\t                          'nav main main main aside'\n\t\t\t                          'nav main main main aside'\n\t\t\t                          'footer footer footer footer footer';\n\t\t\t    font-size: 30px;\n\t\t\t    text-align: center;\n\t\t\t}\n\t\t\t.title {\n\t\t\t    grid-area: title;\n\t\t\t    background-color: blue;\n\t\t\t}\n\t\t\t.nav {\n\t\t\t    grid-area: nav;\n\t\t\t    background-color: yellow;\n\t\t\t}\n\t\t\t.main {\n\t\t\t    grid-area: main;\n\t\t\t    background-color: gray;\n\t\t\t}\n\t\t\t.aside {\n\t\t\t    grid-area: aside;\n\t\t\t    background-color: green;\n\t\t\t}\n\t\t\t.footer {\n\t\t\t    grid-area: footer;\n\t\t\t    background-color: pink;\n\t\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-30.jpg)   \n\n4. **grid-column-gap|grid-row-gap**  \n   grid-column-gap和grid-row-gap定义了网格之间的间距\n   \n\t\t   .box {\n\t\t    grid-template-columns: 100px 50px 100px;\n\t\t    grid-template-rows: 80px auto 80px;\n\t\t    grid-column-gap: 10px;\n\t\t    grid-row-gap: 15px;\n\t\t}\n![](http://oczira72b.bkt.clouddn.com/grid-flex-31.png) \n\n5.**justify-items**  \njustify-items定义了网格子项的内容和列轴对齐方式，即水平方向上的对齐方式  \n\n\t\t\t.box {\n\t\t\t    justify-items: start | end | center | stretch;\n\t\t\t}\nstart代表内容和网格区域的左边对齐  \nend代表内容和网格区域的右边对齐  \ncenter代表内容和网格区域的中间对齐  \nstretch为默认值，代表填充整个网格区域的宽度  \n\n6. **align-items**  \n  类似于justify-items，align-items定义了网格子项的内容和行轴对齐方式，即垂直方向上的对齐方式。\n  \n\t\t\t .box {\n\t\t\t    align-items: start | end | center | stretch;\n\t\t\t}\n\t\t\t  \nstart代表内容和网格区域的上边对齐  \nend代表内容和网格区域的下边对齐  \ncenter代表内容和网格区域的中间对齐  \nstretch为默认值，代表填充整个网格区域的高度  \n\n7. **justity-content|align-content**\n  justify-content属性定义了网格和网格容器列轴对齐方式  \n  \n  \t\t\t.box {\n\t\t\t    justify-content|align-content: start | end | center | stretch | space-around | space-between | space-evenly;\n\t\t\t}\nstart代表网格在网格容器(左|上）边对齐  \nend代表网格在网格容器(右|下)边对齐  \ncenter代表网格在网格容器中间对齐  \nstretch改变网格子项的容量让其填充整个网格容器宽度  \nspace-around代表在每个网格子项中间放置均等的空间，在始末两端只有一半大小  \nspace-between代表在每个网格子项中间放置均等的空间，在始末两端没有空间  \nspace-evenly代表在每个网格子项中间放置均等的空间，包括始末两端  \n\n8. **grid-auto-columns|grid-auto-rows**  \n   grid-auto-columns与grid-auto-rows可以指定隐式网格。\n   \t\t\n   \t\t<div class=\"grid\">\n\t\t    <div class=\"box1\">box1</div>\n\t\t    <div class=\"box2\">box2</div>\n\t\t    <div class=\"box3\">box3</div>\n\t\t    <div class=\"box4\">box4</div>\n\t\t</div>\n  \t\t\t.grid {\n\t\t\t    display: grid;\n\t\t\t    grid-template-columns: 200px;\n\t\t\t    grid-template-rows: 200px;\n\t\t\t    text-align: center;\n\t\t\t    font-size: 30px;\n\t\t\t}\n\t\t\t.box1 {\n\t\t\t    background-color: pink;\n\t\t\t    grid-column: 1;\n\t\t\t    grid-row: 1;\n\t\t\t}\n\t\t\t.box2 {\n\t\t\t    background-color: yellow;\n\t\t\t    grid-column: 2;\n\t\t\t    grid-row: 1;\n\t\t\t}\n\t\t\t.box3 {\n\t\t\t    background-color: gray;\n\t\t\t    grid-column: 1;\n\t\t\t    grid-column: 2;\n\t\t\t}\n\t\t\t.box4 {\n\t\t\t    background-color: blue;\n\t\t\t    grid-column: 2;\n\t\t\t    grid-row: 2;\n\t\t\t}\n\n![](http://oczira72b.bkt.clouddn.com/grid-flex-54.jpg)  \n通过grid-auto-columns与grid-auto-rows属性，创建一个隐式的2×2的网格  \n\n\t\t\t\tgrid-auto-columns: 300px;\n\t\t\t\tgrid-auto-rows: 300px;\n![](http://oczira72b.bkt.clouddn.com/grid-flex-55.jpg)  \n9. **grid-auto-flow**    \n   grid布局自身具有的自动布局算法会将网格子项自动放置起来，而grid-auto-flow属性控制自动布局算法如何工作\n \n\t   .box {\n\t    grid-auto-flow: row | column | row dense | column dense\n\t}\n\t\nrow为默认值，代表自动布局算法在每一行中依次填充，只有必要时才会添加新行。  \ncolumn代表自动布局算法在每一列中依次填充，只有必要时才会添加新行。  \ndense代表告诉自动布局算法如果更小的子项出现时尝试在网格中填补漏洞。  \n10 **grid**  \ngrid为以下属性的合并写法：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns，grid-auto-flow。它也可以设置grid-column-gap和grid-row-gap。  \n\n\t.box {\n\t    grid: none | <grid-template-rows> / <grid-template-columns> | <grid-auto-flow> [<grid-auto-rows> [/ <grid-auto-columns>]];\n\t}\n","slug":"flex&grid","published":1,"date":"2018-11-22T14:45:53.235Z","updated":"2018-11-22T14:45:53.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjosppz0t0000ggjgaewxck5n","content":"<h1 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h2><ul>\n<li><strong>容器的声明</strong><br>Flex是Flexible Box的缩写，意为”弹性布局”<br>任何容器，我们均可以将它指定为flex布局，行内元素也可以使用Flex布局，Webkit内核的浏览器，必须加上-webkit前缀<br>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效</li>\n</ul>\n<pre><code>  .box{\n    display:flex;\n    }\n\n\n  .box{  \n  display:inline-flex;\n  }\n\n  .box{\n  display:-webkit-flex;\n  display:flex;\n}\n</code></pre><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-2.png\" alt=\"\"><br> 采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）<br> 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size</p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><ol>\n<li><p><strong>flex-direction</strong><br>该属性决定主轴的方向</p>\n<pre><code>     .box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-5.jpg\" alt=\"\"></p>\n</li>\n<li><p><strong>flex-wrap</strong><br>如果一条轴线排不下，如何换行  </p>\n<pre><code>.box{\n     flex-wrap: nowrap | wrap | wrap-reverse;\n   }\n</code></pre><p> nowrap为默认值，代表不换行。<br> wrap代表换行，但默认为第一行在上方。<br> wrap-reverse代表换行，但默认为第一行在下方。     </p>\n</li>\n<li><strong>flex-flow</strong><br>flex-flow属性是<strong>flex-direction</strong>属性和<strong>flex-wrap</strong>属性的简写形式，默认值为<strong>row nowrap</strong></li>\n</ol>\n<pre><code> .box {\n  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}\n</code></pre><ol start=\"4\">\n<li><p><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上的对齐方式。</p>\n<pre><code>   .box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n</code></pre><p>flex-start为默认值，代表项目在主轴上向起始方向对齐<br>flex-end代表项目在主轴上向结束方向对齐<br>center代表项目在主轴上居中对齐<br>space-between代表项目在主轴上两端对齐，但第一个项目在主轴的起始位置，最后一个项目在主轴的结束位置<br>space-around代表项目在主轴上等分间距，但第一个项目与最后一个项目距离主轴的两端保持一定的距离，这个距离为项目之间间距的1/2<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-7.jpg\" alt=\"\"></p>\n</li>\n<li><p><strong>align-items</strong><br>align-items属性定义项目在交叉轴上如何对齐。</p>\n<pre><code>.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-8.jpg\" alt=\"\"><br>flex-start代表项目在交叉轴上向起始方向对齐。<br>flex-end代表项目在交叉轴上向结束方向对齐。<br>center代表项目在交叉轴上居中对齐。<br>baseline代表项目在交叉轴上向项目的第一行文字的基线对齐。<br>stretch代表项目在交叉轴上拉伸对齐。 </p>\n</li>\n<li><p><strong>align-content</strong><br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<pre><code>.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n</code></pre><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-9.jpg\" alt=\"\">  </p>\n</li>\n</ol>\n<h2 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h2><ol>\n<li><p><strong>order</strong><br>order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0  </p>\n<pre><code>  .item {\n  order: &lt;integer&gt;;\n}\n</code></pre><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-10.jpg\" alt=\"\"> </p>\n</li>\n</ol>\n<p>2.<strong>flex-grow</strong><br>  flex-grow定义了项目的放大比例。如果所有伸缩项目的flex-grow设置了1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了flex-grow值为2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。</p>\n<p>ps：负值对该属性无效。  </p>\n<pre><code>.item {\n    flex-grow: &lt;number&gt;; /* default 0 */\n}\n</code></pre><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-11.jpg\" alt=\"\"></p>\n<ol start=\"3\">\n<li><strong>flex-shrink</strong><br>类似于flex-grow，flex-shrink定义了项目的缩小比例。其默认值为1  </li>\n</ol>\n<p>如果所有项目的flex-shrink都为1，当空间不足时，都将等比例缩小  </p>\n<p>如果所有项目都为1，但其中一个项目的flex-shrink为0，即代表空间不足时，该项目缩小0倍，即为不缩小  </p>\n<p>ps：负值对该属性不起作用。<br> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-12.jpg\" alt=\"\"></p>\n<ol start=\"4\">\n<li><p><strong>flex-basis</strong><br>flex-basis定义了在分配多余空间之前，项目占据的主轴空间。览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n<pre><code>  .item {\n    flex-basis: &lt;length&gt; | auto; /* default auto */\n}\n</code></pre></li>\n</ol>\n<p>利用flex-basis，我们可以很容易实现页面布局中的常见问题：两栏/三栏布局</p>\n<pre><code>    &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n&lt;/div&gt;\n\n\n        .box {\n    display: flex;\n    height: 200px;\n        }\n        .left {\n            background-color: yellow;\n            flex-basis: 200px;\n    /* flex-basis定义该项目在分配主轴空间之前提前获得200px的空间 */\n            flex-grow: 0;\n            /* flex-grow定义该项目不分配剩余空间 */\n        }\n        .main {\n            background-color: green;\n            flex-grow: 1;\n            /* flex-grow定义main占满剩余空间 */\n        }\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-13.jpg\" alt=\"\"></p>\n<p>5.<strong>flex</strong><br>flex是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n<pre><code>.item {\n    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]\n}\n</code></pre><ol start=\"6\">\n<li><strong>align-self</strong><br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。    </li>\n</ol>\n<h1 id=\"Grid\"><a href=\"#Grid\" class=\"headerlink\" title=\"Grid\"></a>Grid</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>grid 布局。是一个基于网格的二维布局系统。grid是第一个专门为了解决那些我们一直使用 hack 手段而导致的页面布局问题而创建的CSS模块。<br>一个grid容器的内容：  </p>\n<ul>\n<li>可以将应用程序分割成不同的空间  </li>\n<li>可以定义子项的大小、位置以及层级。</li>\n<li>与表格类似的是：可以让Web设计师根据元素按列或行对齐排列。</li>\n<li>可以定位自己的位置，这样他们可以重叠和类似元素定位。</li>\n<li>可以通过结合CSS的媒体查询属性，根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容  </li>\n</ul>\n<p><strong>浏览器支持</strong><br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-25.jpg\" alt=\"\"></p>\n<p>采用grid布局的元素，称为grid容器（grid container）。它的所有子元素自动成为容器成员，称为grid项目（grid item）。</p>\n<p>分隔的线组成了网格的结构。它们可以是垂直的（“列网格线”）或者水平的（“行网格线”），也可以在行或列的任一边。下面的例子中黄色的线是一个列网格线的例子。<br><strong>网格线</strong><br>每条网格线具有默认的编号，从左到右和从上到下分别为1,2,3……<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-3.jpg\" alt=\"\"><br><strong>网格单元</strong><br>网格单元是指两根毗邻的行网格线和列网格线中间的位置，它是一个单独的网格“单元”，如图所示，网格单元是指第 1 和 2 根行网格线和第 2 和 3 根列网格线中间的位置。<br><img src=\"http://oczira72b.bkt.clouddn.com/flex-grid-4.png\" alt=\"\"><br><strong>网格轨迹</strong><br>网格轨迹是指两根毗邻线中间的位置，可以认为是网格的行或者列<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-26.png\" alt=\"\"><br><strong>网格区域</strong><br>网格区域是指 4 根网格线包围的空间，一个网格空间可能由任意数量的网格单元构成<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-27.png\" alt=\"\">  </p>\n<h2 id=\"容器的属性-1\"><a href=\"#容器的属性-1\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><ol>\n<li><p><strong>disaplay</strong><br>display属性定义了一个网格容器，容器是展现为行内或块状由所给定的值而决定，此时，他的所有子元素进入grid文档流，称为grid项目 </p>\n<pre><code>.box {\n    display: grid | inline-grid | subgrid;\n}\n</code></pre><p>grid定义了一个网格容器，它以块级元素的形式显示<br>inline-grid定义了一个网格容器，它以内联元素的形式显示<br>subgrid定义了一个网格容器，这个网格容器是其父级网格容器的一个子项。它的行和列的大小从父级网格容器中获取  </p>\n</li>\n<li><p><strong>grid-template-columns | grid-template-rows</strong><br>grid-template-rows和grid-template-columns定义了一个网格的列数、行数以及网格的大小。</p>\n<pre><code>.box {\n        grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;\n        grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;\n    }\n</code></pre><p>定义网格单元的宽高，其单位可以是一个长度(如px、em、rem、vw、vh)或百分比，也可以是网格中自由空间的份数(单位为fr)<br>定义网格线的名称，它不是必须值。可以一个你选择的任意名字，当没有显示设定时，它的名字以数字表示。  </p>\n<pre><code>.box {\n    grid-template-columns: 40px 50px auto 50px 40px;\n    grid-template-rows: 25% 100px auto;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-28.png\" alt=\"\"></p>\n<pre><code>.box {\n    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-29.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>一根网格线可以有多个名字，例如在下面的例子中第二根线有两个名字：row1-end 和 row2-start，命名方式以空格来作为间隔。</p>\n<pre><code>.box{\n    grid-template-rows:[row1-start] 25% [row1-end row-start] 25% [row-end];\n    }\n</code></pre><p>定义了容器的重复部分，你可以使用CSS的repeat()方法来生成多个相同值：</p>\n<pre><code>.box {\n    grid-template-columns: repeat(3, 20px [col-start]) 5%;\n}\n\n.box {\n    grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;\n}\n</code></pre><p>fr是一个特殊的单位，它可以类似于设定flex-grow时，给网格容器中的自由空间设置为一个份数，举个例子，下面的例子将把网格容器的每个子项设置为三分之一</p>\n<pre><code>.box {\n    grid-template-columns: 1fr 1fr 1fr;\n}\n</code></pre><p>也是类似于flex-grow，自由空间是在固定子项确定后开始计算的（这里就如同flex-basis提前给予宽高那样），在下面的例子中自由空间是fr单位的总和但不包括50px：<br>            .box {<br>                grid-template-columns: 1fr 50px 1fr 1fr;<br>            }</p>\n<ol start=\"3\">\n<li><p><strong>grid-template-areas</strong><br>grid-template-areas可以配合gird-area定义一个显示的网格区域。<br>grid-template-areas定义网格区域，然后使用grid-area调用声明好的网格区域名称来放置对应的网格项目  </p>\n<pre><code> &lt;section class=&quot;grid&quot;&gt;\n    &lt;div class=&quot;title&quot;&gt;title&lt;/div&gt;\n    &lt;div class=&quot;nav&quot;&gt;nav&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n    &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt;\n    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;\n&lt;/section&gt;  \n.grid {\n        display: grid;\n        grid-template-columns: 100px 100px 100px 100px 100px;\n        grid-template-rows: 100px 100px 100px 100px;\n        grid-template-areas: &apos;title title title title aside&apos;\n                              &apos;nav main main main aside&apos;\n                              &apos;nav main main main aside&apos;\n                              &apos;footer footer footer footer footer&apos;;\n        font-size: 30px;\n        text-align: center;\n    }\n    .title {\n        grid-area: title;\n        background-color: blue;\n    }\n    .nav {\n        grid-area: nav;\n        background-color: yellow;\n    }\n    .main {\n        grid-area: main;\n        background-color: gray;\n    }\n    .aside {\n        grid-area: aside;\n        background-color: green;\n    }\n    .footer {\n        grid-area: footer;\n        background-color: pink;\n    }\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-30.jpg\" alt=\"\">   </p>\n</li>\n<li><p><strong>grid-column-gap|grid-row-gap</strong><br>grid-column-gap和grid-row-gap定义了网格之间的间距</p>\n<pre><code>   .box {\n    grid-template-columns: 100px 50px 100px;\n    grid-template-rows: 80px auto 80px;\n    grid-column-gap: 10px;\n    grid-row-gap: 15px;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-31.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>5.<strong>justify-items</strong><br>justify-items定义了网格子项的内容和列轴对齐方式，即水平方向上的对齐方式  </p>\n<pre><code>.box {\n    justify-items: start | end | center | stretch;\n}\n</code></pre><p>start代表内容和网格区域的左边对齐<br>end代表内容和网格区域的右边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的宽度  </p>\n<ol start=\"6\">\n<li><p><strong>align-items</strong><br>类似于justify-items，align-items定义了网格子项的内容和行轴对齐方式，即垂直方向上的对齐方式。</p>\n<pre><code> .box {\n    align-items: start | end | center | stretch;\n}\n</code></pre></li>\n</ol>\n<p>start代表内容和网格区域的上边对齐<br>end代表内容和网格区域的下边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的高度  </p>\n<ol start=\"7\">\n<li><p><strong>justity-content|align-content</strong><br>justify-content属性定义了网格和网格容器列轴对齐方式  </p>\n<pre><code>  .box {\n    justify-content|align-content: start | end | center | stretch | space-around | space-between | space-evenly;\n}\n</code></pre><p>start代表网格在网格容器(左|上）边对齐<br>end代表网格在网格容器(右|下)边对齐<br>center代表网格在网格容器中间对齐<br>stretch改变网格子项的容量让其填充整个网格容器宽度<br>space-around代表在每个网格子项中间放置均等的空间，在始末两端只有一半大小<br>space-between代表在每个网格子项中间放置均等的空间，在始末两端没有空间<br>space-evenly代表在每个网格子项中间放置均等的空间，包括始末两端  </p>\n</li>\n<li><p><strong>grid-auto-columns|grid-auto-rows</strong><br>grid-auto-columns与grid-auto-rows可以指定隐式网格。</p>\n<pre><code>   &lt;div class=&quot;grid&quot;&gt;\n    &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;\n    &lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt;\n    &lt;div class=&quot;box4&quot;&gt;box4&lt;/div&gt;\n&lt;/div&gt;\n      .grid {\n        display: grid;\n        grid-template-columns: 200px;\n        grid-template-rows: 200px;\n        text-align: center;\n        font-size: 30px;\n    }\n    .box1 {\n        background-color: pink;\n        grid-column: 1;\n        grid-row: 1;\n    }\n    .box2 {\n        background-color: yellow;\n        grid-column: 2;\n        grid-row: 1;\n    }\n    .box3 {\n        background-color: gray;\n        grid-column: 1;\n        grid-column: 2;\n    }\n    .box4 {\n        background-color: blue;\n        grid-column: 2;\n        grid-row: 2;\n    }\n</code></pre></li>\n</ol>\n<p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-54.jpg\" alt=\"\"><br>通过grid-auto-columns与grid-auto-rows属性，创建一个隐式的2×2的网格  </p>\n<pre><code>grid-auto-columns: 300px;\ngrid-auto-rows: 300px;\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-55.jpg\" alt=\"\">  </p>\n<ol start=\"9\">\n<li><p><strong>grid-auto-flow</strong><br>grid布局自身具有的自动布局算法会将网格子项自动放置起来，而grid-auto-flow属性控制自动布局算法如何工作</p>\n<pre><code>.box {\n grid-auto-flow: row | column | row dense | column dense\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>row为默认值，代表自动布局算法在每一行中依次填充，只有必要时才会添加新行。<br>column代表自动布局算法在每一列中依次填充，只有必要时才会添加新行。<br>dense代表告诉自动布局算法如果更小的子项出现时尝试在网格中填补漏洞。<br>10 <strong>grid</strong><br>grid为以下属性的合并写法：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns，grid-auto-flow。它也可以设置grid-column-gap和grid-row-gap。  </p>\n<pre><code>.box {\n    grid: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [/ &lt;grid-auto-columns&gt;]];\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h2><ul>\n<li><strong>容器的声明</strong><br>Flex是Flexible Box的缩写，意为”弹性布局”<br>任何容器，我们均可以将它指定为flex布局，行内元素也可以使用Flex布局，Webkit内核的浏览器，必须加上-webkit前缀<br>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效</li>\n</ul>\n<pre><code>  .box{\n    display:flex;\n    }\n\n\n  .box{  \n  display:inline-flex;\n  }\n\n  .box{\n  display:-webkit-flex;\n  display:flex;\n}\n</code></pre><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-2.png\" alt=\"\"><br> 采用flex布局的元素，称为flex容器（flex container）。它的所有子元素自动成为容器成员，称为flex项目（flex item）<br> 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size</p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><ol>\n<li><p><strong>flex-direction</strong><br>该属性决定主轴的方向</p>\n<pre><code>     .box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-5.jpg\" alt=\"\"></p>\n</li>\n<li><p><strong>flex-wrap</strong><br>如果一条轴线排不下，如何换行  </p>\n<pre><code>.box{\n     flex-wrap: nowrap | wrap | wrap-reverse;\n   }\n</code></pre><p> nowrap为默认值，代表不换行。<br> wrap代表换行，但默认为第一行在上方。<br> wrap-reverse代表换行，但默认为第一行在下方。     </p>\n</li>\n<li><strong>flex-flow</strong><br>flex-flow属性是<strong>flex-direction</strong>属性和<strong>flex-wrap</strong>属性的简写形式，默认值为<strong>row nowrap</strong></li>\n</ol>\n<pre><code> .box {\n  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}\n</code></pre><ol start=\"4\">\n<li><p><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上的对齐方式。</p>\n<pre><code>   .box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n</code></pre><p>flex-start为默认值，代表项目在主轴上向起始方向对齐<br>flex-end代表项目在主轴上向结束方向对齐<br>center代表项目在主轴上居中对齐<br>space-between代表项目在主轴上两端对齐，但第一个项目在主轴的起始位置，最后一个项目在主轴的结束位置<br>space-around代表项目在主轴上等分间距，但第一个项目与最后一个项目距离主轴的两端保持一定的距离，这个距离为项目之间间距的1/2<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-7.jpg\" alt=\"\"></p>\n</li>\n<li><p><strong>align-items</strong><br>align-items属性定义项目在交叉轴上如何对齐。</p>\n<pre><code>.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-8.jpg\" alt=\"\"><br>flex-start代表项目在交叉轴上向起始方向对齐。<br>flex-end代表项目在交叉轴上向结束方向对齐。<br>center代表项目在交叉轴上居中对齐。<br>baseline代表项目在交叉轴上向项目的第一行文字的基线对齐。<br>stretch代表项目在交叉轴上拉伸对齐。 </p>\n</li>\n<li><p><strong>align-content</strong><br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<pre><code>.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n</code></pre><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-9.jpg\" alt=\"\">  </p>\n</li>\n</ol>\n<h2 id=\"项目的属性\"><a href=\"#项目的属性\" class=\"headerlink\" title=\"项目的属性\"></a>项目的属性</h2><ol>\n<li><p><strong>order</strong><br>order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0  </p>\n<pre><code>  .item {\n  order: &lt;integer&gt;;\n}\n</code></pre><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-10.jpg\" alt=\"\"> </p>\n</li>\n</ol>\n<p>2.<strong>flex-grow</strong><br>  flex-grow定义了项目的放大比例。如果所有伸缩项目的flex-grow设置了1，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了flex-grow值为2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。</p>\n<p>ps：负值对该属性无效。  </p>\n<pre><code>.item {\n    flex-grow: &lt;number&gt;; /* default 0 */\n}\n</code></pre><p> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-11.jpg\" alt=\"\"></p>\n<ol start=\"3\">\n<li><strong>flex-shrink</strong><br>类似于flex-grow，flex-shrink定义了项目的缩小比例。其默认值为1  </li>\n</ol>\n<p>如果所有项目的flex-shrink都为1，当空间不足时，都将等比例缩小  </p>\n<p>如果所有项目都为1，但其中一个项目的flex-shrink为0，即代表空间不足时，该项目缩小0倍，即为不缩小  </p>\n<p>ps：负值对该属性不起作用。<br> <img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-12.jpg\" alt=\"\"></p>\n<ol start=\"4\">\n<li><p><strong>flex-basis</strong><br>flex-basis定义了在分配多余空间之前，项目占据的主轴空间。览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n<pre><code>  .item {\n    flex-basis: &lt;length&gt; | auto; /* default auto */\n}\n</code></pre></li>\n</ol>\n<p>利用flex-basis，我们可以很容易实现页面布局中的常见问题：两栏/三栏布局</p>\n<pre><code>    &lt;div class=&quot;box&quot;&gt;\n    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n&lt;/div&gt;\n\n\n        .box {\n    display: flex;\n    height: 200px;\n        }\n        .left {\n            background-color: yellow;\n            flex-basis: 200px;\n    /* flex-basis定义该项目在分配主轴空间之前提前获得200px的空间 */\n            flex-grow: 0;\n            /* flex-grow定义该项目不分配剩余空间 */\n        }\n        .main {\n            background-color: green;\n            flex-grow: 1;\n            /* flex-grow定义main占满剩余空间 */\n        }\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-13.jpg\" alt=\"\"></p>\n<p>5.<strong>flex</strong><br>flex是flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>\n<pre><code>.item {\n    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]\n}\n</code></pre><ol start=\"6\">\n<li><strong>align-self</strong><br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。    </li>\n</ol>\n<h1 id=\"Grid\"><a href=\"#Grid\" class=\"headerlink\" title=\"Grid\"></a>Grid</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>grid 布局。是一个基于网格的二维布局系统。grid是第一个专门为了解决那些我们一直使用 hack 手段而导致的页面布局问题而创建的CSS模块。<br>一个grid容器的内容：  </p>\n<ul>\n<li>可以将应用程序分割成不同的空间  </li>\n<li>可以定义子项的大小、位置以及层级。</li>\n<li>与表格类似的是：可以让Web设计师根据元素按列或行对齐排列。</li>\n<li>可以定位自己的位置，这样他们可以重叠和类似元素定位。</li>\n<li>可以通过结合CSS的媒体查询属性，根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容  </li>\n</ul>\n<p><strong>浏览器支持</strong><br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-25.jpg\" alt=\"\"></p>\n<p>采用grid布局的元素，称为grid容器（grid container）。它的所有子元素自动成为容器成员，称为grid项目（grid item）。</p>\n<p>分隔的线组成了网格的结构。它们可以是垂直的（“列网格线”）或者水平的（“行网格线”），也可以在行或列的任一边。下面的例子中黄色的线是一个列网格线的例子。<br><strong>网格线</strong><br>每条网格线具有默认的编号，从左到右和从上到下分别为1,2,3……<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-3.jpg\" alt=\"\"><br><strong>网格单元</strong><br>网格单元是指两根毗邻的行网格线和列网格线中间的位置，它是一个单独的网格“单元”，如图所示，网格单元是指第 1 和 2 根行网格线和第 2 和 3 根列网格线中间的位置。<br><img src=\"http://oczira72b.bkt.clouddn.com/flex-grid-4.png\" alt=\"\"><br><strong>网格轨迹</strong><br>网格轨迹是指两根毗邻线中间的位置，可以认为是网格的行或者列<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-26.png\" alt=\"\"><br><strong>网格区域</strong><br>网格区域是指 4 根网格线包围的空间，一个网格空间可能由任意数量的网格单元构成<br><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-27.png\" alt=\"\">  </p>\n<h2 id=\"容器的属性-1\"><a href=\"#容器的属性-1\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><ol>\n<li><p><strong>disaplay</strong><br>display属性定义了一个网格容器，容器是展现为行内或块状由所给定的值而决定，此时，他的所有子元素进入grid文档流，称为grid项目 </p>\n<pre><code>.box {\n    display: grid | inline-grid | subgrid;\n}\n</code></pre><p>grid定义了一个网格容器，它以块级元素的形式显示<br>inline-grid定义了一个网格容器，它以内联元素的形式显示<br>subgrid定义了一个网格容器，这个网格容器是其父级网格容器的一个子项。它的行和列的大小从父级网格容器中获取  </p>\n</li>\n<li><p><strong>grid-template-columns | grid-template-rows</strong><br>grid-template-rows和grid-template-columns定义了一个网格的列数、行数以及网格的大小。</p>\n<pre><code>.box {\n        grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;\n        grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;\n    }\n</code></pre><p>定义网格单元的宽高，其单位可以是一个长度(如px、em、rem、vw、vh)或百分比，也可以是网格中自由空间的份数(单位为fr)<br>定义网格线的名称，它不是必须值。可以一个你选择的任意名字，当没有显示设定时，它的名字以数字表示。  </p>\n<pre><code>.box {\n    grid-template-columns: 40px 50px auto 50px 40px;\n    grid-template-rows: 25% 100px auto;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-28.png\" alt=\"\"></p>\n<pre><code>.box {\n    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-29.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>一根网格线可以有多个名字，例如在下面的例子中第二根线有两个名字：row1-end 和 row2-start，命名方式以空格来作为间隔。</p>\n<pre><code>.box{\n    grid-template-rows:[row1-start] 25% [row1-end row-start] 25% [row-end];\n    }\n</code></pre><p>定义了容器的重复部分，你可以使用CSS的repeat()方法来生成多个相同值：</p>\n<pre><code>.box {\n    grid-template-columns: repeat(3, 20px [col-start]) 5%;\n}\n\n.box {\n    grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;\n}\n</code></pre><p>fr是一个特殊的单位，它可以类似于设定flex-grow时，给网格容器中的自由空间设置为一个份数，举个例子，下面的例子将把网格容器的每个子项设置为三分之一</p>\n<pre><code>.box {\n    grid-template-columns: 1fr 1fr 1fr;\n}\n</code></pre><p>也是类似于flex-grow，自由空间是在固定子项确定后开始计算的（这里就如同flex-basis提前给予宽高那样），在下面的例子中自由空间是fr单位的总和但不包括50px：<br>            .box {<br>                grid-template-columns: 1fr 50px 1fr 1fr;<br>            }</p>\n<ol start=\"3\">\n<li><p><strong>grid-template-areas</strong><br>grid-template-areas可以配合gird-area定义一个显示的网格区域。<br>grid-template-areas定义网格区域，然后使用grid-area调用声明好的网格区域名称来放置对应的网格项目  </p>\n<pre><code> &lt;section class=&quot;grid&quot;&gt;\n    &lt;div class=&quot;title&quot;&gt;title&lt;/div&gt;\n    &lt;div class=&quot;nav&quot;&gt;nav&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;\n    &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt;\n    &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;\n&lt;/section&gt;  \n.grid {\n        display: grid;\n        grid-template-columns: 100px 100px 100px 100px 100px;\n        grid-template-rows: 100px 100px 100px 100px;\n        grid-template-areas: &apos;title title title title aside&apos;\n                              &apos;nav main main main aside&apos;\n                              &apos;nav main main main aside&apos;\n                              &apos;footer footer footer footer footer&apos;;\n        font-size: 30px;\n        text-align: center;\n    }\n    .title {\n        grid-area: title;\n        background-color: blue;\n    }\n    .nav {\n        grid-area: nav;\n        background-color: yellow;\n    }\n    .main {\n        grid-area: main;\n        background-color: gray;\n    }\n    .aside {\n        grid-area: aside;\n        background-color: green;\n    }\n    .footer {\n        grid-area: footer;\n        background-color: pink;\n    }\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-30.jpg\" alt=\"\">   </p>\n</li>\n<li><p><strong>grid-column-gap|grid-row-gap</strong><br>grid-column-gap和grid-row-gap定义了网格之间的间距</p>\n<pre><code>   .box {\n    grid-template-columns: 100px 50px 100px;\n    grid-template-rows: 80px auto 80px;\n    grid-column-gap: 10px;\n    grid-row-gap: 15px;\n}\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-31.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>5.<strong>justify-items</strong><br>justify-items定义了网格子项的内容和列轴对齐方式，即水平方向上的对齐方式  </p>\n<pre><code>.box {\n    justify-items: start | end | center | stretch;\n}\n</code></pre><p>start代表内容和网格区域的左边对齐<br>end代表内容和网格区域的右边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的宽度  </p>\n<ol start=\"6\">\n<li><p><strong>align-items</strong><br>类似于justify-items，align-items定义了网格子项的内容和行轴对齐方式，即垂直方向上的对齐方式。</p>\n<pre><code> .box {\n    align-items: start | end | center | stretch;\n}\n</code></pre></li>\n</ol>\n<p>start代表内容和网格区域的上边对齐<br>end代表内容和网格区域的下边对齐<br>center代表内容和网格区域的中间对齐<br>stretch为默认值，代表填充整个网格区域的高度  </p>\n<ol start=\"7\">\n<li><p><strong>justity-content|align-content</strong><br>justify-content属性定义了网格和网格容器列轴对齐方式  </p>\n<pre><code>  .box {\n    justify-content|align-content: start | end | center | stretch | space-around | space-between | space-evenly;\n}\n</code></pre><p>start代表网格在网格容器(左|上）边对齐<br>end代表网格在网格容器(右|下)边对齐<br>center代表网格在网格容器中间对齐<br>stretch改变网格子项的容量让其填充整个网格容器宽度<br>space-around代表在每个网格子项中间放置均等的空间，在始末两端只有一半大小<br>space-between代表在每个网格子项中间放置均等的空间，在始末两端没有空间<br>space-evenly代表在每个网格子项中间放置均等的空间，包括始末两端  </p>\n</li>\n<li><p><strong>grid-auto-columns|grid-auto-rows</strong><br>grid-auto-columns与grid-auto-rows可以指定隐式网格。</p>\n<pre><code>   &lt;div class=&quot;grid&quot;&gt;\n    &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;\n    &lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt;\n    &lt;div class=&quot;box4&quot;&gt;box4&lt;/div&gt;\n&lt;/div&gt;\n      .grid {\n        display: grid;\n        grid-template-columns: 200px;\n        grid-template-rows: 200px;\n        text-align: center;\n        font-size: 30px;\n    }\n    .box1 {\n        background-color: pink;\n        grid-column: 1;\n        grid-row: 1;\n    }\n    .box2 {\n        background-color: yellow;\n        grid-column: 2;\n        grid-row: 1;\n    }\n    .box3 {\n        background-color: gray;\n        grid-column: 1;\n        grid-column: 2;\n    }\n    .box4 {\n        background-color: blue;\n        grid-column: 2;\n        grid-row: 2;\n    }\n</code></pre></li>\n</ol>\n<p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-54.jpg\" alt=\"\"><br>通过grid-auto-columns与grid-auto-rows属性，创建一个隐式的2×2的网格  </p>\n<pre><code>grid-auto-columns: 300px;\ngrid-auto-rows: 300px;\n</code></pre><p><img src=\"http://oczira72b.bkt.clouddn.com/grid-flex-55.jpg\" alt=\"\">  </p>\n<ol start=\"9\">\n<li><p><strong>grid-auto-flow</strong><br>grid布局自身具有的自动布局算法会将网格子项自动放置起来，而grid-auto-flow属性控制自动布局算法如何工作</p>\n<pre><code>.box {\n grid-auto-flow: row | column | row dense | column dense\n</code></pre><p> }</p>\n</li>\n</ol>\n<p>row为默认值，代表自动布局算法在每一行中依次填充，只有必要时才会添加新行。<br>column代表自动布局算法在每一列中依次填充，只有必要时才会添加新行。<br>dense代表告诉自动布局算法如果更小的子项出现时尝试在网格中填补漏洞。<br>10 <strong>grid</strong><br>grid为以下属性的合并写法：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns，grid-auto-flow。它也可以设置grid-column-gap和grid-row-gap。  </p>\n<pre><code>.box {\n    grid: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [/ &lt;grid-auto-columns&gt;]];\n}\n</code></pre>"},{"title":"head-meta","_content":"\n使用 HTML5 doctype，不区分大小写 \n\n\t\t<!DOCTYPE html> \n\n\n\t\n\t\t\n单一的 zh 和 zh-CN 均属于废弃用法。  \n问题主要在于，zh 现在不是语言code了，而是macrolang，能作为语言code的是cmn（国语）、yue（粤语）、wuu（吴语）等。  \n通常建议写成 zh-cmn 而不是光写 cmn，主要是考虑兼容性（至少可匹配 zh），有不少软件和框架还没有据此更新。zh-CN 的问题还在于，其实多数情况下标记的是简体中文，但是不恰当的使用了地区  \n所以其实应该使用 zh-Hans / zh-Hant 来表示简体和繁体。\n\n\t<html lang=\"zh-cmn-Hans\">\n\n   \n  声明文档使用的字符编码   \n  \n    <meta charset='utf-8'>\n  \n  优先使用 IE 最新版本和 Chrome  \n  \n\t  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/>\n\t    \n页面描述\t\n\n  \t<meta name=\"description\" content=\"不超过150个字符\"/>\n 页面关键词 \n \n    <meta name=\"keywords\" content=\"\"/>\n 网页作者 \n \n    <meta name=\"author\" content=\"name, email@gmail.com\"/>\n 搜索引擎抓取\n \n    <meta name=\"robots\" content=\"index,follow\"/>\n 为移动设备添加 viewport\n \n    <meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\">\n    \n  `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz \n  \n  iOS 设备 begin \n   添加到主屏后的标题（iOS 6 新增）\n   \n    <meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n   是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 \n   \n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    \n\n 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）\n \n    <meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\">\n  \n设置苹果工具栏颜色 \n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/>\n   \n忽略页面中的数字识别为电话，忽略email识别 \n\n\t<meta name=\"format-detection\" content=\"telphone=no, email=no\"/>\n\n 启用360浏览器的极速模式(webkit)\n    <meta name=\"renderer\" content=\"webkit\">\n    \n避免IE使用兼容模式 \n\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    \n不让百度转码 \n\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n    \n 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓\n \n    <meta name=\"HandheldFriendly\" content=\"true\">\n    \n微软的老式浏览器 \n\n    <meta name=\"MobileOptimized\" content=\"320\">\n    \n   uc强制竖屏 \n   \n    <meta name=\"screen-orientation\" content=\"portrait\">\n    \n  QQ强制竖屏\n  \n    <meta name=\"x5-orientation\" content=\"portrait\">\n    \n   UC强制全屏\n   \n    <meta name=\"full-screen\" content=\"yes\">\n    \n QQ强制全屏 \n \n    <meta name=\"x5-fullscreen\" content=\"true\">\n    \n   UC应用模式\n   \n    <meta name=\"browsermode\" content=\"application\">\n    \n   QQ应用模式\n   \n    <meta name=\"x5-page-mode\" content=\"app\">\n    \n  windows phone 点击无高光 \n  \n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n    \n iOS 图标 begin \n iPhone 和 iTouch，默认 57x57 像素，必须有 \n \n    <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n\nRetina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有\n\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\nRetina iPad，144x144 像素，可以没有，但推荐有 \n\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n    \niOS 图标\n \n  iOS 启动画面 begin \n  iPad 竖屏 768 x 1004（标准分辨率）\n  \n    <link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n\niPad 竖屏 1536x2008（Retina）\n\n    <link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n\niPad 横屏 1024x748（标准分辨率）\n\n    <link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n  \niPad 横屏 2048x1496（Retina） \n \n    <link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n    \n iPhone/iPod Touch 竖屏 320x480 (标准分辨率)\n \n    <link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/>\n\niPhone/iPod Touch 竖屏 640x960 (Retina) \n\n    <link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/>\n\niPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) \n\n    <link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/>\n\n\n Windows 8 磁贴颜色\n \n    <meta name=\"msapplication-TileColor\" content=\"#000\"/>\n    \n Windows 8 磁贴图标 \n \n    <meta name=\"msapplication-TileImage\" content=\"icon.png\"/>\n \n  添加 RSS 订阅\n    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/>\n\n添加 favicon icon \n    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/>\n\n sns 社交标签 begin \n 参考微博API \n \n    <meta property=\"og:type\" content=\"类型\" />\n    <meta property=\"og:url\" content=\"URL地址\" />\n    <meta property=\"og:title\" content=\"标题\" />\n    <meta property=\"og:image\" content=\"图片\" />\n    <meta property=\"og:description\" content=\"描述\" />\nsns 社交标签 end\n \n    <title>标题</title>\n\n","source":"_posts/head-meta.md","raw":"---\ntitle:      \"head-meta\"\ntags:\n    - head\n---\n\n使用 HTML5 doctype，不区分大小写 \n\n\t\t<!DOCTYPE html> \n\n\n\t\n\t\t\n单一的 zh 和 zh-CN 均属于废弃用法。  \n问题主要在于，zh 现在不是语言code了，而是macrolang，能作为语言code的是cmn（国语）、yue（粤语）、wuu（吴语）等。  \n通常建议写成 zh-cmn 而不是光写 cmn，主要是考虑兼容性（至少可匹配 zh），有不少软件和框架还没有据此更新。zh-CN 的问题还在于，其实多数情况下标记的是简体中文，但是不恰当的使用了地区  \n所以其实应该使用 zh-Hans / zh-Hant 来表示简体和繁体。\n\n\t<html lang=\"zh-cmn-Hans\">\n\n   \n  声明文档使用的字符编码   \n  \n    <meta charset='utf-8'>\n  \n  优先使用 IE 最新版本和 Chrome  \n  \n\t  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/>\n\t    \n页面描述\t\n\n  \t<meta name=\"description\" content=\"不超过150个字符\"/>\n 页面关键词 \n \n    <meta name=\"keywords\" content=\"\"/>\n 网页作者 \n \n    <meta name=\"author\" content=\"name, email@gmail.com\"/>\n 搜索引擎抓取\n \n    <meta name=\"robots\" content=\"index,follow\"/>\n 为移动设备添加 viewport\n \n    <meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\">\n    \n  `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz \n  \n  iOS 设备 begin \n   添加到主屏后的标题（iOS 6 新增）\n   \n    <meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n   是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 \n   \n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    \n\n 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）\n \n    <meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\">\n  \n设置苹果工具栏颜色 \n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/>\n   \n忽略页面中的数字识别为电话，忽略email识别 \n\n\t<meta name=\"format-detection\" content=\"telphone=no, email=no\"/>\n\n 启用360浏览器的极速模式(webkit)\n    <meta name=\"renderer\" content=\"webkit\">\n    \n避免IE使用兼容模式 \n\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    \n不让百度转码 \n\n    <meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" />\n    \n 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓\n \n    <meta name=\"HandheldFriendly\" content=\"true\">\n    \n微软的老式浏览器 \n\n    <meta name=\"MobileOptimized\" content=\"320\">\n    \n   uc强制竖屏 \n   \n    <meta name=\"screen-orientation\" content=\"portrait\">\n    \n  QQ强制竖屏\n  \n    <meta name=\"x5-orientation\" content=\"portrait\">\n    \n   UC强制全屏\n   \n    <meta name=\"full-screen\" content=\"yes\">\n    \n QQ强制全屏 \n \n    <meta name=\"x5-fullscreen\" content=\"true\">\n    \n   UC应用模式\n   \n    <meta name=\"browsermode\" content=\"application\">\n    \n   QQ应用模式\n   \n    <meta name=\"x5-page-mode\" content=\"app\">\n    \n  windows phone 点击无高光 \n  \n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n    \n iOS 图标 begin \n iPhone 和 iTouch，默认 57x57 像素，必须有 \n \n    <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n\nRetina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有\n\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\nRetina iPad，144x144 像素，可以没有，但推荐有 \n\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n    \niOS 图标\n \n  iOS 启动画面 begin \n  iPad 竖屏 768 x 1004（标准分辨率）\n  \n    <link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n\niPad 竖屏 1536x2008（Retina）\n\n    <link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n\niPad 横屏 1024x748（标准分辨率）\n\n    <link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n  \niPad 横屏 2048x1496（Retina） \n \n    <link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n    \n iPhone/iPod Touch 竖屏 320x480 (标准分辨率)\n \n    <link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/>\n\niPhone/iPod Touch 竖屏 640x960 (Retina) \n\n    <link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/>\n\niPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) \n\n    <link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/>\n\n\n Windows 8 磁贴颜色\n \n    <meta name=\"msapplication-TileColor\" content=\"#000\"/>\n    \n Windows 8 磁贴图标 \n \n    <meta name=\"msapplication-TileImage\" content=\"icon.png\"/>\n \n  添加 RSS 订阅\n    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/>\n\n添加 favicon icon \n    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/>\n\n sns 社交标签 begin \n 参考微博API \n \n    <meta property=\"og:type\" content=\"类型\" />\n    <meta property=\"og:url\" content=\"URL地址\" />\n    <meta property=\"og:title\" content=\"标题\" />\n    <meta property=\"og:image\" content=\"图片\" />\n    <meta property=\"og:description\" content=\"描述\" />\nsns 社交标签 end\n \n    <title>标题</title>\n\n","slug":"head-meta","published":1,"date":"2018-12-06T15:30:01.296Z","updated":"2018-12-06T15:30:01.296Z","_id":"cjou118i20000xijgczp7dy6a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用 HTML5 doctype，不区分大小写 </p>\n<pre><code>&lt;!DOCTYPE html&gt; \n</code></pre><p>单一的 zh 和 zh-CN 均属于废弃用法。<br>问题主要在于，zh 现在不是语言code了，而是macrolang，能作为语言code的是cmn（国语）、yue（粤语）、wuu（吴语）等。<br>通常建议写成 zh-cmn 而不是光写 cmn，主要是考虑兼容性（至少可匹配 zh），有不少软件和框架还没有据此更新。zh-CN 的问题还在于，其实多数情况下标记的是简体中文，但是不恰当的使用了地区<br>所以其实应该使用 zh-Hans / zh-Hant 来表示简体和繁体。</p>\n<pre><code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;\n</code></pre><p>  声明文档使用的字符编码   </p>\n<pre><code>&lt;meta charset=&apos;utf-8&apos;&gt;\n</code></pre><p>  优先使用 IE 最新版本和 Chrome  </p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;\n</code></pre><p>页面描述    </p>\n<pre><code>&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;\n</code></pre><p> 页面关键词 </p>\n<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;\n</code></pre><p> 网页作者 </p>\n<pre><code>&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;\n</code></pre><p> 搜索引擎抓取</p>\n<pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;\n</code></pre><p> 为移动设备添加 viewport</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;\n</code></pre><p>  <code>width=device-width</code> 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 <a href=\"http://bigc.at/ios-webapp-viewport-meta.orz\" target=\"_blank\" rel=\"noopener\">http://bigc.at/ios-webapp-viewport-meta.orz</a> </p>\n<p>  iOS 设备 begin<br>   添加到主屏后的标题（iOS 6 新增）</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;\n</code></pre><p>   是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 </p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;\n</code></pre><p> 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</p>\n<pre><code>&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;\n</code></pre><p>设置苹果工具栏颜色<br>    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"></p>\n<p>忽略页面中的数字识别为电话，忽略email识别 </p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;\n</code></pre><p> 启用360浏览器的极速模式(webkit)<br>    <meta name=\"renderer\" content=\"webkit\"></p>\n<p>避免IE使用兼容模式 </p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n</code></pre><p>不让百度转码 </p>\n<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;\n</code></pre><p> 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</p>\n<pre><code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;\n</code></pre><p>微软的老式浏览器 </p>\n<pre><code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;\n</code></pre><p>   uc强制竖屏 </p>\n<pre><code>&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;\n</code></pre><p>  QQ强制竖屏</p>\n<pre><code>&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;\n</code></pre><p>   UC强制全屏</p>\n<pre><code>&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;\n</code></pre><p> QQ强制全屏 </p>\n<pre><code>&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;\n</code></pre><p>   UC应用模式</p>\n<pre><code>&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;\n</code></pre><p>   QQ应用模式</p>\n<pre><code>&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;\n</code></pre><p>  windows phone 点击无高光 </p>\n<pre><code>&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;\n</code></pre><p> iOS 图标 begin<br> iPhone 和 iTouch，默认 57x57 像素，必须有 </p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;\n</code></pre><p>Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有</p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;\n</code></pre><p>Retina iPad，144x144 像素，可以没有，但推荐有 </p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;\n</code></pre><p>iOS 图标</p>\n<p>  iOS 启动画面 begin<br>  iPad 竖屏 768 x 1004（标准分辨率）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;\n</code></pre><p>iPad 竖屏 1536x2008（Retina）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;\n</code></pre><p>iPad 横屏 1024x748（标准分辨率）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;\n</code></pre><p>iPad 横屏 2048x1496（Retina） </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;\n</code></pre><p> iPhone/iPod Touch 竖屏 320x480 (标准分辨率)</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;\n</code></pre><p>iPhone/iPod Touch 竖屏 640x960 (Retina) </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;\n</code></pre><p>iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;\n</code></pre><p> Windows 8 磁贴颜色</p>\n<pre><code>&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;\n</code></pre><p> Windows 8 磁贴图标 </p>\n<pre><code>&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;\n</code></pre><p>  添加 RSS 订阅<br>    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"></p>\n<p>添加 favicon icon<br>    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"></p>\n<p> sns 社交标签 begin<br> 参考微博API </p>\n<pre><code>&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;\n&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;\n&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;\n&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;\n&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;\n</code></pre><p>sns 社交标签 end</p>\n<pre><code>&lt;title&gt;标题&lt;/title&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>使用 HTML5 doctype，不区分大小写 </p>\n<pre><code>&lt;!DOCTYPE html&gt; \n</code></pre><p>单一的 zh 和 zh-CN 均属于废弃用法。<br>问题主要在于，zh 现在不是语言code了，而是macrolang，能作为语言code的是cmn（国语）、yue（粤语）、wuu（吴语）等。<br>通常建议写成 zh-cmn 而不是光写 cmn，主要是考虑兼容性（至少可匹配 zh），有不少软件和框架还没有据此更新。zh-CN 的问题还在于，其实多数情况下标记的是简体中文，但是不恰当的使用了地区<br>所以其实应该使用 zh-Hans / zh-Hant 来表示简体和繁体。</p>\n<pre><code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;\n</code></pre><p>  声明文档使用的字符编码   </p>\n<pre><code>&lt;meta charset=&apos;utf-8&apos;&gt;\n</code></pre><p>  优先使用 IE 最新版本和 Chrome  </p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;\n</code></pre><p>页面描述    </p>\n<pre><code>&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;\n</code></pre><p> 页面关键词 </p>\n<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;\n</code></pre><p> 网页作者 </p>\n<pre><code>&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;\n</code></pre><p> 搜索引擎抓取</p>\n<pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;\n</code></pre><p> 为移动设备添加 viewport</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;\n</code></pre><p>  <code>width=device-width</code> 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 <a href=\"http://bigc.at/ios-webapp-viewport-meta.orz\" target=\"_blank\" rel=\"noopener\">http://bigc.at/ios-webapp-viewport-meta.orz</a> </p>\n<p>  iOS 设备 begin<br>   添加到主屏后的标题（iOS 6 新增）</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;\n</code></pre><p>   是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 </p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;\n</code></pre><p> 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</p>\n<pre><code>&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;\n</code></pre><p>设置苹果工具栏颜色<br>    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"></p>\n<p>忽略页面中的数字识别为电话，忽略email识别 </p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;\n</code></pre><p> 启用360浏览器的极速模式(webkit)<br>    <meta name=\"renderer\" content=\"webkit\"></p>\n<p>避免IE使用兼容模式 </p>\n<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n</code></pre><p>不让百度转码 </p>\n<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;\n</code></pre><p> 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</p>\n<pre><code>&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;\n</code></pre><p>微软的老式浏览器 </p>\n<pre><code>&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;\n</code></pre><p>   uc强制竖屏 </p>\n<pre><code>&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;\n</code></pre><p>  QQ强制竖屏</p>\n<pre><code>&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;\n</code></pre><p>   UC强制全屏</p>\n<pre><code>&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;\n</code></pre><p> QQ强制全屏 </p>\n<pre><code>&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;\n</code></pre><p>   UC应用模式</p>\n<pre><code>&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;\n</code></pre><p>   QQ应用模式</p>\n<pre><code>&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;\n</code></pre><p>  windows phone 点击无高光 </p>\n<pre><code>&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;\n</code></pre><p> iOS 图标 begin<br> iPhone 和 iTouch，默认 57x57 像素，必须有 </p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;\n</code></pre><p>Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有</p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;\n</code></pre><p>Retina iPad，144x144 像素，可以没有，但推荐有 </p>\n<pre><code>&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;\n</code></pre><p>iOS 图标</p>\n<p>  iOS 启动画面 begin<br>  iPad 竖屏 768 x 1004（标准分辨率）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;\n</code></pre><p>iPad 竖屏 1536x2008（Retina）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;\n</code></pre><p>iPad 横屏 1024x748（标准分辨率）</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;\n</code></pre><p>iPad 横屏 2048x1496（Retina） </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;\n</code></pre><p> iPhone/iPod Touch 竖屏 320x480 (标准分辨率)</p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;\n</code></pre><p>iPhone/iPod Touch 竖屏 640x960 (Retina) </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;\n</code></pre><p>iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) </p>\n<pre><code>&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;\n</code></pre><p> Windows 8 磁贴颜色</p>\n<pre><code>&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;\n</code></pre><p> Windows 8 磁贴图标 </p>\n<pre><code>&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;\n</code></pre><p>  添加 RSS 订阅<br>    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"></p>\n<p>添加 favicon icon<br>    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"></p>\n<p> sns 社交标签 begin<br> 参考微博API </p>\n<pre><code>&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;\n&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;\n&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;\n&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;\n&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;\n</code></pre><p>sns 社交标签 end</p>\n<pre><code>&lt;title&gt;标题&lt;/title&gt;\n</code></pre>"},{"title":"跨域","_content":"\n\n# 什么是跨域\n协议，域名，端口任何一项不同都会引起跨域问题  \n注意： 下面讨论的解决方案都是针对于域名引起的跨域的，协议和端口的跨域前端无能为力  \n\n# 跨域解决方案\n## 1.document.domain + iframe\n只有主域相同才能使用  \n\n\t\t\t//parent.domain.com/a.html\n\t\t\tdocument.doman = 'domain.com'\n\t\t\tvar ifr = document.createElement('iframe')\n\t\t\tifr.src = 'child.domain.com/b.html'\n\t\t\tifr.display = none;\n\t\t\tdocument.body.appendChild(ifr);\n\t\t\tifr.onload = function () {\n\t\t\t\tvar doc = ifr.contentDocument || ifr.contentWindow.document\n\t\t\t\t//doc \n\t\t\t\t ifr.onload = null;\n\t\t\t}\n\t\t\t\n--\n\n\t\t\t//child.domain.com/b.html\n\t\t\tdocument.domain = 'domain.com'\n\n## 2.动态创建script\n\n\tfunction loadScript(url, func) {\n\t  var head = document.head || document.getElementByTagName('head')[0];\n\t  var script = document.createElement('script');\n\t  script.src = url;\n\t \n\t  script.onload = script.onreadystatechange = function(){\n\t    if(!this.readyState || this.readyState=='loaded' || this.readyState=='complete'){\n\t      func();\n\t      script.onload = script.onreadystatechange = null;\n\t    }\n\t  };\n\t \n\t  head.insertBefore(script, null);\n\t}\n\twindow.baidu = {\n\t  sug: function(data){\n\t    console.log(data);\n\t  }\n\t}\n\tloadScript('http://suggestion.baidu.com/su?wd=w',function(){console.log('loaded')});\t\n\t\n## 3.loaction.hash+ iframe  \n\t\t//a.com/a.html\n\tfunction startRequest(){\n\t    var ifr = document.createElement('iframe');\n\t    ifr.style.display = 'none';\n\t    ifr.src = 'http://b.com/b.html#paramdo';\n   \t\t document.body.appendChild(ifr);\n\t}\n\t \n\tfunction checkHash() {\n\t    try {\n\t        var data = location.hash ? location.hash.substring(1) : '';\n\t        if (console.log) {\n\t            console.log('Now the data is '+data);\n\t        }\n\t    } catch(e) {};\n\t}\n\tsetInterval(checkHash, 2000);\n--\n\t//b.com/b.html\n\t//模拟一个简单的参数处理操作\n\tswitch(location.hash){\n\t    case '#paramdo':\n\t        callBack();\n\t        break;\n\t    case '#paramset':\n\t        //do something……\n\t        break;\n\t}\n\t \n\tfunction callBack(){\n\t    try {\n\t        parent.location.hash = 'somedata';\n\t    } catch (e) {\n\t        // ie、chrome的安全机制无法修改parent.location.hash，\n\t        // 所以要利用一个中间的cnblogs域下的代理iframe\n\t        var ifrproxy = document.createElement('iframe');\n\t        ifrproxy.style.display = 'none';\n\t        ifrproxy.src = 'http://a.com/c.html#somedata';    // 注意该文件在\"a.com\"域下\n\t        document.body.appendChild(ifrproxy);\n\t    }\n\t}\t\n--\n\t//http://a.com/c.html\n\tparent.parent.location.hash = self.location.hash.substring(1);\n## 4.window.name + iframe  \nwindow.name :name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB)  \n\n\t\t\t//a.com/a/html\n\t\t\t\t\tfunction proxy(url,func) {\n\t\t\tvar isFirst = true;\n\t\t\tvar ifr = document.createElement('iframe');\n\t\t\tloadFunc = function() {\n\t\t\t\tconsole.log(1,isFirst)\n\t\t\t\tif(isFirst) {\n\t\t\t\t\tifr.src = 'a.com/cs1.html';\n\t\t\t\t\tisFirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('name',ifr.contentWindow.name)\n\t\t\t\t\tfunc(ifr.contentWindow.name);\n\t\t\t\t\tdocument.body.removeChild(ifr);\n\t\t\t\t\tifr.src = null;\n\t\t\t\t\tifr = '';\n\t\t\t\t}\n\t\t\n\t\t\t}\n\t\t\t ifr.src = url;\n\t\t    ifr.style.display = 'none';\n\t\t    if(ifr.attachEvent){ ifr.attachEvent('onload', loadFunc);\n\t\t}else {ifr.onload = loadFunc;}\n\t\t     document.body.appendChild(ifr);\n\t\t}\n\t\t\n\t\t proxy('http://www.baidu.com/', function(data){\n\t\t      console.log('data',data);\n\t\t    });\n\t\t    \n## 5.\tpostMessage  \n\n\ta.com/index.html中的代码：\n\t<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function() {\n    \tvar ifr = document.getElementById('ifr');\n   \t\tvar targetOrigin = 'http://b.com';\n     \t// 若写成'http://b.com/c/proxy.html'效果一样\n      \t// 若写成'http://c.com'就不会执行postMessage了\n   \t\tifr.contentWindow.postMessage('I was there!', targetOrigin);\n\t};\n\t</script>\n\n\t//b.com/index.html\n\twindow.addEventListener('message', function(event){\n\t        // 通过origin属性判断消息来源地址\n\t        if (event.origin == 'http://a.com') {\n\t            alert(event.data);    // 弹出\"I was there!\"\n\t            alert(event.source);  \n\t            // 对a.com、index.html中window对象的引用\n\t            // 但由于同源策略，这里event.source不可以访问window对象\n\t        }\n\t    }, false);\n## 6.CORS  \n## 7.JSONP  \n\t\tfunction handleResponse(response){\n\t    console.log('The responsed data is: '+response.data);\n\t}\n\tvar script = document.createElement('script');\n\tscript.src = 'http://www.baidu.com/json/?callback=handleResponse';\n\tdocument.body.insertBefore(script, document.body.firstChild);\n\t/*handleResonse({\"data\": \"zhe\"})*/\n\t//原理如下：\n\t//当我们通过script标签请求时\n\t//后台就会根据相应的参数(json,handleResponse)\n\t//来生成相应的json数据(handleResponse({\"data\": \"zhe\"}))\n\t//最后这个返回的json数据(代码)就会被放在当前js文件中被执行\n\t//至此跨域通信完成\n\t\n## 8.web socket\n\n\t\n\t\t\t    \n\t","source":"_posts/跨域.md","raw":"---\ntitle: 跨域\n---\n\n\n# 什么是跨域\n协议，域名，端口任何一项不同都会引起跨域问题  \n注意： 下面讨论的解决方案都是针对于域名引起的跨域的，协议和端口的跨域前端无能为力  \n\n# 跨域解决方案\n## 1.document.domain + iframe\n只有主域相同才能使用  \n\n\t\t\t//parent.domain.com/a.html\n\t\t\tdocument.doman = 'domain.com'\n\t\t\tvar ifr = document.createElement('iframe')\n\t\t\tifr.src = 'child.domain.com/b.html'\n\t\t\tifr.display = none;\n\t\t\tdocument.body.appendChild(ifr);\n\t\t\tifr.onload = function () {\n\t\t\t\tvar doc = ifr.contentDocument || ifr.contentWindow.document\n\t\t\t\t//doc \n\t\t\t\t ifr.onload = null;\n\t\t\t}\n\t\t\t\n--\n\n\t\t\t//child.domain.com/b.html\n\t\t\tdocument.domain = 'domain.com'\n\n## 2.动态创建script\n\n\tfunction loadScript(url, func) {\n\t  var head = document.head || document.getElementByTagName('head')[0];\n\t  var script = document.createElement('script');\n\t  script.src = url;\n\t \n\t  script.onload = script.onreadystatechange = function(){\n\t    if(!this.readyState || this.readyState=='loaded' || this.readyState=='complete'){\n\t      func();\n\t      script.onload = script.onreadystatechange = null;\n\t    }\n\t  };\n\t \n\t  head.insertBefore(script, null);\n\t}\n\twindow.baidu = {\n\t  sug: function(data){\n\t    console.log(data);\n\t  }\n\t}\n\tloadScript('http://suggestion.baidu.com/su?wd=w',function(){console.log('loaded')});\t\n\t\n## 3.loaction.hash+ iframe  \n\t\t//a.com/a.html\n\tfunction startRequest(){\n\t    var ifr = document.createElement('iframe');\n\t    ifr.style.display = 'none';\n\t    ifr.src = 'http://b.com/b.html#paramdo';\n   \t\t document.body.appendChild(ifr);\n\t}\n\t \n\tfunction checkHash() {\n\t    try {\n\t        var data = location.hash ? location.hash.substring(1) : '';\n\t        if (console.log) {\n\t            console.log('Now the data is '+data);\n\t        }\n\t    } catch(e) {};\n\t}\n\tsetInterval(checkHash, 2000);\n--\n\t//b.com/b.html\n\t//模拟一个简单的参数处理操作\n\tswitch(location.hash){\n\t    case '#paramdo':\n\t        callBack();\n\t        break;\n\t    case '#paramset':\n\t        //do something……\n\t        break;\n\t}\n\t \n\tfunction callBack(){\n\t    try {\n\t        parent.location.hash = 'somedata';\n\t    } catch (e) {\n\t        // ie、chrome的安全机制无法修改parent.location.hash，\n\t        // 所以要利用一个中间的cnblogs域下的代理iframe\n\t        var ifrproxy = document.createElement('iframe');\n\t        ifrproxy.style.display = 'none';\n\t        ifrproxy.src = 'http://a.com/c.html#somedata';    // 注意该文件在\"a.com\"域下\n\t        document.body.appendChild(ifrproxy);\n\t    }\n\t}\t\n--\n\t//http://a.com/c.html\n\tparent.parent.location.hash = self.location.hash.substring(1);\n## 4.window.name + iframe  \nwindow.name :name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB)  \n\n\t\t\t//a.com/a/html\n\t\t\t\t\tfunction proxy(url,func) {\n\t\t\tvar isFirst = true;\n\t\t\tvar ifr = document.createElement('iframe');\n\t\t\tloadFunc = function() {\n\t\t\t\tconsole.log(1,isFirst)\n\t\t\t\tif(isFirst) {\n\t\t\t\t\tifr.src = 'a.com/cs1.html';\n\t\t\t\t\tisFirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('name',ifr.contentWindow.name)\n\t\t\t\t\tfunc(ifr.contentWindow.name);\n\t\t\t\t\tdocument.body.removeChild(ifr);\n\t\t\t\t\tifr.src = null;\n\t\t\t\t\tifr = '';\n\t\t\t\t}\n\t\t\n\t\t\t}\n\t\t\t ifr.src = url;\n\t\t    ifr.style.display = 'none';\n\t\t    if(ifr.attachEvent){ ifr.attachEvent('onload', loadFunc);\n\t\t}else {ifr.onload = loadFunc;}\n\t\t     document.body.appendChild(ifr);\n\t\t}\n\t\t\n\t\t proxy('http://www.baidu.com/', function(data){\n\t\t      console.log('data',data);\n\t\t    });\n\t\t    \n## 5.\tpostMessage  \n\n\ta.com/index.html中的代码：\n\t<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n\t<script type=\"text/javascript\">\n\t\twindow.onload = function() {\n    \tvar ifr = document.getElementById('ifr');\n   \t\tvar targetOrigin = 'http://b.com';\n     \t// 若写成'http://b.com/c/proxy.html'效果一样\n      \t// 若写成'http://c.com'就不会执行postMessage了\n   \t\tifr.contentWindow.postMessage('I was there!', targetOrigin);\n\t};\n\t</script>\n\n\t//b.com/index.html\n\twindow.addEventListener('message', function(event){\n\t        // 通过origin属性判断消息来源地址\n\t        if (event.origin == 'http://a.com') {\n\t            alert(event.data);    // 弹出\"I was there!\"\n\t            alert(event.source);  \n\t            // 对a.com、index.html中window对象的引用\n\t            // 但由于同源策略，这里event.source不可以访问window对象\n\t        }\n\t    }, false);\n## 6.CORS  \n## 7.JSONP  \n\t\tfunction handleResponse(response){\n\t    console.log('The responsed data is: '+response.data);\n\t}\n\tvar script = document.createElement('script');\n\tscript.src = 'http://www.baidu.com/json/?callback=handleResponse';\n\tdocument.body.insertBefore(script, document.body.firstChild);\n\t/*handleResonse({\"data\": \"zhe\"})*/\n\t//原理如下：\n\t//当我们通过script标签请求时\n\t//后台就会根据相应的参数(json,handleResponse)\n\t//来生成相应的json数据(handleResponse({\"data\": \"zhe\"}))\n\t//最后这个返回的json数据(代码)就会被放在当前js文件中被执行\n\t//至此跨域通信完成\n\t\n## 8.web socket\n\n\t\n\t\t\t    \n\t","slug":"跨域","published":1,"date":"2018-11-26T15:04:04.999Z","updated":"2018-11-26T15:04:04.999Z","_id":"cjoyft7bp0000nljgn33pwduk","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h1><p>协议，域名，端口任何一项不同都会引起跨域问题<br>注意： 下面讨论的解决方案都是针对于域名引起的跨域的，协议和端口的跨域前端无能为力  </p>\n<h1 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h1><h2 id=\"1-document-domain-iframe\"><a href=\"#1-document-domain-iframe\" class=\"headerlink\" title=\"1.document.domain + iframe\"></a>1.document.domain + iframe</h2><p>只有主域相同才能使用  </p>\n<pre><code>//parent.domain.com/a.html\ndocument.doman = &apos;domain.com&apos;\nvar ifr = document.createElement(&apos;iframe&apos;)\nifr.src = &apos;child.domain.com/b.html&apos;\nifr.display = none;\ndocument.body.appendChild(ifr);\nifr.onload = function () {\n    var doc = ifr.contentDocument || ifr.contentWindow.document\n    //doc \n     ifr.onload = null;\n}\n</code></pre><p>–</p>\n<pre><code>//child.domain.com/b.html\ndocument.domain = &apos;domain.com&apos;\n</code></pre><h2 id=\"2-动态创建script\"><a href=\"#2-动态创建script\" class=\"headerlink\" title=\"2.动态创建script\"></a>2.动态创建script</h2><pre><code>function loadScript(url, func) {\n  var head = document.head || document.getElementByTagName(&apos;head&apos;)[0];\n  var script = document.createElement(&apos;script&apos;);\n  script.src = url;\n\n  script.onload = script.onreadystatechange = function(){\n    if(!this.readyState || this.readyState==&apos;loaded&apos; || this.readyState==&apos;complete&apos;){\n      func();\n      script.onload = script.onreadystatechange = null;\n    }\n  };\n\n  head.insertBefore(script, null);\n}\nwindow.baidu = {\n  sug: function(data){\n    console.log(data);\n  }\n}\nloadScript(&apos;http://suggestion.baidu.com/su?wd=w&apos;,function(){console.log(&apos;loaded&apos;)});    \n</code></pre><h2 id=\"3-loaction-hash-iframe\"><a href=\"#3-loaction-hash-iframe\" class=\"headerlink\" title=\"3.loaction.hash+ iframe\"></a>3.loaction.hash+ iframe</h2><pre><code>    //a.com/a.html\nfunction startRequest(){\n    var ifr = document.createElement(&apos;iframe&apos;);\n    ifr.style.display = &apos;none&apos;;\n    ifr.src = &apos;http://b.com/b.html#paramdo&apos;;\n        document.body.appendChild(ifr);\n}\n\nfunction checkHash() {\n    try {\n        var data = location.hash ? location.hash.substring(1) : &apos;&apos;;\n        if (console.log) {\n            console.log(&apos;Now the data is &apos;+data);\n        }\n    } catch(e) {};\n}\nsetInterval(checkHash, 2000);\n</code></pre><p>–<br>    //b.com/b.html<br>    //模拟一个简单的参数处理操作<br>    switch(location.hash){<br>        case ‘#paramdo’:<br>            callBack();<br>            break;<br>        case ‘#paramset’:<br>            //do something……<br>            break;<br>    }</p>\n<pre><code>function callBack(){\n    try {\n        parent.location.hash = &apos;somedata&apos;;\n    } catch (e) {\n        // ie、chrome的安全机制无法修改parent.location.hash，\n        // 所以要利用一个中间的cnblogs域下的代理iframe\n        var ifrproxy = document.createElement(&apos;iframe&apos;);\n        ifrproxy.style.display = &apos;none&apos;;\n        ifrproxy.src = &apos;http://a.com/c.html#somedata&apos;;    // 注意该文件在&quot;a.com&quot;域下\n        document.body.appendChild(ifrproxy);\n    }\n}    \n</code></pre><p>–<br>    //<a href=\"http://a.com/c.html\" target=\"_blank\" rel=\"noopener\">http://a.com/c.html</a><br>    parent.parent.location.hash = self.location.hash.substring(1);</p>\n<h2 id=\"4-window-name-iframe\"><a href=\"#4-window-name-iframe\" class=\"headerlink\" title=\"4.window.name + iframe\"></a>4.window.name + iframe</h2><p>window.name :name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB)  </p>\n<pre><code>    //a.com/a/html\n            function proxy(url,func) {\n    var isFirst = true;\n    var ifr = document.createElement(&apos;iframe&apos;);\n    loadFunc = function() {\n        console.log(1,isFirst)\n        if(isFirst) {\n            ifr.src = &apos;a.com/cs1.html&apos;;\n            isFirst = false;\n        } else {\n            console.log(&apos;name&apos;,ifr.contentWindow.name)\n            func(ifr.contentWindow.name);\n            document.body.removeChild(ifr);\n            ifr.src = null;\n            ifr = &apos;&apos;;\n        }\n\n    }\n     ifr.src = url;\n    ifr.style.display = &apos;none&apos;;\n    if(ifr.attachEvent){ ifr.attachEvent(&apos;onload&apos;, loadFunc);\n}else {ifr.onload = loadFunc;}\n     document.body.appendChild(ifr);\n}\n\n proxy(&apos;http://www.baidu.com/&apos;, function(data){\n      console.log(&apos;data&apos;,data);\n    });\n</code></pre><h2 id=\"5-postMessage\"><a href=\"#5-postMessage\" class=\"headerlink\" title=\"5.    postMessage\"></a>5.    postMessage</h2><pre><code>a.com/index.html中的代码：\n&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function() {\n    var ifr = document.getElementById(&apos;ifr&apos;);\n       var targetOrigin = &apos;http://b.com&apos;;\n     // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样\n      // 若写成&apos;http://c.com&apos;就不会执行postMessage了\n       ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);\n};\n&lt;/script&gt;\n\n//b.com/index.html\nwindow.addEventListener(&apos;message&apos;, function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == &apos;http://a.com&apos;) {\n            alert(event.data);    // 弹出&quot;I was there!&quot;\n            alert(event.source);  \n            // 对a.com、index.html中window对象的引用\n            // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</code></pre><h2 id=\"6-CORS\"><a href=\"#6-CORS\" class=\"headerlink\" title=\"6.CORS\"></a>6.CORS</h2><h2 id=\"7-JSONP\"><a href=\"#7-JSONP\" class=\"headerlink\" title=\"7.JSONP\"></a>7.JSONP</h2><pre><code>    function handleResponse(response){\n    console.log(&apos;The responsed data is: &apos;+response.data);\n}\nvar script = document.createElement(&apos;script&apos;);\nscript.src = &apos;http://www.baidu.com/json/?callback=handleResponse&apos;;\ndocument.body.insertBefore(script, document.body.firstChild);\n/*handleResonse({&quot;data&quot;: &quot;zhe&quot;})*/\n//原理如下：\n//当我们通过script标签请求时\n//后台就会根据相应的参数(json,handleResponse)\n//来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))\n//最后这个返回的json数据(代码)就会被放在当前js文件中被执行\n//至此跨域通信完成\n</code></pre><h2 id=\"8-web-socket\"><a href=\"#8-web-socket\" class=\"headerlink\" title=\"8.web socket\"></a>8.web socket</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h1><p>协议，域名，端口任何一项不同都会引起跨域问题<br>注意： 下面讨论的解决方案都是针对于域名引起的跨域的，协议和端口的跨域前端无能为力  </p>\n<h1 id=\"跨域解决方案\"><a href=\"#跨域解决方案\" class=\"headerlink\" title=\"跨域解决方案\"></a>跨域解决方案</h1><h2 id=\"1-document-domain-iframe\"><a href=\"#1-document-domain-iframe\" class=\"headerlink\" title=\"1.document.domain + iframe\"></a>1.document.domain + iframe</h2><p>只有主域相同才能使用  </p>\n<pre><code>//parent.domain.com/a.html\ndocument.doman = &apos;domain.com&apos;\nvar ifr = document.createElement(&apos;iframe&apos;)\nifr.src = &apos;child.domain.com/b.html&apos;\nifr.display = none;\ndocument.body.appendChild(ifr);\nifr.onload = function () {\n    var doc = ifr.contentDocument || ifr.contentWindow.document\n    //doc \n     ifr.onload = null;\n}\n</code></pre><p>–</p>\n<pre><code>//child.domain.com/b.html\ndocument.domain = &apos;domain.com&apos;\n</code></pre><h2 id=\"2-动态创建script\"><a href=\"#2-动态创建script\" class=\"headerlink\" title=\"2.动态创建script\"></a>2.动态创建script</h2><pre><code>function loadScript(url, func) {\n  var head = document.head || document.getElementByTagName(&apos;head&apos;)[0];\n  var script = document.createElement(&apos;script&apos;);\n  script.src = url;\n\n  script.onload = script.onreadystatechange = function(){\n    if(!this.readyState || this.readyState==&apos;loaded&apos; || this.readyState==&apos;complete&apos;){\n      func();\n      script.onload = script.onreadystatechange = null;\n    }\n  };\n\n  head.insertBefore(script, null);\n}\nwindow.baidu = {\n  sug: function(data){\n    console.log(data);\n  }\n}\nloadScript(&apos;http://suggestion.baidu.com/su?wd=w&apos;,function(){console.log(&apos;loaded&apos;)});    \n</code></pre><h2 id=\"3-loaction-hash-iframe\"><a href=\"#3-loaction-hash-iframe\" class=\"headerlink\" title=\"3.loaction.hash+ iframe\"></a>3.loaction.hash+ iframe</h2><pre><code>    //a.com/a.html\nfunction startRequest(){\n    var ifr = document.createElement(&apos;iframe&apos;);\n    ifr.style.display = &apos;none&apos;;\n    ifr.src = &apos;http://b.com/b.html#paramdo&apos;;\n        document.body.appendChild(ifr);\n}\n\nfunction checkHash() {\n    try {\n        var data = location.hash ? location.hash.substring(1) : &apos;&apos;;\n        if (console.log) {\n            console.log(&apos;Now the data is &apos;+data);\n        }\n    } catch(e) {};\n}\nsetInterval(checkHash, 2000);\n</code></pre><p>–<br>    //b.com/b.html<br>    //模拟一个简单的参数处理操作<br>    switch(location.hash){<br>        case ‘#paramdo’:<br>            callBack();<br>            break;<br>        case ‘#paramset’:<br>            //do something……<br>            break;<br>    }</p>\n<pre><code>function callBack(){\n    try {\n        parent.location.hash = &apos;somedata&apos;;\n    } catch (e) {\n        // ie、chrome的安全机制无法修改parent.location.hash，\n        // 所以要利用一个中间的cnblogs域下的代理iframe\n        var ifrproxy = document.createElement(&apos;iframe&apos;);\n        ifrproxy.style.display = &apos;none&apos;;\n        ifrproxy.src = &apos;http://a.com/c.html#somedata&apos;;    // 注意该文件在&quot;a.com&quot;域下\n        document.body.appendChild(ifrproxy);\n    }\n}    \n</code></pre><p>–<br>    //<a href=\"http://a.com/c.html\" target=\"_blank\" rel=\"noopener\">http://a.com/c.html</a><br>    parent.parent.location.hash = self.location.hash.substring(1);</p>\n<h2 id=\"4-window-name-iframe\"><a href=\"#4-window-name-iframe\" class=\"headerlink\" title=\"4.window.name + iframe\"></a>4.window.name + iframe</h2><p>window.name :name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB)  </p>\n<pre><code>    //a.com/a/html\n            function proxy(url,func) {\n    var isFirst = true;\n    var ifr = document.createElement(&apos;iframe&apos;);\n    loadFunc = function() {\n        console.log(1,isFirst)\n        if(isFirst) {\n            ifr.src = &apos;a.com/cs1.html&apos;;\n            isFirst = false;\n        } else {\n            console.log(&apos;name&apos;,ifr.contentWindow.name)\n            func(ifr.contentWindow.name);\n            document.body.removeChild(ifr);\n            ifr.src = null;\n            ifr = &apos;&apos;;\n        }\n\n    }\n     ifr.src = url;\n    ifr.style.display = &apos;none&apos;;\n    if(ifr.attachEvent){ ifr.attachEvent(&apos;onload&apos;, loadFunc);\n}else {ifr.onload = loadFunc;}\n     document.body.appendChild(ifr);\n}\n\n proxy(&apos;http://www.baidu.com/&apos;, function(data){\n      console.log(&apos;data&apos;,data);\n    });\n</code></pre><h2 id=\"5-postMessage\"><a href=\"#5-postMessage\" class=\"headerlink\" title=\"5.    postMessage\"></a>5.    postMessage</h2><pre><code>a.com/index.html中的代码：\n&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function() {\n    var ifr = document.getElementById(&apos;ifr&apos;);\n       var targetOrigin = &apos;http://b.com&apos;;\n     // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样\n      // 若写成&apos;http://c.com&apos;就不会执行postMessage了\n       ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);\n};\n&lt;/script&gt;\n\n//b.com/index.html\nwindow.addEventListener(&apos;message&apos;, function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == &apos;http://a.com&apos;) {\n            alert(event.data);    // 弹出&quot;I was there!&quot;\n            alert(event.source);  \n            // 对a.com、index.html中window对象的引用\n            // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</code></pre><h2 id=\"6-CORS\"><a href=\"#6-CORS\" class=\"headerlink\" title=\"6.CORS\"></a>6.CORS</h2><h2 id=\"7-JSONP\"><a href=\"#7-JSONP\" class=\"headerlink\" title=\"7.JSONP\"></a>7.JSONP</h2><pre><code>    function handleResponse(response){\n    console.log(&apos;The responsed data is: &apos;+response.data);\n}\nvar script = document.createElement(&apos;script&apos;);\nscript.src = &apos;http://www.baidu.com/json/?callback=handleResponse&apos;;\ndocument.body.insertBefore(script, document.body.firstChild);\n/*handleResonse({&quot;data&quot;: &quot;zhe&quot;})*/\n//原理如下：\n//当我们通过script标签请求时\n//后台就会根据相应的参数(json,handleResponse)\n//来生成相应的json数据(handleResponse({&quot;data&quot;: &quot;zhe&quot;}))\n//最后这个返回的json数据(代码)就会被放在当前js文件中被执行\n//至此跨域通信完成\n</code></pre><h2 id=\"8-web-socket\"><a href=\"#8-web-socket\" class=\"headerlink\" title=\"8.web socket\"></a>8.web socket</h2>"},{"title":"浏览器与内核","_content":"\n\n## Trident  \nIE内核  \nIE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色\n\n国内很多的双核浏览器的其中一核便是 Trident\n\nWindow10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML\n\n## Gecko  \nFirefox 内核  \n\n## Webkit  \nsafari  \n早期chrome  \n\n## Chromium/Blink  \nchrome  \nchromium fork 自开源引擎 webkit\n\n## Presto\n早期oprea  \n\n## 关于移动端\n移动端的浏览器内核主要说的是系统内置浏览器的内核。\n\n目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。","source":"_posts/浏览器与内核.md","raw":"---\ntitle: 浏览器与内核\ntag: \n    - 浏览器\n---\n\n\n## Trident  \nIE内核  \nIE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色\n\n国内很多的双核浏览器的其中一核便是 Trident\n\nWindow10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML\n\n## Gecko  \nFirefox 内核  \n\n## Webkit  \nsafari  \n早期chrome  \n\n## Chromium/Blink  \nchrome  \nchromium fork 自开源引擎 webkit\n\n## Presto\n早期oprea  \n\n## 关于移动端\n移动端的浏览器内核主要说的是系统内置浏览器的内核。\n\n目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。","slug":"浏览器与内核","published":1,"date":"2018-11-27T14:14:58.200Z","updated":"2018-11-27T14:14:58.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjoztpcqa00002jjgqwxyq0u8","content":"<h2 id=\"Trident\"><a href=\"#Trident\" class=\"headerlink\" title=\"Trident\"></a>Trident</h2><p>IE内核<br>IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色</p>\n<p>国内很多的双核浏览器的其中一核便是 Trident</p>\n<p>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML</p>\n<h2 id=\"Gecko\"><a href=\"#Gecko\" class=\"headerlink\" title=\"Gecko\"></a>Gecko</h2><p>Firefox 内核  </p>\n<h2 id=\"Webkit\"><a href=\"#Webkit\" class=\"headerlink\" title=\"Webkit\"></a>Webkit</h2><p>safari<br>早期chrome  </p>\n<h2 id=\"Chromium-Blink\"><a href=\"#Chromium-Blink\" class=\"headerlink\" title=\"Chromium/Blink\"></a>Chromium/Blink</h2><p>chrome<br>chromium fork 自开源引擎 webkit</p>\n<h2 id=\"Presto\"><a href=\"#Presto\" class=\"headerlink\" title=\"Presto\"></a>Presto</h2><p>早期oprea  </p>\n<h2 id=\"关于移动端\"><a href=\"#关于移动端\" class=\"headerlink\" title=\"关于移动端\"></a>关于移动端</h2><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>\n<p>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Trident\"><a href=\"#Trident\" class=\"headerlink\" title=\"Trident\"></a>Trident</h2><p>IE内核<br>IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色</p>\n<p>国内很多的双核浏览器的其中一核便是 Trident</p>\n<p>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML</p>\n<h2 id=\"Gecko\"><a href=\"#Gecko\" class=\"headerlink\" title=\"Gecko\"></a>Gecko</h2><p>Firefox 内核  </p>\n<h2 id=\"Webkit\"><a href=\"#Webkit\" class=\"headerlink\" title=\"Webkit\"></a>Webkit</h2><p>safari<br>早期chrome  </p>\n<h2 id=\"Chromium-Blink\"><a href=\"#Chromium-Blink\" class=\"headerlink\" title=\"Chromium/Blink\"></a>Chromium/Blink</h2><p>chrome<br>chromium fork 自开源引擎 webkit</p>\n<h2 id=\"Presto\"><a href=\"#Presto\" class=\"headerlink\" title=\"Presto\"></a>Presto</h2><p>早期oprea  </p>\n<h2 id=\"关于移动端\"><a href=\"#关于移动端\" class=\"headerlink\" title=\"关于移动端\"></a>关于移动端</h2><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>\n<p>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p>\n"},{"title":"浏览器渲染","_content":"\n## 从浏览器角度谈渲染\n* 之前更多的优化是从页面资源的数量，传输是否采用了压缩，JS、cSS，是否进行了精简，缓存有没有合理的使用\n* 这次从另一个角度谈页面的渲染，浏览器是如何工作的，要把页面渲染出来，浏览器需要做什么，哪些过程比较耗时\n* 浏览器工作原理![浏览器工作原理](http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib1uAwicF98dVY5j2dib36rQkOw6lnb7Jls3Gd1BBbp5bhk81Q4qkfOFnO7hyXO1bFNdCg6cDVvasj5A/0?wx_fmt=jpeg)\n\t* 加载HTML\n\t* 解析HTML，生成DOM\n\t* 加载CSS，JS\n\t* 解析CSS，生成CSSOM\n\t* JS引擎执行JS\n\t* 合并DOM和CSSOM，生成Render Tree\n\t* 根据Render Tree 进行布局\n\t* 绘制每个层中的元素\n\t* 合并图层\n\n\t\n* 方案：加快完成DOM+CSSOM-Layout-Paint-Composite的整个过程\n   * 分割css\n     对不同的浏览终端，同一终端的不同模式，提供不同的规则（通俗讲屏幕大小和宽高比）把媒体查询放在link上，根据终端情况加载不同的css文件\n     \n     \n   * css规则的优先级  \n     css权重计算的无形增加    \n     **css选择器解析从右往左还是从左往右？？**\n     过多的嵌套规则，会导致复杂的，无必要的深层次规则（SASS，LESS开发过程中尤为明显）  \n     css规则越复杂，构建Render Tree时，浏览器花费的时间越长  \n     \n     \n   * 使用GPU加速\n      很多的动画定时的执行，会导致浏览器的重新布局  \n\t      \n\t\t\t      @keyframes my {\n\t\t\t     20% {\n\t\t\t      top: 10px;\n\t\t\t      }\n\t\t\t  \n\t\t\t  50% {\n\t\t\t      top: 120px;\n\t\t\t  }\n\t\t\t  \n\t\t\t  80% {\n\t\t\t      top: 10px;\n\t\t\t  }\n\t\t\t} \n\t  这些执行可以放到GPU加速执行  \n\t  \n\t\t\t @keyframes my {\n\t\t\t  20% {\n\t\t\t      transform: translateY(10px);\n\t\t\t  }\n\t\t\t \n\t\t\t  50% {\n\t\t\t      transform: translateY(120px);\n\t\t\t  }\n\t\t\t      \n\t\t\t  80% {\n\t\t\t      transform: translateY(10px);\n\t\t\t  }\n\t\t\t}\n\t\t\t\n\t\t\t\n\tjQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 \n\t \n\tjQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。\n    \n\tjQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bu\t\n\t**setTimeOut和FAF（单人淋浴间和大澡堂）**\t\n\t\n\t\n--\n\n\t\tvar startingTop = 0;\n\t\t\t\tsetInterval(function() {\n\t\t\t\t    element.style.top = (startingTop += 1/60);\n\t\t\t\t}, 16);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfunction tick () {\n\t\t\t\t    element.style.top = (startingTop += 1/60);\n\t\t\t\t}\n\t\t\t\twindow.requestAnimationFrame(tick);\n\t\t\t\t\n\t\t\t\t\n--\n  requestAnimationFrame\t\t\n  setTimeout间隔设置过小，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。\t\n  \n  而requestAnimationFrame就是为了这个而出现的。所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧  \n  \n  优势：向下兼容 、相比于css3动画应用更广、动画效果更多\n  \n  CSS transition 的动画逻辑是由浏览器来执行，所以它的性能能够比 jQuery 动画好。它的优势体现在：\n\n通过优化 DOM 操作，避免内存消耗来减少卡顿  \n使用与 RAF 类似的机制  \n强制使用硬件加速 （通过 GPU 来提高动画性能）  \n\t\t\t\n * 异步JavaScript   \n   js执行会阻塞DOM构建的过程，Js中可能存在dom操作 async异步  \n   \n   js可能会不断的重新布局，重新绘制  \n\t     1.访问元素的某些属性  \n\t     2.通过JavaScript修改元素的CSS属性  \n\t     3.在onScroll中做耗时的任务  \n\t     4.在其他Event Handler中做耗时的任务  \n\t     5.图片的预处理  \n\t     6.过多的动画  \n\t     7.过多的数据处理  \n\t     \n   元素的一些属性和方法，当被访问或调用的时候，会触发浏览器的布局和绘制，布局基本上会影响页面的大部分元素，导致耗时长  \n   \n   为了避免之前提到的布局颠簸，我们需要批量访问和更新DOM。\n\n\t\t\tvar currentTop,\n\t\t    currentLeft;\n\t\t/* 有 layout thrashing. */\n\t\tcurrentTop = element.style.top; /* 访问 */\n\t\telement.style.top = currentTop + 1; /* 更新 */\n\t\t\n\t\tcurrentLeft = element.style.left; /* 访问 */\n\t\telement.style.left = currentLeft + 1; /* 更新 */\n\t\t\n\t\t/* 没有 layout thrashing. */\n\t\tcurrentTop = element.style.top; /* 访问 */\n\t\tcurrentLeft = element.style.left; /* 访问 */\n\t\t\n\t\telement.style.top = currentTop + 1; /* 更新 */\n\t\telement.style.left = currentLeft + 1; /* 更新 */\n  计算offset 时，浏览器需要重新计算（重新布局），然后才能返回最新的值 \n   \n\t\t\t       for(var i = 0; i < list.length; i++) {\n\t\t\t  list[i].style.width = parent.offsetWidth + 'px';\n\t\t\t}   \n\t\t\t\n\t\t\t\n\t\t\tvar parentWidth = parent.offsetWidth;\n\t\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\t  list[i].style.width = parentWidth + 'px';\n\t\t\t}\n\t\t\t\n\t\t\t\n   * css样式修改  \n   * 修改布局相关属性，会触发Layout-Paint-Composite\n   * 修改绘制相关属性，会触发Paint-Composite\n   * 其他属性，某些特别属性可在不同层中单独绘制，在合并图层，就是直接Composite  （transform，opacity）\n\n   在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。\n   \n   **类比电梯**\n   \n\t\t   // 防抖动函数\n\t\tfunction debounce(func, wait, immediate) {\n\t\t    var timeout;\n\t\t    return function() {\n\t\t        var context = this, args = arguments;\n\t\t        var later = function() {\n\t\t            timeout = null;\n\t\t            if (!immediate) func.apply(context, args);\n\t\t        };\n\t\t        var callNow = immediate && !timeout;\n\t\t        clearTimeout(timeout);\n\t\t        timeout = setTimeout(later, wait);\n\t\t        if (callNow) func.apply(context, args);\n\t\t    };\n\t\t};\n\t\t \n\t\tvar myEfficientFn = debounce(function() {\n\t\t    // 滚动中的真正的操作\n\t\t}, 250);\n\t\t \n\t\t// 绑定监听\n\t\twindow.addEventListener('resize', myEfficientFn);\n   --\n\t\t\t   // 简单的节流函数\n\t\t\tfunction throttle(func, wait, mustRun) {\n\t\t\t    var timeout,\n\t\t\t        startTime = new Date();\n\t\t\t \n\t\t\t    return function() {\n\t\t\t        var context = this,\n\t\t\t            args = arguments,\n\t\t\t            curTime = new Date();\n\t\t\t \n\t\t\t        clearTimeout(timeout);\n\t\t\t        // 如果达到了规定的触发时间间隔，触发 handler\n\t\t\t        if(curTime - startTime >= mustRun){\n\t\t\t            func.apply(context,args);\n\t\t\t            startTime = curTime;\n\t\t\t        // 没达到触发间隔，重新设定定时器\n\t\t\t        }else{\n\t\t\t            timeout = setTimeout(func, wait);\n\t\t\t        }\n\t\t\t    };\n\t\t};\n\t\t// 实际想绑定在 scroll 事件上的 handler\n\t\tfunction realFunc(){\n\t\t    console.log(\"Success\");\n\t\t}\n\t\t// 采用了节流函数\n\t\twindow.addEventListener('scroll',throttle(realFunc,500,1000));\n\t\t\n\t\t\n\tpointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。\n\t\n\t\nwill-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。  \n\n**类比萨里机长**\n\n值得注意的是，用好这个属性并不是很容易：  \n\n不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。  \n\n不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。  \n\n给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。\n\n**Unable to preventDefault inside passive event listener due to target being treated as passive**\n   \n   window.addEventListener(\"touchstart\", func, {passive: true} );\n   \n   window, document , body\n","source":"_posts/浏览器渲染.md","raw":"---\ntitle: 浏览器渲染\ntag: \n    - 浏览器\n---\n\n## 从浏览器角度谈渲染\n* 之前更多的优化是从页面资源的数量，传输是否采用了压缩，JS、cSS，是否进行了精简，缓存有没有合理的使用\n* 这次从另一个角度谈页面的渲染，浏览器是如何工作的，要把页面渲染出来，浏览器需要做什么，哪些过程比较耗时\n* 浏览器工作原理![浏览器工作原理](http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib1uAwicF98dVY5j2dib36rQkOw6lnb7Jls3Gd1BBbp5bhk81Q4qkfOFnO7hyXO1bFNdCg6cDVvasj5A/0?wx_fmt=jpeg)\n\t* 加载HTML\n\t* 解析HTML，生成DOM\n\t* 加载CSS，JS\n\t* 解析CSS，生成CSSOM\n\t* JS引擎执行JS\n\t* 合并DOM和CSSOM，生成Render Tree\n\t* 根据Render Tree 进行布局\n\t* 绘制每个层中的元素\n\t* 合并图层\n\n\t\n* 方案：加快完成DOM+CSSOM-Layout-Paint-Composite的整个过程\n   * 分割css\n     对不同的浏览终端，同一终端的不同模式，提供不同的规则（通俗讲屏幕大小和宽高比）把媒体查询放在link上，根据终端情况加载不同的css文件\n     \n     \n   * css规则的优先级  \n     css权重计算的无形增加    \n     **css选择器解析从右往左还是从左往右？？**\n     过多的嵌套规则，会导致复杂的，无必要的深层次规则（SASS，LESS开发过程中尤为明显）  \n     css规则越复杂，构建Render Tree时，浏览器花费的时间越长  \n     \n     \n   * 使用GPU加速\n      很多的动画定时的执行，会导致浏览器的重新布局  \n\t      \n\t\t\t      @keyframes my {\n\t\t\t     20% {\n\t\t\t      top: 10px;\n\t\t\t      }\n\t\t\t  \n\t\t\t  50% {\n\t\t\t      top: 120px;\n\t\t\t  }\n\t\t\t  \n\t\t\t  80% {\n\t\t\t      top: 10px;\n\t\t\t  }\n\t\t\t} \n\t  这些执行可以放到GPU加速执行  \n\t  \n\t\t\t @keyframes my {\n\t\t\t  20% {\n\t\t\t      transform: translateY(10px);\n\t\t\t  }\n\t\t\t \n\t\t\t  50% {\n\t\t\t      transform: translateY(120px);\n\t\t\t  }\n\t\t\t      \n\t\t\t  80% {\n\t\t\t      transform: translateY(10px);\n\t\t\t  }\n\t\t\t}\n\t\t\t\n\t\t\t\n\tjQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 \n\t \n\tjQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。\n    \n\tjQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bu\t\n\t**setTimeOut和FAF（单人淋浴间和大澡堂）**\t\n\t\n\t\n--\n\n\t\tvar startingTop = 0;\n\t\t\t\tsetInterval(function() {\n\t\t\t\t    element.style.top = (startingTop += 1/60);\n\t\t\t\t}, 16);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfunction tick () {\n\t\t\t\t    element.style.top = (startingTop += 1/60);\n\t\t\t\t}\n\t\t\t\twindow.requestAnimationFrame(tick);\n\t\t\t\t\n\t\t\t\t\n--\n  requestAnimationFrame\t\t\n  setTimeout间隔设置过小，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。\t\n  \n  而requestAnimationFrame就是为了这个而出现的。所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧  \n  \n  优势：向下兼容 、相比于css3动画应用更广、动画效果更多\n  \n  CSS transition 的动画逻辑是由浏览器来执行，所以它的性能能够比 jQuery 动画好。它的优势体现在：\n\n通过优化 DOM 操作，避免内存消耗来减少卡顿  \n使用与 RAF 类似的机制  \n强制使用硬件加速 （通过 GPU 来提高动画性能）  \n\t\t\t\n * 异步JavaScript   \n   js执行会阻塞DOM构建的过程，Js中可能存在dom操作 async异步  \n   \n   js可能会不断的重新布局，重新绘制  \n\t     1.访问元素的某些属性  \n\t     2.通过JavaScript修改元素的CSS属性  \n\t     3.在onScroll中做耗时的任务  \n\t     4.在其他Event Handler中做耗时的任务  \n\t     5.图片的预处理  \n\t     6.过多的动画  \n\t     7.过多的数据处理  \n\t     \n   元素的一些属性和方法，当被访问或调用的时候，会触发浏览器的布局和绘制，布局基本上会影响页面的大部分元素，导致耗时长  \n   \n   为了避免之前提到的布局颠簸，我们需要批量访问和更新DOM。\n\n\t\t\tvar currentTop,\n\t\t    currentLeft;\n\t\t/* 有 layout thrashing. */\n\t\tcurrentTop = element.style.top; /* 访问 */\n\t\telement.style.top = currentTop + 1; /* 更新 */\n\t\t\n\t\tcurrentLeft = element.style.left; /* 访问 */\n\t\telement.style.left = currentLeft + 1; /* 更新 */\n\t\t\n\t\t/* 没有 layout thrashing. */\n\t\tcurrentTop = element.style.top; /* 访问 */\n\t\tcurrentLeft = element.style.left; /* 访问 */\n\t\t\n\t\telement.style.top = currentTop + 1; /* 更新 */\n\t\telement.style.left = currentLeft + 1; /* 更新 */\n  计算offset 时，浏览器需要重新计算（重新布局），然后才能返回最新的值 \n   \n\t\t\t       for(var i = 0; i < list.length; i++) {\n\t\t\t  list[i].style.width = parent.offsetWidth + 'px';\n\t\t\t}   \n\t\t\t\n\t\t\t\n\t\t\tvar parentWidth = parent.offsetWidth;\n\t\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\t  list[i].style.width = parentWidth + 'px';\n\t\t\t}\n\t\t\t\n\t\t\t\n   * css样式修改  \n   * 修改布局相关属性，会触发Layout-Paint-Composite\n   * 修改绘制相关属性，会触发Paint-Composite\n   * 其他属性，某些特别属性可在不同层中单独绘制，在合并图层，就是直接Composite  （transform，opacity）\n\n   在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。\n   \n   **类比电梯**\n   \n\t\t   // 防抖动函数\n\t\tfunction debounce(func, wait, immediate) {\n\t\t    var timeout;\n\t\t    return function() {\n\t\t        var context = this, args = arguments;\n\t\t        var later = function() {\n\t\t            timeout = null;\n\t\t            if (!immediate) func.apply(context, args);\n\t\t        };\n\t\t        var callNow = immediate && !timeout;\n\t\t        clearTimeout(timeout);\n\t\t        timeout = setTimeout(later, wait);\n\t\t        if (callNow) func.apply(context, args);\n\t\t    };\n\t\t};\n\t\t \n\t\tvar myEfficientFn = debounce(function() {\n\t\t    // 滚动中的真正的操作\n\t\t}, 250);\n\t\t \n\t\t// 绑定监听\n\t\twindow.addEventListener('resize', myEfficientFn);\n   --\n\t\t\t   // 简单的节流函数\n\t\t\tfunction throttle(func, wait, mustRun) {\n\t\t\t    var timeout,\n\t\t\t        startTime = new Date();\n\t\t\t \n\t\t\t    return function() {\n\t\t\t        var context = this,\n\t\t\t            args = arguments,\n\t\t\t            curTime = new Date();\n\t\t\t \n\t\t\t        clearTimeout(timeout);\n\t\t\t        // 如果达到了规定的触发时间间隔，触发 handler\n\t\t\t        if(curTime - startTime >= mustRun){\n\t\t\t            func.apply(context,args);\n\t\t\t            startTime = curTime;\n\t\t\t        // 没达到触发间隔，重新设定定时器\n\t\t\t        }else{\n\t\t\t            timeout = setTimeout(func, wait);\n\t\t\t        }\n\t\t\t    };\n\t\t};\n\t\t// 实际想绑定在 scroll 事件上的 handler\n\t\tfunction realFunc(){\n\t\t    console.log(\"Success\");\n\t\t}\n\t\t// 采用了节流函数\n\t\twindow.addEventListener('scroll',throttle(realFunc,500,1000));\n\t\t\n\t\t\n\tpointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。\n\t\n\t\nwill-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。  \n\n**类比萨里机长**\n\n值得注意的是，用好这个属性并不是很容易：  \n\n不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。  \n\n不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。  \n\n给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。\n\n**Unable to preventDefault inside passive event listener due to target being treated as passive**\n   \n   window.addEventListener(\"touchstart\", func, {passive: true} );\n   \n   window, document , body\n","slug":"浏览器渲染","published":1,"date":"2018-12-03T15:03:31.878Z","updated":"2018-12-03T15:03:31.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp8g36rk0000ntji9mvtv4cs","content":"<h2 id=\"从浏览器角度谈渲染\"><a href=\"#从浏览器角度谈渲染\" class=\"headerlink\" title=\"从浏览器角度谈渲染\"></a>从浏览器角度谈渲染</h2><ul>\n<li>之前更多的优化是从页面资源的数量，传输是否采用了压缩，JS、cSS，是否进行了精简，缓存有没有合理的使用</li>\n<li>这次从另一个角度谈页面的渲染，浏览器是如何工作的，要把页面渲染出来，浏览器需要做什么，哪些过程比较耗时</li>\n<li>浏览器工作原理<img src=\"http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib1uAwicF98dVY5j2dib36rQkOw6lnb7Jls3Gd1BBbp5bhk81Q4qkfOFnO7hyXO1bFNdCg6cDVvasj5A/0?wx_fmt=jpeg\" alt=\"浏览器工作原理\"><ul>\n<li>加载HTML</li>\n<li>解析HTML，生成DOM</li>\n<li>加载CSS，JS</li>\n<li>解析CSS，生成CSSOM</li>\n<li>JS引擎执行JS</li>\n<li>合并DOM和CSSOM，生成Render Tree</li>\n<li>根据Render Tree 进行布局</li>\n<li>绘制每个层中的元素</li>\n<li>合并图层</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>方案：加快完成DOM+CSSOM-Layout-Paint-Composite的整个过程<ul>\n<li>分割css<br>对不同的浏览终端，同一终端的不同模式，提供不同的规则（通俗讲屏幕大小和宽高比）把媒体查询放在link上，根据终端情况加载不同的css文件</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>css规则的优先级<br>css权重计算的无形增加<br><strong>css选择器解析从右往左还是从左往右？？</strong><br>过多的嵌套规则，会导致复杂的，无必要的深层次规则（SASS，LESS开发过程中尤为明显）<br>css规则越复杂，构建Render Tree时，浏览器花费的时间越长  </li>\n</ul>\n<ul>\n<li><p>使用GPU加速<br> 很多的动画定时的执行，会导致浏览器的重新布局  </p>\n<pre><code>      @keyframes my {\n     20% {\n      top: 10px;\n      }\n\n  50% {\n      top: 120px;\n  }\n\n  80% {\n      top: 10px;\n  }\n} \n</code></pre><p> 这些执行可以放到GPU加速执行  </p>\n<pre><code> @keyframes my {\n  20% {\n      transform: translateY(10px);\n  }\n\n  50% {\n      transform: translateY(120px);\n  }\n\n  80% {\n      transform: translateY(10px);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>jQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 \n\njQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。\n\njQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bu    \n**setTimeOut和FAF（单人淋浴间和大澡堂）**    \n</code></pre><p>–</p>\n<pre><code>var startingTop = 0;\n        setInterval(function() {\n            element.style.top = (startingTop += 1/60);\n        }, 16);\n\n\n        function tick () {\n            element.style.top = (startingTop += 1/60);\n        }\n        window.requestAnimationFrame(tick);\n</code></pre><p>–<br>  requestAnimationFrame<br>  setTimeout间隔设置过小，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。    </p>\n<p>  而requestAnimationFrame就是为了这个而出现的。所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧  </p>\n<p>  优势：向下兼容 、相比于css3动画应用更广、动画效果更多</p>\n<p>  CSS transition 的动画逻辑是由浏览器来执行，所以它的性能能够比 jQuery 动画好。它的优势体现在：</p>\n<p>通过优化 DOM 操作，避免内存消耗来减少卡顿<br>使用与 RAF 类似的机制<br>强制使用硬件加速 （通过 GPU 来提高动画性能）  </p>\n<ul>\n<li><p>异步JavaScript<br>js执行会阻塞DOM构建的过程，Js中可能存在dom操作 async异步  </p>\n<p>js可能会不断的重新布局，重新绘制  </p>\n<pre><code>1.访问元素的某些属性  \n2.通过JavaScript修改元素的CSS属性  \n3.在onScroll中做耗时的任务  \n4.在其他Event Handler中做耗时的任务  \n5.图片的预处理  \n6.过多的动画  \n7.过多的数据处理  \n</code></pre><p>元素的一些属性和方法，当被访问或调用的时候，会触发浏览器的布局和绘制，布局基本上会影响页面的大部分元素，导致耗时长  </p>\n<p>为了避免之前提到的布局颠簸，我们需要批量访问和更新DOM。</p>\n<pre><code>    var currentTop,\n    currentLeft;\n/* 有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */\n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */\n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */\n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */\n</code></pre><p>计算offset 时，浏览器需要重新计算（重新布局），然后才能返回最新的值 </p>\n<pre><code>       for(var i = 0; i &lt; list.length; i++) {\n  list[i].style.width = parent.offsetWidth + &apos;px&apos;;\n}   \n</code></pre></li>\n</ul>\n<pre><code>var parentWidth = parent.offsetWidth;\nfor(var i = 0; i &lt; list.length; i++) {\n  list[i].style.width = parentWidth + &apos;px&apos;;\n}\n</code></pre><ul>\n<li>css样式修改  </li>\n<li>修改布局相关属性，会触发Layout-Paint-Composite</li>\n<li>修改绘制相关属性，会触发Paint-Composite</li>\n<li><p>其他属性，某些特别属性可在不同层中单独绘制，在合并图层，就是直接Composite  （transform，opacity）</p>\n<p>在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。</p>\n<p><strong>类比电梯</strong></p>\n<pre><code>// 防抖动函数\n</code></pre><p>   function debounce(func, wait, immediate) {</p>\n<pre><code>var timeout;\nreturn function() {\n    var context = this, args = arguments;\n    var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate &amp;&amp; !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n};\n</code></pre><p>   };</p>\n<p>   var myEfficientFn = debounce(function() {</p>\n<pre><code>// 滚动中的真正的操作\n</code></pre><p>   }, 250);</p>\n<p>   // 绑定监听</p>\n<h2 id=\"window-addEventListener-‘resize’-myEfficientFn\"><a href=\"#window-addEventListener-‘resize’-myEfficientFn\" class=\"headerlink\" title=\"   window.addEventListener(‘resize’, myEfficientFn);\"></a>   window.addEventListener(‘resize’, myEfficientFn);</h2><pre><code>   // 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime &gt;= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n</code></pre><p>   };<br>   // 实际想绑定在 scroll 事件上的 handler<br>   function realFunc(){</p>\n<pre><code>console.log(&quot;Success&quot;);\n</code></pre><p>   }<br>   // 采用了节流函数<br>   window.addEventListener(‘scroll’,throttle(realFunc,500,1000));</p>\n</li>\n</ul>\n<pre><code>pointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。\n</code></pre><p>will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。  </p>\n<p><strong>类比萨里机长</strong></p>\n<p>值得注意的是，用好这个属性并不是很容易：  </p>\n<p>不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。  </p>\n<p>不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。  </p>\n<p>给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。</p>\n<p><strong>Unable to preventDefault inside passive event listener due to target being treated as passive</strong></p>\n<p>   window.addEventListener(“touchstart”, func, {passive: true} );</p>\n<p>   window, document , body</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"从浏览器角度谈渲染\"><a href=\"#从浏览器角度谈渲染\" class=\"headerlink\" title=\"从浏览器角度谈渲染\"></a>从浏览器角度谈渲染</h2><ul>\n<li>之前更多的优化是从页面资源的数量，传输是否采用了压缩，JS、cSS，是否进行了精简，缓存有没有合理的使用</li>\n<li>这次从另一个角度谈页面的渲染，浏览器是如何工作的，要把页面渲染出来，浏览器需要做什么，哪些过程比较耗时</li>\n<li>浏览器工作原理<img src=\"http://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib1uAwicF98dVY5j2dib36rQkOw6lnb7Jls3Gd1BBbp5bhk81Q4qkfOFnO7hyXO1bFNdCg6cDVvasj5A/0?wx_fmt=jpeg\" alt=\"浏览器工作原理\"><ul>\n<li>加载HTML</li>\n<li>解析HTML，生成DOM</li>\n<li>加载CSS，JS</li>\n<li>解析CSS，生成CSSOM</li>\n<li>JS引擎执行JS</li>\n<li>合并DOM和CSSOM，生成Render Tree</li>\n<li>根据Render Tree 进行布局</li>\n<li>绘制每个层中的元素</li>\n<li>合并图层</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>方案：加快完成DOM+CSSOM-Layout-Paint-Composite的整个过程<ul>\n<li>分割css<br>对不同的浏览终端，同一终端的不同模式，提供不同的规则（通俗讲屏幕大小和宽高比）把媒体查询放在link上，根据终端情况加载不同的css文件</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>css规则的优先级<br>css权重计算的无形增加<br><strong>css选择器解析从右往左还是从左往右？？</strong><br>过多的嵌套规则，会导致复杂的，无必要的深层次规则（SASS，LESS开发过程中尤为明显）<br>css规则越复杂，构建Render Tree时，浏览器花费的时间越长  </li>\n</ul>\n<ul>\n<li><p>使用GPU加速<br> 很多的动画定时的执行，会导致浏览器的重新布局  </p>\n<pre><code>      @keyframes my {\n     20% {\n      top: 10px;\n      }\n\n  50% {\n      top: 120px;\n  }\n\n  80% {\n      top: 10px;\n  }\n} \n</code></pre><p> 这些执行可以放到GPU加速执行  </p>\n<pre><code> @keyframes my {\n  20% {\n      transform: translateY(10px);\n  }\n\n  50% {\n      transform: translateY(120px);\n  }\n\n  80% {\n      transform: translateY(10px);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>jQuery 不能避免 layout thrashing （有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。 \n\njQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易让动画卡住。\n\njQuery使用了setInterval而不是 reqeustAnimationFrame(RAF)，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bu    \n**setTimeOut和FAF（单人淋浴间和大澡堂）**    \n</code></pre><p>–</p>\n<pre><code>var startingTop = 0;\n        setInterval(function() {\n            element.style.top = (startingTop += 1/60);\n        }, 16);\n\n\n        function tick () {\n            element.style.top = (startingTop += 1/60);\n        }\n        window.requestAnimationFrame(tick);\n</code></pre><p>–<br>  requestAnimationFrame<br>  setTimeout间隔设置过小，显示器16.7ms刷新间隔之前发生了其他绘制请求(setTimeout)，导致所有第三帧丢失，继而导致动画断续显示（堵车的感觉），这就是过度绘制带来的问题。不仅如此，这种计时器频率的降低也会对电池使用寿命造成负面影响，并会降低其他应用的性能。    </p>\n<p>  而requestAnimationFrame就是为了这个而出现的。所做的事情很简单，跟着浏览器的绘制走，如果浏览设备绘制间隔是16.7ms，那我就这个间隔绘制；如果浏览设备绘制间隔是10ms, 我就10ms绘制。这样就不会存在过度绘制的问题，动画不会掉帧  </p>\n<p>  优势：向下兼容 、相比于css3动画应用更广、动画效果更多</p>\n<p>  CSS transition 的动画逻辑是由浏览器来执行，所以它的性能能够比 jQuery 动画好。它的优势体现在：</p>\n<p>通过优化 DOM 操作，避免内存消耗来减少卡顿<br>使用与 RAF 类似的机制<br>强制使用硬件加速 （通过 GPU 来提高动画性能）  </p>\n<ul>\n<li><p>异步JavaScript<br>js执行会阻塞DOM构建的过程，Js中可能存在dom操作 async异步  </p>\n<p>js可能会不断的重新布局，重新绘制  </p>\n<pre><code>1.访问元素的某些属性  \n2.通过JavaScript修改元素的CSS属性  \n3.在onScroll中做耗时的任务  \n4.在其他Event Handler中做耗时的任务  \n5.图片的预处理  \n6.过多的动画  \n7.过多的数据处理  \n</code></pre><p>元素的一些属性和方法，当被访问或调用的时候，会触发浏览器的布局和绘制，布局基本上会影响页面的大部分元素，导致耗时长  </p>\n<p>为了避免之前提到的布局颠簸，我们需要批量访问和更新DOM。</p>\n<pre><code>    var currentTop,\n    currentLeft;\n/* 有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */\n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */\n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */\n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */\n</code></pre><p>计算offset 时，浏览器需要重新计算（重新布局），然后才能返回最新的值 </p>\n<pre><code>       for(var i = 0; i &lt; list.length; i++) {\n  list[i].style.width = parent.offsetWidth + &apos;px&apos;;\n}   \n</code></pre></li>\n</ul>\n<pre><code>var parentWidth = parent.offsetWidth;\nfor(var i = 0; i &lt; list.length; i++) {\n  list[i].style.width = parentWidth + &apos;px&apos;;\n}\n</code></pre><ul>\n<li>css样式修改  </li>\n<li>修改布局相关属性，会触发Layout-Paint-Composite</li>\n<li>修改绘制相关属性，会触发Paint-Composite</li>\n<li><p>其他属性，某些特别属性可在不同层中单独绘制，在合并图层，就是直接Composite  （transform，opacity）</p>\n<p>在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。</p>\n<p><strong>类比电梯</strong></p>\n<pre><code>// 防抖动函数\n</code></pre><p>   function debounce(func, wait, immediate) {</p>\n<pre><code>var timeout;\nreturn function() {\n    var context = this, args = arguments;\n    var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate &amp;&amp; !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n};\n</code></pre><p>   };</p>\n<p>   var myEfficientFn = debounce(function() {</p>\n<pre><code>// 滚动中的真正的操作\n</code></pre><p>   }, 250);</p>\n<p>   // 绑定监听</p>\n<h2 id=\"window-addEventListener-‘resize’-myEfficientFn\"><a href=\"#window-addEventListener-‘resize’-myEfficientFn\" class=\"headerlink\" title=\"   window.addEventListener(‘resize’, myEfficientFn);\"></a>   window.addEventListener(‘resize’, myEfficientFn);</h2><pre><code>   // 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime &gt;= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n</code></pre><p>   };<br>   // 实际想绑定在 scroll 事件上的 handler<br>   function realFunc(){</p>\n<pre><code>console.log(&quot;Success&quot;);\n</code></pre><p>   }<br>   // 采用了节流函数<br>   window.addEventListener(‘scroll’,throttle(realFunc,500,1000));</p>\n</li>\n</ul>\n<pre><code>pointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。\n</code></pre><p>will-change 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。  </p>\n<p><strong>类比萨里机长</strong></p>\n<p>值得注意的是，用好这个属性并不是很容易：  </p>\n<p>不要将 will-change 应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 will-change 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。  </p>\n<p>不要过早应用 will-change 优化：如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。 will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。  </p>\n<p>给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 will-change 属性。</p>\n<p><strong>Unable to preventDefault inside passive event listener due to target being treated as passive</strong></p>\n<p>   window.addEventListener(“touchstart”, func, {passive: true} );</p>\n<p>   window, document , body</p>\n"},{"title":"freemark","_content":"\n# FreeMarker\n\n## summary\n  基于模板的，用来生成输出文本的通用工具  \n  适用于MVC模式，分离思想   \n  并非web的应用框架，只是框架中的一个组件，其引擎本身并不知道http协议或者servlet\n\n## freemark 模板\n  * `${...}` interpolations 插值 \n  * `<#> </#>` tags 标签  （`<@> </@>` 自定义标签)\n  * `<#--  -->` comments 注释\n  * `<table></tabel>` directives 指令  \n  \n## 指令\n \n### if指令\n条件  \n`<#if boolean><#else></#if>`\n\n### list指令\n循环  \n`<#list Array as array></#list>`\n\n### include指令\n插入其他文件到当前模板  \n`<#include \"\"/>`\n\n### 处理不存在的变量\n变量不存在时使用default代替  \n\n`${...}!\"default\"`  \n\n使用？？和if指令，变量不存在忽略代码段  \n\n`<#if argument??></if>`\n\n`argument1.argument2.argument3!0`  \n若argument1或argument2不存在，则模板处理会以“未定义变量”错误停止  \n通过`（argument1.argument2.argument3）!0` 方式防止这种错误\n\n### 用户自定义指令\n如果能够实现，用自定义指令而不用函数/方法。  \n输出（返回值）的是标记（HTML,XML 等）。  \n主要原因是函数的返回结果可以自动进行 XML 转义  \n（这是因为${…}的特性），  \n而用户自定义指令的输出则不是  \n（这是\n因为<@...>的特性所致，它的输出假定为是标记，因此就不再转义）。\n\n### 转义\n**特殊字符** 原生字符 `${r\"${foo}\"}`\n\n\n\n","source":"_posts/freemark.md","raw":"---\ntitle:      \"freemark\"\ntags:\n    - freemark 模板\n---\n\n# FreeMarker\n\n## summary\n  基于模板的，用来生成输出文本的通用工具  \n  适用于MVC模式，分离思想   \n  并非web的应用框架，只是框架中的一个组件，其引擎本身并不知道http协议或者servlet\n\n## freemark 模板\n  * `${...}` interpolations 插值 \n  * `<#> </#>` tags 标签  （`<@> </@>` 自定义标签)\n  * `<#--  -->` comments 注释\n  * `<table></tabel>` directives 指令  \n  \n## 指令\n \n### if指令\n条件  \n`<#if boolean><#else></#if>`\n\n### list指令\n循环  \n`<#list Array as array></#list>`\n\n### include指令\n插入其他文件到当前模板  \n`<#include \"\"/>`\n\n### 处理不存在的变量\n变量不存在时使用default代替  \n\n`${...}!\"default\"`  \n\n使用？？和if指令，变量不存在忽略代码段  \n\n`<#if argument??></if>`\n\n`argument1.argument2.argument3!0`  \n若argument1或argument2不存在，则模板处理会以“未定义变量”错误停止  \n通过`（argument1.argument2.argument3）!0` 方式防止这种错误\n\n### 用户自定义指令\n如果能够实现，用自定义指令而不用函数/方法。  \n输出（返回值）的是标记（HTML,XML 等）。  \n主要原因是函数的返回结果可以自动进行 XML 转义  \n（这是因为${…}的特性），  \n而用户自定义指令的输出则不是  \n（这是\n因为<@...>的特性所致，它的输出假定为是标记，因此就不再转义）。\n\n### 转义\n**特殊字符** 原生字符 `${r\"${foo}\"}`\n\n\n\n","slug":"freemark","published":1,"date":"2018-12-04T13:47:12.095Z","updated":"2018-12-04T13:47:12.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9ssssn000050ji7jo2pidl","content":"<h1 id=\"FreeMarker\"><a href=\"#FreeMarker\" class=\"headerlink\" title=\"FreeMarker\"></a>FreeMarker</h1><h2 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h2><p>  基于模板的，用来生成输出文本的通用工具<br>  适用于MVC模式，分离思想<br>  并非web的应用框架，只是框架中的一个组件，其引擎本身并不知道http协议或者servlet</p>\n<h2 id=\"freemark-模板\"><a href=\"#freemark-模板\" class=\"headerlink\" title=\"freemark 模板\"></a>freemark 模板</h2><ul>\n<li><code>${...}</code> interpolations 插值 </li>\n<li><code>&lt;#&gt; &lt;/#&gt;</code> tags 标签  （<code>&lt;@&gt; &lt;/@&gt;</code> 自定义标签)</li>\n<li><code>&lt;#--  --&gt;</code> comments 注释</li>\n<li><code>&lt;table&gt;&lt;/tabel&gt;</code> directives 指令  </li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"if指令\"><a href=\"#if指令\" class=\"headerlink\" title=\"if指令\"></a>if指令</h3><p>条件<br><code>&lt;#if boolean&gt;&lt;#else&gt;&lt;/#if&gt;</code></p>\n<h3 id=\"list指令\"><a href=\"#list指令\" class=\"headerlink\" title=\"list指令\"></a>list指令</h3><p>循环<br><code>&lt;#list Array as array&gt;&lt;/#list&gt;</code></p>\n<h3 id=\"include指令\"><a href=\"#include指令\" class=\"headerlink\" title=\"include指令\"></a>include指令</h3><p>插入其他文件到当前模板<br><code>&lt;#include &quot;&quot;/&gt;</code></p>\n<h3 id=\"处理不存在的变量\"><a href=\"#处理不存在的变量\" class=\"headerlink\" title=\"处理不存在的变量\"></a>处理不存在的变量</h3><p>变量不存在时使用default代替  </p>\n<p><code>${...}!&quot;default&quot;</code>  </p>\n<p>使用？？和if指令，变量不存在忽略代码段  </p>\n<p><code>&lt;#if argument??&gt;&lt;/if&gt;</code></p>\n<p><code>argument1.argument2.argument3!0</code><br>若argument1或argument2不存在，则模板处理会以“未定义变量”错误停止<br>通过<code>（argument1.argument2.argument3）!0</code> 方式防止这种错误</p>\n<h3 id=\"用户自定义指令\"><a href=\"#用户自定义指令\" class=\"headerlink\" title=\"用户自定义指令\"></a>用户自定义指令</h3><p>如果能够实现，用自定义指令而不用函数/方法。<br>输出（返回值）的是标记（HTML,XML 等）。<br>主要原因是函数的返回结果可以自动进行 XML 转义<br>（这是因为${…}的特性），<br>而用户自定义指令的输出则不是<br>（这是<br>因为&lt;@…&gt;的特性所致，它的输出假定为是标记，因此就不再转义）。</p>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><p><strong>特殊字符</strong> 原生字符 <code>${r&quot;${foo}&quot;}</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"FreeMarker\"><a href=\"#FreeMarker\" class=\"headerlink\" title=\"FreeMarker\"></a>FreeMarker</h1><h2 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h2><p>  基于模板的，用来生成输出文本的通用工具<br>  适用于MVC模式，分离思想<br>  并非web的应用框架，只是框架中的一个组件，其引擎本身并不知道http协议或者servlet</p>\n<h2 id=\"freemark-模板\"><a href=\"#freemark-模板\" class=\"headerlink\" title=\"freemark 模板\"></a>freemark 模板</h2><ul>\n<li><code>${...}</code> interpolations 插值 </li>\n<li><code>&lt;#&gt; &lt;/#&gt;</code> tags 标签  （<code>&lt;@&gt; &lt;/@&gt;</code> 自定义标签)</li>\n<li><code>&lt;#--  --&gt;</code> comments 注释</li>\n<li><code>&lt;table&gt;&lt;/tabel&gt;</code> directives 指令  </li>\n</ul>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><h3 id=\"if指令\"><a href=\"#if指令\" class=\"headerlink\" title=\"if指令\"></a>if指令</h3><p>条件<br><code>&lt;#if boolean&gt;&lt;#else&gt;&lt;/#if&gt;</code></p>\n<h3 id=\"list指令\"><a href=\"#list指令\" class=\"headerlink\" title=\"list指令\"></a>list指令</h3><p>循环<br><code>&lt;#list Array as array&gt;&lt;/#list&gt;</code></p>\n<h3 id=\"include指令\"><a href=\"#include指令\" class=\"headerlink\" title=\"include指令\"></a>include指令</h3><p>插入其他文件到当前模板<br><code>&lt;#include &quot;&quot;/&gt;</code></p>\n<h3 id=\"处理不存在的变量\"><a href=\"#处理不存在的变量\" class=\"headerlink\" title=\"处理不存在的变量\"></a>处理不存在的变量</h3><p>变量不存在时使用default代替  </p>\n<p><code>${...}!&quot;default&quot;</code>  </p>\n<p>使用？？和if指令，变量不存在忽略代码段  </p>\n<p><code>&lt;#if argument??&gt;&lt;/if&gt;</code></p>\n<p><code>argument1.argument2.argument3!0</code><br>若argument1或argument2不存在，则模板处理会以“未定义变量”错误停止<br>通过<code>（argument1.argument2.argument3）!0</code> 方式防止这种错误</p>\n<h3 id=\"用户自定义指令\"><a href=\"#用户自定义指令\" class=\"headerlink\" title=\"用户自定义指令\"></a>用户自定义指令</h3><p>如果能够实现，用自定义指令而不用函数/方法。<br>输出（返回值）的是标记（HTML,XML 等）。<br>主要原因是函数的返回结果可以自动进行 XML 转义<br>（这是因为${…}的特性），<br>而用户自定义指令的输出则不是<br>（这是<br>因为&lt;@…&gt;的特性所致，它的输出假定为是标记，因此就不再转义）。</p>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><p><strong>特殊字符</strong> 原生字符 <code>${r&quot;${foo}&quot;}</code></p>\n"},{"title":"css 杂记（持续补充）","_content":"\n## margin\n* **作用**\n  * 让块元素水平居中\n  * 让元素之间留有间距\n  * 处理特殊的first，last\n  * 布局\n* **要点** \n  * margin折叠\n  * margin百分比\n  * margin的auto值\n  * margin和相对偏移的异同\n  * IE6浮动双margin Bug\n  * IE6浮动相邻元素3px Bug  \n  \n### auto\n一般auto计算值取决于可用空间\n\n### 百分比\n默认在writing-mode:horizontal-tb和direction：ltr，百分比参照父级的宽度\n\n### margin折叠\n* 垂直边毗邻  \n  * 元素的上外边距和其属于常流中的第一个孩子的上外边距\n  * 元素的下外边距和其属于常流中的下一个兄弟的上外边距\n  * 属于常流中的最后一个孩子的下外边距和其父亲的下外边距\n  * 元素的上下外边距，如果该元素没有建立新的块级格式上下文，且min-height的计算值为0或auto，且没有属于常流中的孩子\n\n### IE6浮动双倍margin bug\n*  解决方案\n   1. `_margin-left:*/2`\n   2. `_display:inline`  \n   \n## z-index\n* 元素的层叠级别为整型，描述在相同层叠上下文中元素在z轴上的呈现顺序\n* 同一层叠上下文中，层叠级别大的显示在上，相同层叠级别时，遵循后来居上的原则\n* 不同层叠的上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关\n* 当定位元素没有显式定义z-index值时，不会创建新的局部层叠上下文\n* 子元素有可能和祖先的兄弟会长祖先兄弟的子元素处在同一个层叠上下文中\n* 当opacity值小于1时，该元素会创建新的局部层叠上下文，\n* 当opacity值小于1时，该元素拥有层叠级别相当于z-index：0或auto，但不能定义z-index，除非本身是定位元素\n","source":"_posts/css杂记.md","raw":"---\ntitle:      \"css 杂记（持续补充）\"\ntags:\n    - css\n---\n\n## margin\n* **作用**\n  * 让块元素水平居中\n  * 让元素之间留有间距\n  * 处理特殊的first，last\n  * 布局\n* **要点** \n  * margin折叠\n  * margin百分比\n  * margin的auto值\n  * margin和相对偏移的异同\n  * IE6浮动双margin Bug\n  * IE6浮动相邻元素3px Bug  \n  \n### auto\n一般auto计算值取决于可用空间\n\n### 百分比\n默认在writing-mode:horizontal-tb和direction：ltr，百分比参照父级的宽度\n\n### margin折叠\n* 垂直边毗邻  \n  * 元素的上外边距和其属于常流中的第一个孩子的上外边距\n  * 元素的下外边距和其属于常流中的下一个兄弟的上外边距\n  * 属于常流中的最后一个孩子的下外边距和其父亲的下外边距\n  * 元素的上下外边距，如果该元素没有建立新的块级格式上下文，且min-height的计算值为0或auto，且没有属于常流中的孩子\n\n### IE6浮动双倍margin bug\n*  解决方案\n   1. `_margin-left:*/2`\n   2. `_display:inline`  \n   \n## z-index\n* 元素的层叠级别为整型，描述在相同层叠上下文中元素在z轴上的呈现顺序\n* 同一层叠上下文中，层叠级别大的显示在上，相同层叠级别时，遵循后来居上的原则\n* 不同层叠的上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关\n* 当定位元素没有显式定义z-index值时，不会创建新的局部层叠上下文\n* 子元素有可能和祖先的兄弟会长祖先兄弟的子元素处在同一个层叠上下文中\n* 当opacity值小于1时，该元素会创建新的局部层叠上下文，\n* 当opacity值小于1时，该元素拥有层叠级别相当于z-index：0或auto，但不能定义z-index，除非本身是定位元素\n","slug":"css杂记","published":1,"date":"2018-12-05T14:43:52.402Z","updated":"2018-12-05T14:43:52.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpba9hbq0000qkjini862bdy","content":"<h2 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h2><ul>\n<li><strong>作用</strong><ul>\n<li>让块元素水平居中</li>\n<li>让元素之间留有间距</li>\n<li>处理特殊的first，last</li>\n<li>布局</li>\n</ul>\n</li>\n<li><strong>要点</strong> <ul>\n<li>margin折叠</li>\n<li>margin百分比</li>\n<li>margin的auto值</li>\n<li>margin和相对偏移的异同</li>\n<li>IE6浮动双margin Bug</li>\n<li>IE6浮动相邻元素3px Bug  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"auto\"><a href=\"#auto\" class=\"headerlink\" title=\"auto\"></a>auto</h3><p>一般auto计算值取决于可用空间</p>\n<h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h3><p>默认在writing-mode:horizontal-tb和direction：ltr，百分比参照父级的宽度</p>\n<h3 id=\"margin折叠\"><a href=\"#margin折叠\" class=\"headerlink\" title=\"margin折叠\"></a>margin折叠</h3><ul>\n<li>垂直边毗邻  <ul>\n<li>元素的上外边距和其属于常流中的第一个孩子的上外边距</li>\n<li>元素的下外边距和其属于常流中的下一个兄弟的上外边距</li>\n<li>属于常流中的最后一个孩子的下外边距和其父亲的下外边距</li>\n<li>元素的上下外边距，如果该元素没有建立新的块级格式上下文，且min-height的计算值为0或auto，且没有属于常流中的孩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IE6浮动双倍margin-bug\"><a href=\"#IE6浮动双倍margin-bug\" class=\"headerlink\" title=\"IE6浮动双倍margin bug\"></a>IE6浮动双倍margin bug</h3><ul>\n<li>解决方案<ol>\n<li><code>_margin-left:*/2</code></li>\n<li><code>_display:inline</code>  </li>\n</ol>\n</li>\n</ul>\n<h2 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h2><ul>\n<li>元素的层叠级别为整型，描述在相同层叠上下文中元素在z轴上的呈现顺序</li>\n<li>同一层叠上下文中，层叠级别大的显示在上，相同层叠级别时，遵循后来居上的原则</li>\n<li>不同层叠的上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关</li>\n<li>当定位元素没有显式定义z-index值时，不会创建新的局部层叠上下文</li>\n<li>子元素有可能和祖先的兄弟会长祖先兄弟的子元素处在同一个层叠上下文中</li>\n<li>当opacity值小于1时，该元素会创建新的局部层叠上下文，</li>\n<li>当opacity值小于1时，该元素拥有层叠级别相当于z-index：0或auto，但不能定义z-index，除非本身是定位元素</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h2><ul>\n<li><strong>作用</strong><ul>\n<li>让块元素水平居中</li>\n<li>让元素之间留有间距</li>\n<li>处理特殊的first，last</li>\n<li>布局</li>\n</ul>\n</li>\n<li><strong>要点</strong> <ul>\n<li>margin折叠</li>\n<li>margin百分比</li>\n<li>margin的auto值</li>\n<li>margin和相对偏移的异同</li>\n<li>IE6浮动双margin Bug</li>\n<li>IE6浮动相邻元素3px Bug  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"auto\"><a href=\"#auto\" class=\"headerlink\" title=\"auto\"></a>auto</h3><p>一般auto计算值取决于可用空间</p>\n<h3 id=\"百分比\"><a href=\"#百分比\" class=\"headerlink\" title=\"百分比\"></a>百分比</h3><p>默认在writing-mode:horizontal-tb和direction：ltr，百分比参照父级的宽度</p>\n<h3 id=\"margin折叠\"><a href=\"#margin折叠\" class=\"headerlink\" title=\"margin折叠\"></a>margin折叠</h3><ul>\n<li>垂直边毗邻  <ul>\n<li>元素的上外边距和其属于常流中的第一个孩子的上外边距</li>\n<li>元素的下外边距和其属于常流中的下一个兄弟的上外边距</li>\n<li>属于常流中的最后一个孩子的下外边距和其父亲的下外边距</li>\n<li>元素的上下外边距，如果该元素没有建立新的块级格式上下文，且min-height的计算值为0或auto，且没有属于常流中的孩子</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IE6浮动双倍margin-bug\"><a href=\"#IE6浮动双倍margin-bug\" class=\"headerlink\" title=\"IE6浮动双倍margin bug\"></a>IE6浮动双倍margin bug</h3><ul>\n<li>解决方案<ol>\n<li><code>_margin-left:*/2</code></li>\n<li><code>_display:inline</code>  </li>\n</ol>\n</li>\n</ul>\n<h2 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h2><ul>\n<li>元素的层叠级别为整型，描述在相同层叠上下文中元素在z轴上的呈现顺序</li>\n<li>同一层叠上下文中，层叠级别大的显示在上，相同层叠级别时，遵循后来居上的原则</li>\n<li>不同层叠的上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关</li>\n<li>当定位元素没有显式定义z-index值时，不会创建新的局部层叠上下文</li>\n<li>子元素有可能和祖先的兄弟会长祖先兄弟的子元素处在同一个层叠上下文中</li>\n<li>当opacity值小于1时，该元素会创建新的局部层叠上下文，</li>\n<li>当opacity值小于1时，该元素拥有层叠级别相当于z-index：0或auto，但不能定义z-index，除非本身是定位元素</li>\n</ul>\n"},{"title":"javascript & ECMAScript & es","_content":"# JavaScript & ECMAScript & ES2015... & ES6...\n\n## JavaScript\t\nJavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能\n\nJavaScript由三部分组成  \n1. ECMAScript  \n2. DOM  \n3. BOM\n\n## ECMAScript\n一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身\n\n\n**ECMA**  \nEcma国际（Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。\n\nEcma国际是一家和企业密切相连的组织，所以 Ecma国际制定的规范都是由各类企业来做主要的制定和推广\n\n**TC39**  \n在ECMA国际，每个标准都会有一个 TC 来负责，而一个 TC 中可能会有不同的 TG 来负责不同的工作。而负责 ECMA262，也就是我们所说的 ECMAScript 的就是 TC39（以前叫 TC39-TG1）。  \n***TC（Technical Committees）***  \n***TG（Task Groups）***\n\n\n\n要讲清ECMAScript，回顾历史。  \n1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。  \n该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。\n\n**ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现**\n\nECMAScript 作为一门脚本程序设计语言标准，并不只有 javascript 这一种实现，它也有很多的方言实现。比如有下面这些语言：\n\nJavaScript\n\nEjscript\n\nJScript .NET\n\nActionScript\n\nDMDScript\n\nCriScript\n\nInScript\n\n\n\n## ES2015...\n**ES2015**  \n**ECMAScript 2015**  \nECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。  \n\n**ECMAScript 2016**    \n第七版 ECMAScript 修订，只加了Array.prototype.includes、Exponentiation Operator(求冥运算)\n\n**ECMAScript 2017**   \n第八版 ECMAScript 修订  \n新增  \nObject.values/Object.entries  \n字符串填充    padStart()和padEnd()  \nObject.getOwnPropertyDescriptor\n尾随逗号  \n异步函数async  \n共享内存和原子操作  \n\n**ECMAScript 2018**   \n异步迭代  \nPromise.finally()  \nRest/Spread 属性: ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符   \n正则表达式命名捕获组（Regular Expression Named Capture Groups）  \n正则表达式反向断言（lookbehind）\n正则表达式dotAll模式  \n正则表达式 Unicode 转义  \n非转义序列的模板字符串\n\n**ECMAScript Proposals**   \n被考虑加入未来版本 ECMAScript标准的特性与语法提案，他们需要经历五个阶段：\n\nstage| 名称  | 描述\n------ | ---- | -------------\nStage 0 | strawman（稻草人） | 任何人都可以提交pull request到[GitHub - tc39/ecma262: Status, process, and documents for ECMA262](https://github.com/tc39/ecma262)\nStage 1 | Proposal（提议） | TC39制定成员作为 champion，TC39审阅通过，有实现的 Demo 或者 Polyfill初步描写标准的语义语法算法复杂度解决的问题等\nStage 2 | Draft（草案）| 有两个或两个以上的实现（包括babel这类的转译实现）使用正式的语言描述该语法，api等\nStage 3 | Candidate（候选） | 至少2个实现，可以为实验性实现，ECMAScript spec editor 通过审核，TC39 review 通过，文本编写完成\nStage 4 | Finished （完成）| 编写 test 262 测试用例，通过两个实现该特性的内核测试，ECMAScript spec editor 通过审核，开发者表示支持和认可\n\n\n对于有些人来说，前端的更新总是很突兀，很让人迷茫。\n\n但是其实不是的。变化总是一点一点发生的。\n\n[GitHub - tc39/proposals: Tracking ECMAScript Proposals](https://link.zhihu.com/?target=https://github.com/tc39/proposals)\n\n我们可以在 TC39 的 Github 仓库中找到完成了，废弃的，以及正在进行中的提案。\n\n多去关注这些东西，对于很多新事物的到来，我们也就不会有多惊讶了。\n\n**其他ECMA标准**  \n和 ECMAScript 有关的标准有 ECMA262，ECMA290，ECMA327，ECMA357，ECMA402，ECMA404，ECMA414等等。\n\n其中290，327，357等等没有推广开来，被废弃。\n\nECMA 262 是语言规范本身。\n\nECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。\n\nECMA 404 是 JSON 规范。\n\nECMA 414 则规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402和404。\n\n\n\n## ES6...\nES   | ECMAScript\n---- | -------------\n ES6 | ECMAScript 2015\n ES7 | ECMAScript 2016\n ES8 | ECMAScript 2017\n ES9 | ECMAScript 2018\n \n ES1：1997 年 6 月  ——    \n ES2：1998 年 6 月  ——   \n ES3：1999 年 12月  ——     \n ES4： 2007 年 10月  **未通过**  ——   \n ES5： 2009年12月  ——   \n ES5.1  2011年6月  ——\n\n**ES4&ES3.1**  \n在制定ES4的时候，是分成了两个工作组同时工作的。\n\n一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。\n\n一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。\n\nECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新\n\n最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，然后将一部分比较激进的部分放置到 ES.NEXT 中，命名为 Harmony（和谐），留待以后再进行商榷。接下来，ECMAScript  3.1 变成了 ECMAScript 5，而 ES.NEXT 中的那些特性，则有着相当一部分被ECMAScript 6，也就是 ECMAScript 2015 所吸收了。所以说虽然 ECMAScript 4 被废弃了，但是它终究还是通过另一种方式活了下来。\n\n\n\n","source":"_posts/javascript & ECMAScript & es.md","raw":"title:      \"javascript & ECMAScript & es\"\ntags:\n    - javascript\n---\n# JavaScript & ECMAScript & ES2015... & ES6...\n\n## JavaScript\t\nJavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能\n\nJavaScript由三部分组成  \n1. ECMAScript  \n2. DOM  \n3. BOM\n\n## ECMAScript\n一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身\n\n\n**ECMA**  \nEcma国际（Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。\n\nEcma国际是一家和企业密切相连的组织，所以 Ecma国际制定的规范都是由各类企业来做主要的制定和推广\n\n**TC39**  \n在ECMA国际，每个标准都会有一个 TC 来负责，而一个 TC 中可能会有不同的 TG 来负责不同的工作。而负责 ECMA262，也就是我们所说的 ECMAScript 的就是 TC39（以前叫 TC39-TG1）。  \n***TC（Technical Committees）***  \n***TG（Task Groups）***\n\n\n\n要讲清ECMAScript，回顾历史。  \n1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。  \n该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。\n\n**ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现**\n\nECMAScript 作为一门脚本程序设计语言标准，并不只有 javascript 这一种实现，它也有很多的方言实现。比如有下面这些语言：\n\nJavaScript\n\nEjscript\n\nJScript .NET\n\nActionScript\n\nDMDScript\n\nCriScript\n\nInScript\n\n\n\n## ES2015...\n**ES2015**  \n**ECMAScript 2015**  \nECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。  \n\n**ECMAScript 2016**    \n第七版 ECMAScript 修订，只加了Array.prototype.includes、Exponentiation Operator(求冥运算)\n\n**ECMAScript 2017**   \n第八版 ECMAScript 修订  \n新增  \nObject.values/Object.entries  \n字符串填充    padStart()和padEnd()  \nObject.getOwnPropertyDescriptor\n尾随逗号  \n异步函数async  \n共享内存和原子操作  \n\n**ECMAScript 2018**   \n异步迭代  \nPromise.finally()  \nRest/Spread 属性: ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符   \n正则表达式命名捕获组（Regular Expression Named Capture Groups）  \n正则表达式反向断言（lookbehind）\n正则表达式dotAll模式  \n正则表达式 Unicode 转义  \n非转义序列的模板字符串\n\n**ECMAScript Proposals**   \n被考虑加入未来版本 ECMAScript标准的特性与语法提案，他们需要经历五个阶段：\n\nstage| 名称  | 描述\n------ | ---- | -------------\nStage 0 | strawman（稻草人） | 任何人都可以提交pull request到[GitHub - tc39/ecma262: Status, process, and documents for ECMA262](https://github.com/tc39/ecma262)\nStage 1 | Proposal（提议） | TC39制定成员作为 champion，TC39审阅通过，有实现的 Demo 或者 Polyfill初步描写标准的语义语法算法复杂度解决的问题等\nStage 2 | Draft（草案）| 有两个或两个以上的实现（包括babel这类的转译实现）使用正式的语言描述该语法，api等\nStage 3 | Candidate（候选） | 至少2个实现，可以为实验性实现，ECMAScript spec editor 通过审核，TC39 review 通过，文本编写完成\nStage 4 | Finished （完成）| 编写 test 262 测试用例，通过两个实现该特性的内核测试，ECMAScript spec editor 通过审核，开发者表示支持和认可\n\n\n对于有些人来说，前端的更新总是很突兀，很让人迷茫。\n\n但是其实不是的。变化总是一点一点发生的。\n\n[GitHub - tc39/proposals: Tracking ECMAScript Proposals](https://link.zhihu.com/?target=https://github.com/tc39/proposals)\n\n我们可以在 TC39 的 Github 仓库中找到完成了，废弃的，以及正在进行中的提案。\n\n多去关注这些东西，对于很多新事物的到来，我们也就不会有多惊讶了。\n\n**其他ECMA标准**  \n和 ECMAScript 有关的标准有 ECMA262，ECMA290，ECMA327，ECMA357，ECMA402，ECMA404，ECMA414等等。\n\n其中290，327，357等等没有推广开来，被废弃。\n\nECMA 262 是语言规范本身。\n\nECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。\n\nECMA 404 是 JSON 规范。\n\nECMA 414 则规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402和404。\n\n\n\n## ES6...\nES   | ECMAScript\n---- | -------------\n ES6 | ECMAScript 2015\n ES7 | ECMAScript 2016\n ES8 | ECMAScript 2017\n ES9 | ECMAScript 2018\n \n ES1：1997 年 6 月  ——    \n ES2：1998 年 6 月  ——   \n ES3：1999 年 12月  ——     \n ES4： 2007 年 10月  **未通过**  ——   \n ES5： 2009年12月  ——   \n ES5.1  2011年6月  ——\n\n**ES4&ES3.1**  \n在制定ES4的时候，是分成了两个工作组同时工作的。\n\n一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。\n\n一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。\n\nECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新\n\n最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，然后将一部分比较激进的部分放置到 ES.NEXT 中，命名为 Harmony（和谐），留待以后再进行商榷。接下来，ECMAScript  3.1 变成了 ECMAScript 5，而 ES.NEXT 中的那些特性，则有着相当一部分被ECMAScript 6，也就是 ECMAScript 2015 所吸收了。所以说虽然 ECMAScript 4 被废弃了，但是它终究还是通过另一种方式活了下来。\n\n\n\n","slug":"javascript & ECMAScript & es","published":1,"date":"2018-12-09T13:44:41.036Z","updated":"2018-12-09T13:44:41.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpgxwr8w00007gjizq4xa710","content":"<h1 id=\"JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…\"><a href=\"#JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…\" class=\"headerlink\" title=\"JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…\"></a>JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…</h1><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能</p>\n<p>JavaScript由三部分组成  </p>\n<ol>\n<li>ECMAScript  </li>\n<li>DOM  </li>\n<li>BOM</li>\n</ol>\n<h2 id=\"ECMAScript\"><a href=\"#ECMAScript\" class=\"headerlink\" title=\"ECMAScript\"></a>ECMAScript</h2><p>一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身</p>\n<p><strong>ECMA</strong><br>Ecma国际（Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。</p>\n<p>Ecma国际是一家和企业密切相连的组织，所以 Ecma国际制定的规范都是由各类企业来做主要的制定和推广</p>\n<p><strong>TC39</strong><br>在ECMA国际，每个标准都会有一个 TC 来负责，而一个 TC 中可能会有不同的 TG 来负责不同的工作。而负责 ECMA262，也就是我们所说的 ECMAScript 的就是 TC39（以前叫 TC39-TG1）。<br><strong><em>TC（Technical Committees）</em></strong><br><strong><em>TG（Task Groups）</em></strong></p>\n<p>要讲清ECMAScript，回顾历史。<br>1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。<br>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>\n<p><strong>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现</strong></p>\n<p>ECMAScript 作为一门脚本程序设计语言标准，并不只有 javascript 这一种实现，它也有很多的方言实现。比如有下面这些语言：</p>\n<p>JavaScript</p>\n<p>Ejscript</p>\n<p>JScript .NET</p>\n<p>ActionScript</p>\n<p>DMDScript</p>\n<p>CriScript</p>\n<p>InScript</p>\n<h2 id=\"ES2015…\"><a href=\"#ES2015…\" class=\"headerlink\" title=\"ES2015…\"></a>ES2015…</h2><p><strong>ES2015</strong><br><strong>ECMAScript 2015</strong><br>ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。  </p>\n<p><strong>ECMAScript 2016</strong><br>第七版 ECMAScript 修订，只加了Array.prototype.includes、Exponentiation Operator(求冥运算)</p>\n<p><strong>ECMAScript 2017</strong><br>第八版 ECMAScript 修订<br>新增<br>Object.values/Object.entries<br>字符串填充    padStart()和padEnd()<br>Object.getOwnPropertyDescriptor<br>尾随逗号<br>异步函数async<br>共享内存和原子操作  </p>\n<p><strong>ECMAScript 2018</strong><br>异步迭代<br>Promise.finally()<br>Rest/Spread 属性: ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符<br>正则表达式命名捕获组（Regular Expression Named Capture Groups）<br>正则表达式反向断言（lookbehind）<br>正则表达式dotAll模式<br>正则表达式 Unicode 转义<br>非转义序列的模板字符串</p>\n<p><strong>ECMAScript Proposals</strong><br>被考虑加入未来版本 ECMAScript标准的特性与语法提案，他们需要经历五个阶段：</p>\n<table>\n<thead>\n<tr>\n<th>stage</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Stage 0</td>\n<td>strawman（稻草人）</td>\n<td>任何人都可以提交pull request到<a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"noopener\">GitHub - tc39/ecma262: Status, process, and documents for ECMA262</a></td>\n</tr>\n<tr>\n<td>Stage 1</td>\n<td>Proposal（提议）</td>\n<td>TC39制定成员作为 champion，TC39审阅通过，有实现的 Demo 或者 Polyfill初步描写标准的语义语法算法复杂度解决的问题等</td>\n</tr>\n<tr>\n<td>Stage 2</td>\n<td>Draft（草案）</td>\n<td>有两个或两个以上的实现（包括babel这类的转译实现）使用正式的语言描述该语法，api等</td>\n</tr>\n<tr>\n<td>Stage 3</td>\n<td>Candidate（候选）</td>\n<td>至少2个实现，可以为实验性实现，ECMAScript spec editor 通过审核，TC39 review 通过，文本编写完成</td>\n</tr>\n<tr>\n<td>Stage 4</td>\n<td>Finished （完成）</td>\n<td>编写 test 262 测试用例，通过两个实现该特性的内核测试，ECMAScript spec editor 通过审核，开发者表示支持和认可</td>\n</tr>\n</tbody>\n</table>\n<p>对于有些人来说，前端的更新总是很突兀，很让人迷茫。</p>\n<p>但是其实不是的。变化总是一点一点发生的。</p>\n<p><a href=\"https://link.zhihu.com/?target=https://github.com/tc39/proposals\" target=\"_blank\" rel=\"noopener\">GitHub - tc39/proposals: Tracking ECMAScript Proposals</a></p>\n<p>我们可以在 TC39 的 Github 仓库中找到完成了，废弃的，以及正在进行中的提案。</p>\n<p>多去关注这些东西，对于很多新事物的到来，我们也就不会有多惊讶了。</p>\n<p><strong>其他ECMA标准</strong><br>和 ECMAScript 有关的标准有 ECMA262，ECMA290，ECMA327，ECMA357，ECMA402，ECMA404，ECMA414等等。</p>\n<p>其中290，327，357等等没有推广开来，被废弃。</p>\n<p>ECMA 262 是语言规范本身。</p>\n<p>ECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。</p>\n<p>ECMA 404 是 JSON 规范。</p>\n<p>ECMA 414 则规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402和404。</p>\n<h2 id=\"ES6…\"><a href=\"#ES6…\" class=\"headerlink\" title=\"ES6…\"></a>ES6…</h2><table>\n<thead>\n<tr>\n<th>ES</th>\n<th>ECMAScript</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> ES6</td>\n<td>ECMAScript 2015</td>\n</tr>\n<tr>\n<td> ES7</td>\n<td>ECMAScript 2016</td>\n</tr>\n<tr>\n<td> ES8</td>\n<td>ECMAScript 2017</td>\n</tr>\n<tr>\n<td> ES9</td>\n<td>ECMAScript 2018</td>\n</tr>\n</tbody>\n</table>\n<p> ES1：1997 年 6 月  ——  <br> ES2：1998 年 6 月  ——<br> ES3：1999 年 12月  ——  <br> ES4： 2007 年 10月  <strong>未通过</strong>  ——<br> ES5： 2009年12月  ——<br> ES5.1  2011年6月  ——</p>\n<p><strong>ES4&amp;ES3.1</strong><br>在制定ES4的时候，是分成了两个工作组同时工作的。</p>\n<p>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</p>\n<p>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</p>\n<p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新</p>\n<p>最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，然后将一部分比较激进的部分放置到 ES.NEXT 中，命名为 Harmony（和谐），留待以后再进行商榷。接下来，ECMAScript  3.1 变成了 ECMAScript 5，而 ES.NEXT 中的那些特性，则有着相当一部分被ECMAScript 6，也就是 ECMAScript 2015 所吸收了。所以说虽然 ECMAScript 4 被废弃了，但是它终究还是通过另一种方式活了下来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…\"><a href=\"#JavaScript-amp-ECMAScript-amp-ES2015…-amp-ES6…\" class=\"headerlink\" title=\"JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…\"></a>JavaScript &amp; ECMAScript &amp; ES2015… &amp; ES6…</h1><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能</p>\n<p>JavaScript由三部分组成  </p>\n<ol>\n<li>ECMAScript  </li>\n<li>DOM  </li>\n<li>BOM</li>\n</ol>\n<h2 id=\"ECMAScript\"><a href=\"#ECMAScript\" class=\"headerlink\" title=\"ECMAScript\"></a>ECMAScript</h2><p>一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身</p>\n<p><strong>ECMA</strong><br>Ecma国际（Ecma International）是一家国际性会员制度的信息和电信标准组织。1994年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。现名称已不属于首字母缩略字。</p>\n<p>Ecma国际是一家和企业密切相连的组织，所以 Ecma国际制定的规范都是由各类企业来做主要的制定和推广</p>\n<p><strong>TC39</strong><br>在ECMA国际，每个标准都会有一个 TC 来负责，而一个 TC 中可能会有不同的 TG 来负责不同的工作。而负责 ECMA262，也就是我们所说的 ECMAScript 的就是 TC39（以前叫 TC39-TG1）。<br><strong><em>TC（Technical Committees）</em></strong><br><strong><em>TG（Task Groups）</em></strong></p>\n<p>要讲清ECMAScript，回顾历史。<br>1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。<br>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>\n<p><strong>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现</strong></p>\n<p>ECMAScript 作为一门脚本程序设计语言标准，并不只有 javascript 这一种实现，它也有很多的方言实现。比如有下面这些语言：</p>\n<p>JavaScript</p>\n<p>Ejscript</p>\n<p>JScript .NET</p>\n<p>ActionScript</p>\n<p>DMDScript</p>\n<p>CriScript</p>\n<p>InScript</p>\n<h2 id=\"ES2015…\"><a href=\"#ES2015…\" class=\"headerlink\" title=\"ES2015…\"></a>ES2015…</h2><p><strong>ES2015</strong><br><strong>ECMAScript 2015</strong><br>ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。  </p>\n<p><strong>ECMAScript 2016</strong><br>第七版 ECMAScript 修订，只加了Array.prototype.includes、Exponentiation Operator(求冥运算)</p>\n<p><strong>ECMAScript 2017</strong><br>第八版 ECMAScript 修订<br>新增<br>Object.values/Object.entries<br>字符串填充    padStart()和padEnd()<br>Object.getOwnPropertyDescriptor<br>尾随逗号<br>异步函数async<br>共享内存和原子操作  </p>\n<p><strong>ECMAScript 2018</strong><br>异步迭代<br>Promise.finally()<br>Rest/Spread 属性: ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符<br>正则表达式命名捕获组（Regular Expression Named Capture Groups）<br>正则表达式反向断言（lookbehind）<br>正则表达式dotAll模式<br>正则表达式 Unicode 转义<br>非转义序列的模板字符串</p>\n<p><strong>ECMAScript Proposals</strong><br>被考虑加入未来版本 ECMAScript标准的特性与语法提案，他们需要经历五个阶段：</p>\n<table>\n<thead>\n<tr>\n<th>stage</th>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Stage 0</td>\n<td>strawman（稻草人）</td>\n<td>任何人都可以提交pull request到<a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"noopener\">GitHub - tc39/ecma262: Status, process, and documents for ECMA262</a></td>\n</tr>\n<tr>\n<td>Stage 1</td>\n<td>Proposal（提议）</td>\n<td>TC39制定成员作为 champion，TC39审阅通过，有实现的 Demo 或者 Polyfill初步描写标准的语义语法算法复杂度解决的问题等</td>\n</tr>\n<tr>\n<td>Stage 2</td>\n<td>Draft（草案）</td>\n<td>有两个或两个以上的实现（包括babel这类的转译实现）使用正式的语言描述该语法，api等</td>\n</tr>\n<tr>\n<td>Stage 3</td>\n<td>Candidate（候选）</td>\n<td>至少2个实现，可以为实验性实现，ECMAScript spec editor 通过审核，TC39 review 通过，文本编写完成</td>\n</tr>\n<tr>\n<td>Stage 4</td>\n<td>Finished （完成）</td>\n<td>编写 test 262 测试用例，通过两个实现该特性的内核测试，ECMAScript spec editor 通过审核，开发者表示支持和认可</td>\n</tr>\n</tbody>\n</table>\n<p>对于有些人来说，前端的更新总是很突兀，很让人迷茫。</p>\n<p>但是其实不是的。变化总是一点一点发生的。</p>\n<p><a href=\"https://link.zhihu.com/?target=https://github.com/tc39/proposals\" target=\"_blank\" rel=\"noopener\">GitHub - tc39/proposals: Tracking ECMAScript Proposals</a></p>\n<p>我们可以在 TC39 的 Github 仓库中找到完成了，废弃的，以及正在进行中的提案。</p>\n<p>多去关注这些东西，对于很多新事物的到来，我们也就不会有多惊讶了。</p>\n<p><strong>其他ECMA标准</strong><br>和 ECMAScript 有关的标准有 ECMA262，ECMA290，ECMA327，ECMA357，ECMA402，ECMA404，ECMA414等等。</p>\n<p>其中290，327，357等等没有推广开来，被废弃。</p>\n<p>ECMA 262 是语言规范本身。</p>\n<p>ECMA 402 则是制定一些基于 ECMAScript 5 或者之后版本的一些国际化 API 标准。</p>\n<p>ECMA 404 是 JSON 规范。</p>\n<p>ECMA 414 则规定了哪些规范是和 ECMAScript 有关的。目前内部就包含了 262，402和404。</p>\n<h2 id=\"ES6…\"><a href=\"#ES6…\" class=\"headerlink\" title=\"ES6…\"></a>ES6…</h2><table>\n<thead>\n<tr>\n<th>ES</th>\n<th>ECMAScript</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> ES6</td>\n<td>ECMAScript 2015</td>\n</tr>\n<tr>\n<td> ES7</td>\n<td>ECMAScript 2016</td>\n</tr>\n<tr>\n<td> ES8</td>\n<td>ECMAScript 2017</td>\n</tr>\n<tr>\n<td> ES9</td>\n<td>ECMAScript 2018</td>\n</tr>\n</tbody>\n</table>\n<p> ES1：1997 年 6 月  ——  <br> ES2：1998 年 6 月  ——<br> ES3：1999 年 12月  ——  <br> ES4： 2007 年 10月  <strong>未通过</strong>  ——<br> ES5： 2009年12月  ——<br> ES5.1  2011年6月  ——</p>\n<p><strong>ES4&amp;ES3.1</strong><br>在制定ES4的时候，是分成了两个工作组同时工作的。</p>\n<p>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</p>\n<p>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</p>\n<p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新</p>\n<p>最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，然后将一部分比较激进的部分放置到 ES.NEXT 中，命名为 Harmony（和谐），留待以后再进行商榷。接下来，ECMAScript  3.1 变成了 ECMAScript 5，而 ES.NEXT 中的那些特性，则有着相当一部分被ECMAScript 6，也就是 ECMAScript 2015 所吸收了。所以说虽然 ECMAScript 4 被废弃了，但是它终究还是通过另一种方式活了下来。</p>\n"},{"title":"threejs 解读  scene","_content":"# Scene\n## 概念\nscene用来创建场景\n\n## 使用:\n创建一个scene对象：\n```\nScence()\n```\n\n## 属性\n\n### fog\nfog实例，定义场景中的雾状背景。默认是null\n\n### overrideMaterial\n如果不为null,它将使用其材质强制覆盖场景中所有对象。默认为null\n\n### autoUpdate\n如果是ture,则每一帧自动检测矩阵更新.如果false,则需要手动维护矩阵更新。默认为true\n\n### background\n如果不为null，则设置渲染场景时使用的背景，并始终先渲染。 可以设置为**Color**，**Texture**或**CubeTexture**。 默认为null\n\n## 方法\n### toJSON\n以JSON格式返回场景数据\n\n\n\n\n# Fog\n## 概念\n此类包含定义线性雾的参数，即密度随着距离的增加呈线性增长\n\n## 使用\n创建Fog对象：\n```\nFog( color : Integer, near : Float, far : Float )\n```\n\ncolor参数被传递给**Color**来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串\n\n# 属性\n### name\n对象的可选名称（不必是唯一的),默认值为空字符串\n\n### color\n雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色\n\n### near\n开始施雾的最小距离。距离当前相机小于near单位的对象，将不会受到雾的影响。默认为1\n\n### far\n结束施雾的最大距离。距离当前相机大于far单位的对象，将不会受到雾的影响。默认为1000\n\n# 方法\n### clone\n返回具有与此雾有相同的参数的新雾实例\n\n\n### toJSON\n以JSON格式返回线性雾数据\n\n\n# FogExp2\n## 概念\n此类包含定义指数雾的参数，即密度随着距离的增加呈指数增长\n\n## 使用\n创建FogExp2对象：\n```\nFogExp2( color : Integer, density : Float )\n````\n\ncolor参数被传递给**Color**来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串\n\n## 属性\n## name\n对象的可选名称（不必是唯一的),默认值为空字符串\n\n## color\n雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色\n\n## density\n定义雾密度增加的速度，默认0.00025\n\n## 方法\n### clone\n返回具有与此雾有相同的参数的新雾实例\n\n\n### toJSON\n以JSON格式返回线性雾数据\n\n","source":"_posts/threejs 解读  scene.md","raw":"title:      \"threejs 解读  scene\"\ntags:\n    - js threejs\n---\n# Scene\n## 概念\nscene用来创建场景\n\n## 使用:\n创建一个scene对象：\n```\nScence()\n```\n\n## 属性\n\n### fog\nfog实例，定义场景中的雾状背景。默认是null\n\n### overrideMaterial\n如果不为null,它将使用其材质强制覆盖场景中所有对象。默认为null\n\n### autoUpdate\n如果是ture,则每一帧自动检测矩阵更新.如果false,则需要手动维护矩阵更新。默认为true\n\n### background\n如果不为null，则设置渲染场景时使用的背景，并始终先渲染。 可以设置为**Color**，**Texture**或**CubeTexture**。 默认为null\n\n## 方法\n### toJSON\n以JSON格式返回场景数据\n\n\n\n\n# Fog\n## 概念\n此类包含定义线性雾的参数，即密度随着距离的增加呈线性增长\n\n## 使用\n创建Fog对象：\n```\nFog( color : Integer, near : Float, far : Float )\n```\n\ncolor参数被传递给**Color**来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串\n\n# 属性\n### name\n对象的可选名称（不必是唯一的),默认值为空字符串\n\n### color\n雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色\n\n### near\n开始施雾的最小距离。距离当前相机小于near单位的对象，将不会受到雾的影响。默认为1\n\n### far\n结束施雾的最大距离。距离当前相机大于far单位的对象，将不会受到雾的影响。默认为1000\n\n# 方法\n### clone\n返回具有与此雾有相同的参数的新雾实例\n\n\n### toJSON\n以JSON格式返回线性雾数据\n\n\n# FogExp2\n## 概念\n此类包含定义指数雾的参数，即密度随着距离的增加呈指数增长\n\n## 使用\n创建FogExp2对象：\n```\nFogExp2( color : Integer, density : Float )\n````\n\ncolor参数被传递给**Color**来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串\n\n## 属性\n## name\n对象的可选名称（不必是唯一的),默认值为空字符串\n\n## color\n雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色\n\n## density\n定义雾密度增加的速度，默认0.00025\n\n## 方法\n### clone\n返回具有与此雾有相同的参数的新雾实例\n\n\n### toJSON\n以JSON格式返回线性雾数据\n\n","slug":"threejs 解读  scene","published":1,"date":"2018-12-10T14:03:28.637Z","updated":"2018-12-10T14:03:28.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpie0t5i0000rsjinaoc4c3g","content":"<h1 id=\"Scene\"><a href=\"#Scene\" class=\"headerlink\" title=\"Scene\"></a>Scene</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>scene用来创建场景</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用:\"></a>使用:</h2><p>创建一个scene对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scence()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"fog\"><a href=\"#fog\" class=\"headerlink\" title=\"fog\"></a>fog</h3><p>fog实例，定义场景中的雾状背景。默认是null</p>\n<h3 id=\"overrideMaterial\"><a href=\"#overrideMaterial\" class=\"headerlink\" title=\"overrideMaterial\"></a>overrideMaterial</h3><p>如果不为null,它将使用其材质强制覆盖场景中所有对象。默认为null</p>\n<h3 id=\"autoUpdate\"><a href=\"#autoUpdate\" class=\"headerlink\" title=\"autoUpdate\"></a>autoUpdate</h3><p>如果是ture,则每一帧自动检测矩阵更新.如果false,则需要手动维护矩阵更新。默认为true</p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>如果不为null，则设置渲染场景时使用的背景，并始终先渲染。 可以设置为<strong>Color</strong>，<strong>Texture</strong>或<strong>CubeTexture</strong>。 默认为null</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"toJSON\"><a href=\"#toJSON\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回场景数据</p>\n<h1 id=\"Fog\"><a href=\"#Fog\" class=\"headerlink\" title=\"Fog\"></a>Fog</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此类包含定义线性雾的参数，即密度随着距离的增加呈线性增长</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建Fog对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fog( color : Integer, near : Float, far : Float )</span><br></pre></td></tr></table></figure></p>\n<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>\n<h1 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h1><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>\n<h3 id=\"color\"><a href=\"#color\" class=\"headerlink\" title=\"color\"></a>color</h3><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>\n<h3 id=\"near\"><a href=\"#near\" class=\"headerlink\" title=\"near\"></a>near</h3><p>开始施雾的最小距离。距离当前相机小于near单位的对象，将不会受到雾的影响。默认为1</p>\n<h3 id=\"far\"><a href=\"#far\" class=\"headerlink\" title=\"far\"></a>far</h3><p>结束施雾的最大距离。距离当前相机大于far单位的对象，将不会受到雾的影响。默认为1000</p>\n<h1 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>\n<h3 id=\"toJSON-1\"><a href=\"#toJSON-1\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>\n<h1 id=\"FogExp2\"><a href=\"#FogExp2\" class=\"headerlink\" title=\"FogExp2\"></a>FogExp2</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此类包含定义指数雾的参数，即密度随着距离的增加呈指数增长</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建FogExp2对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FogExp2( color : Integer, density : Float )</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h2 id=\"name-1\"><a href=\"#name-1\" class=\"headerlink\" title=\"name\"></a>name</h2><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>\n<h2 id=\"color-1\"><a href=\"#color-1\" class=\"headerlink\" title=\"color\"></a>color</h2><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>\n<h2 id=\"density\"><a href=\"#density\" class=\"headerlink\" title=\"density\"></a>density</h2><p>定义雾密度增加的速度，默认0.00025</p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"clone-1\"><a href=\"#clone-1\" class=\"headerlink\" title=\"clone\"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>\n<h3 id=\"toJSON-2\"><a href=\"#toJSON-2\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Scene\"><a href=\"#Scene\" class=\"headerlink\" title=\"Scene\"></a>Scene</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>scene用来创建场景</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用:\"></a>使用:</h2><p>创建一个scene对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scence()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"fog\"><a href=\"#fog\" class=\"headerlink\" title=\"fog\"></a>fog</h3><p>fog实例，定义场景中的雾状背景。默认是null</p>\n<h3 id=\"overrideMaterial\"><a href=\"#overrideMaterial\" class=\"headerlink\" title=\"overrideMaterial\"></a>overrideMaterial</h3><p>如果不为null,它将使用其材质强制覆盖场景中所有对象。默认为null</p>\n<h3 id=\"autoUpdate\"><a href=\"#autoUpdate\" class=\"headerlink\" title=\"autoUpdate\"></a>autoUpdate</h3><p>如果是ture,则每一帧自动检测矩阵更新.如果false,则需要手动维护矩阵更新。默认为true</p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>如果不为null，则设置渲染场景时使用的背景，并始终先渲染。 可以设置为<strong>Color</strong>，<strong>Texture</strong>或<strong>CubeTexture</strong>。 默认为null</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"toJSON\"><a href=\"#toJSON\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回场景数据</p>\n<h1 id=\"Fog\"><a href=\"#Fog\" class=\"headerlink\" title=\"Fog\"></a>Fog</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此类包含定义线性雾的参数，即密度随着距离的增加呈线性增长</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建Fog对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fog( color : Integer, near : Float, far : Float )</span><br></pre></td></tr></table></figure></p>\n<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>\n<h1 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h1><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>\n<h3 id=\"color\"><a href=\"#color\" class=\"headerlink\" title=\"color\"></a>color</h3><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>\n<h3 id=\"near\"><a href=\"#near\" class=\"headerlink\" title=\"near\"></a>near</h3><p>开始施雾的最小距离。距离当前相机小于near单位的对象，将不会受到雾的影响。默认为1</p>\n<h3 id=\"far\"><a href=\"#far\" class=\"headerlink\" title=\"far\"></a>far</h3><p>结束施雾的最大距离。距离当前相机大于far单位的对象，将不会受到雾的影响。默认为1000</p>\n<h1 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>\n<h3 id=\"toJSON-1\"><a href=\"#toJSON-1\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>\n<h1 id=\"FogExp2\"><a href=\"#FogExp2\" class=\"headerlink\" title=\"FogExp2\"></a>FogExp2</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此类包含定义指数雾的参数，即密度随着距离的增加呈指数增长</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建FogExp2对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FogExp2( color : Integer, density : Float )</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>color参数被传递给<strong>Color</strong>来设置颜色属性，color可以是一个十六进制整数或CSS样式的字符串</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h2 id=\"name-1\"><a href=\"#name-1\" class=\"headerlink\" title=\"name\"></a>name</h2><p>对象的可选名称（不必是唯一的),默认值为空字符串</p>\n<h2 id=\"color-1\"><a href=\"#color-1\" class=\"headerlink\" title=\"color\"></a>color</h2><p>雾的颜色，例如：如果设置为黑色，远处的物体将被渲染为黑色</p>\n<h2 id=\"density\"><a href=\"#density\" class=\"headerlink\" title=\"density\"></a>density</h2><p>定义雾密度增加的速度，默认0.00025</p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"clone-1\"><a href=\"#clone-1\" class=\"headerlink\" title=\"clone\"></a>clone</h3><p>返回具有与此雾有相同的参数的新雾实例</p>\n<h3 id=\"toJSON-2\"><a href=\"#toJSON-2\" class=\"headerlink\" title=\"toJSON\"></a>toJSON</h3><p>以JSON格式返回线性雾数据</p>\n"},{"title":"threejs解读 webGLRender","_content":"\n# WebGLRender\n## 概念\n使用WebGL渲染场景\n\n## 使用\n```\nWebGLRenderer( parameters : Object )\n```\n\n* **canvas** - 绘制输出的canvas。这对应于下面的domElement属性。如果没有传值，则将创建新的canvas元素。\n\n* **context** - 可用于将渲染器添加到现有的RenderingContext。默认值为null\n* **precision** - 着色器精度。可以是“highp”，“mediump”或“lowp”。如果设备支持，则默认为“highp”\n*  **alpha** 画布是否包含alpha（透明度）缓冲区。默认值为false\n*  **premultipliedAlpha** 渲染器是否会假设颜色具有预乘alpha。默认为true\n*  **antialias** 是否执行抗锯齿,默认值为false\n*  **stencil** 绘图缓冲区是否具有至少8位的模板缓冲区。默认为true\n*  **preserveDrawingBuffer** 在手动清除或覆盖之前是否保留缓冲区。默认值为false\n*  **powerPreference** 向用户代理提供一个提示，指示适用于此WebGL上下文的GPU配置。可以是“high-performance”，“low-power”或“default”。默认为“default”\n* **depth** 绘图缓冲区是否具有至少16位的深度缓冲区。 默认为true\n* **logarithmicDepthBuffer** 是否使用对数深度缓冲区。 如果在单个场景中处理规模的巨大差异，则可能需要使用它。 默认值为false\n\n## 属性\n### autoClear: Boolean\n定义渲染器是否应在渲染帧之前自动清除其输出\n\n### autoClearColor: Boolean\n如果**autoClear**为true，则定义渲染器是否应清除颜色缓冲区, 默认为true\n\n### autoClearDepth: Boolean\n如果**autoClear**为true，则定义渲染器是否应清除深度缓冲区, 默认为true\n\n### autoClearStencil: Boolean\n如果autoClear为true，则定义渲染器是否应清除模板缓冲区, 默认为true\n\n### capabilities: Object\n包含当前RenderingContext功能详细信息d的对象  \n// TODO 对象属性待补充  \n\n### clippingPlanes : Array\n用户定义的在世界坐标系的裁剪平面对象。这些平面全局可用。空间中的点和该平面的点积为负将被裁剪掉。默认为 [].\n\n### context : WebGLRenderingContext\n渲染器默认通过HTMLCanvasElement.getContext（）方法其domElement获取RenderingContext上下文。  \n您可以手动创建它，但它必须与domElement对应才能渲染到屏幕\n\n### domElement：DOMElement\ncanvas元素。\n这是由构造函数中的渲染器自动创建的（如果调用WebGLRenderer没有传入canvas）; 你只需将它添加到你的页面就像这样：\n```\ndocument.body.appendChild（renderer.domElement）;\n```\n\n### extensions : Object\n**extensions.get**方法的封装，用于检查是否支持各种WebGL扩展。\n\n### gammaFactor: Float\n 默认是\n \n### gammaInput：Boolean\n如果设置，则所有纹理和颜色都是预乘伽马因子值。 默认值为false\n\n### gammaOutput：Boolean\n如果设置，则所有纹理和颜色需要以预乘伽马输出。 默认值为false\n\n### info: Object\n一个关于显卡内存和渲染过程统计信息的对象。便于调试和分析。该对象包含如下字段\n\n* memory:\n * geometries\n * textures\n* render:\n * calls\n * vertices\n * faces\n * points\n* programs\n\n\n默认情况下，这些数据会在每次渲染调用时重置，但在使用一个或多个镜像时，最好使用自定义模式重置它们：\n\n\trenderer.info.autoReset = false;\n\trenderer.info.reset();\n\t\n\t\n### localClippingEnabled : Boolean\n定义渲染器是否遵循对象级剪切平面。 默认值为false\n\n### maxMorphTargets : Integer\n着色器中允许的最大变形目标数。标准材料仅允许8个变形目标。默认值为8\n\n### maxMorphNormals : Integer\n着色器中允许的最大变形法线数。标准材料仅允许4个变形法线。默认值为4\n\n### physicallyCorrectLights : Boolean\n是否使用物理上正确的照明模式。 默认值为false\n\n### properties : Object\n由渲染器在内部使用，以跟踪各种子对象属性\n\n### renderLists : WebGLRenderLists\n在内部用于处理场景对象渲染的排序\n\nshadowMap : WebGLShadowMap\n如果使用，它包含阴影贴图的引用\n\n### shadowMap.enabled : Boolean\n如果为true,在场景中使用阴影贴图。 默认值为false\n\n### shadowMap.autoUpdate : Boolean\n启用场景中阴影的自动更新。 默认为true  \n如果不需要动态光照/阴影，则可以在实例化渲染器时将其设置为false\n\n### shadowMap.needsUpdate : Boolean\n设置为true时，场景中的阴影贴图将在下一个渲染调用中更新,默认值为false\n如果禁用了阴影贴图的自动更新\n```shadowMap.autoUpdate = false\n```\n则需要将其设置为true，然后进行渲染调用以更新场景中的阴影\n\n### shadowMap.type : Integer\n定义阴影贴图类型  \n选项有**THREE.BasicShadowMap**，**THREE.PCFShadowMap**（默认），**THREE.PCFSoftShadowMap**\n\n### sortObjects : Boolean\n定义渲染器是否应对对象进行排序。 默认为true  \n注意：排序用于尝试正确渲染具有一定透明度的对象。 根据定义，排序对象可能无法在所有情况下使用。 根据应用的需要，可能需要关闭排序并使用其他方法来处理透明度渲染，例如， 手动确定每个对象的渲染顺序\n\n### state : Object\n包含用于设置WebGLRenderer.context状态的各种属性的函数\n\n### toneMapping: Constant\n默认为**LinearToneMapping**\n\n### toneMappingExposur： Number\n色调映射的曝光级别。 默认值为1\n\n### toneMappingWhitePoint : Number\n色调映射白点。 默认值为1\n\n## 方法\n### allocTextureUnit : Integer\n尝试分配纹理单元以供着色器使用。 如果尝试分配比GPU支持更多的纹理单元，则会发出警告。 这主要用于内部\n\n### clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : null\n\n告诉渲染器清除其颜色，深度或模板绘制缓冲区。 此方法将颜色缓冲区初始化为当前的清除色。\n参数默认为true\n\n### clearColor ( ) : null\n清除颜色缓冲区。 相当于调用```clear（true，false，false）```\n\n### clearDepth(): null\n清除深度缓冲区。相当于调用```clear（false，true，false）```\n\n### clearStencil ( ) : null\n清除模板缓冲区。相当于调用```clear（false，false，true）```\n\n### compile ( scene : Scene, camera : Camera ) : null\n使用相机编译场景中的所有材质。 这对于在第一次渲染之前预编译着色器很有用\n\n### copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null\n将当前WebGLFramebuffer中的像素复制到2D纹理中\n\n### copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null\n将纹理的所有像素复制到从给定位置开始的现有纹理\n\n### dispose(): null\n处理当前渲染上下文\n\n### extensions.get ( extensionName : String ) : Object\n用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息（如果可用）。 此方法可以检查以下扩展名：\n\n\t\t- WEBGL_depth_texture\n\t\t- EXT_texture_filter_anisotropic\n\t\t- WEBGL_compressed_texture_s3tc\n\t\t- WEBGL_compressed_texture_pvrtc\n\t\t- WEBGL_compressed_texture_etc1\n\n### forceContextLoss ( ) : null\n模拟WebGL上下文的丢失。 这需要支持WEBGL_lose_context扩展\n\n### getClearAlpha () : Float\n返回具有当前clear alpha的float。 范围从0到1\n\n### getClearColor () : Color\n返回具有当前清除色的THREE.Color实例\n\n### getContext () : WebGLRenderingContext\n返回当前WebGL上下文\n\n### getContextAttributes () : WebGLContextAttributes\n返回描述在创建WebGL上下文时设置的属性的对象\n\n### getRenderTarget () : RenderTarget\n返回当前的RenderTarget（如果有）\n\n### getCurrentViewport () : RenderTarget\n返回当前视口\n\n### getDrawingBufferSize () : Object\n返回包含渲染器绘图缓冲区宽度和高度的对象，单位px\n\n### getPixelRatio () : number\n返回当前设备像素比率\n\n### getSize () : Object\n返回包含渲染器输出画布的宽度和高度的对象（单位px)\n\n### resetGLState ( ) : null\n将GL状态重置为默认值。 如果WebGL上下文丢失，则在内部调用\n\n### readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null\n\n将renderTarget中的像素数据读入的缓冲区。这是WebGLRenderingContext.readPixels（）的封装函数\n\n### render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null\n\n使用相机渲染场景   \n渲染到r**enderTarget**或canvas\n如果**forceClear**为true，则即使**autoClear**属性为false，也会在渲染之前清除深度，模板和颜色缓冲区  \n即使将**forceClear**设置为true，也可以通过将**autoClearColor**，**autoClearStencil**或**autoClearDepth**属性设置为false来阻止清除某些缓冲区\n\n\n### renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null\n使用相机和指定材质渲染缓冲几何集合\n\n### renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null\nobject - Object3D实例   \nprogram - shaderProgram实例   \n着色 -  Material实例   \n\n渲染立即缓冲区。 由renderImmediateObject调用\n\n### setAnimationLoop ( callback : Function ) : null\ncallback - 将在每个可用帧中调用该函数。 如果传递`null`，它将停止任何已经在进行的动画   \n\n可以用来代替requestAnimationFrame的内置函数。 对于WebVR项目，必须使用此功能\n\n\n### setClearAlpha ( alpha : Float ) : null\n设置清除的alpha。 有效输入是介于0.0和1.0之间的浮点数\n\n### setClearColor ( color : Color, alpha : Float ) : null\n设置清除色和不透明度\n\n### setPixelRatio ( value : number ) : null\n设置设备像素比率。 这通常用于HiDPI设备，以防止画面模糊。\n\n### setRenderTarget ( renderTarget : WebGLRenderTarget ) : null\nrenderTarget - 需要激活的renderTarget（可选）\n\n此方法设置活动的rendertarget。 如果省略该参数，则将画布设置为活动的rendertarget\n\n### setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\n将裁剪区域设置为（x，y）到（x + width，y + height）\n\n### setScissorTest ( boolean : Boolean ) : null\n启用或禁用裁剪测试。 启用此选项后，只有定义的裁剪区域内的像素才会受到其他渲染器操作的影响\n\n### setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null\n\n将输出画布的大小调整为（width，height），并考虑设备像素比率，将视口调整为从（0,0）开始适应该尺寸的大小。 将updateStyle设置为false可防止对输出画布进行任何样式更改\n\n### setTexture2D ( texture : Texture, slot : number ) : null\ntexture - 需要设置的纹理  \nslot - 指示纹理应使用哪个槽的数字  \n\n此方法将正确的纹理设置为WebGL着色器的正确插槽。 可以找到槽号作为采样器的均匀值\n\n### setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null\n\ntexture - 需要设置的cubeTexture。\nslot - 指示纹理应使用哪个槽的数字。\n\n此方法将正确的纹理设置为WebGL着色器的正确插槽， 可以找到槽号作为采样器的均匀值\n\nsetViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\n将视口设置为从（x，y）到（x + width，y + height）\n\n\n# WebGLRenderTarget\n## 概念\n显卡为后台渲染场景的缓冲区，它用于不同的效果，例如在渲染图像显示在屏幕进行后期处理\n\n## 使用\n```\nWebGLRenderTarget(width : Number, height : Number, options : Object)\n```\nwidth -- renderTarget的宽度      \nheight -- renderTarget的高度   \noptions是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值  \nwrapS - 默认为ClampToEdgeWrapping  \nwrapT - 默认为ClampToEdgeWrapping  \nmagFilter - 默认为LinearFilter  \nminFilter - 默认为LinearFilter  \nformat - 默认为RGBAFormat  \ntype - 默认为UnsignedByteType  \nanisotropy - 默认值为1  \nencoding - 默认为LinearEncoding  \ndepthBuffer - 默认为true。 如果您不需要，请将此设置为false  \nstencilBuffer - 默认为true。 如果您不需要，请将此设置为false  \n\n\n## 属性\n\n### width : number\n渲染目标的宽度\n\n### height : number\n渲染目标的高度\n\n### scissor : Vector4\n渲染目标视口内的矩形区域。 区域外的部分将被裁剪\n\n### scissorTest : boolean\n是否激活裁剪测试\n\n### viewport : Vector4\n渲染目标的视口\n\n### texture\n此纹理实例保存渲染的像素,将其用作输入以进行进一步处理\n\n### depthBuffer : boolean\n渲染到深度缓冲区。 默认为true\n\n### stencilBuffer\n渲染到深度缓冲区。 默认为true\n\n### depthTexture : DepthTexture\n如果设置，则场景深度将呈现给此纹理。 默认值为null\n\n## 方法\n### setSize ( width : Number, height : Number ) : null\n设置渲染目标的尺寸\n\n### clone () : WebGLRenderTarget\n创建渲染目标的克隆\n\n### copy ( source : WebGLRenderTarget ) : WebGLRenderTarget\n采用source中渲染目标的设置到该渲染目标\n\n### dispose () : null\n调用dispose事件\n\n# WebGLRenderTargetCube\n## 概念\n使用立方体相机(CubeCamera)对象来作为WebGL渲染器目标(WebGLRenderTarget)\n\n## 使用\n```\nWebGLRenderTargetCube(width : Number, height : Number, options : Object)\n```\nwidth -- renderTarget的宽度    \nheight -- renderTarget的高度  \noptions是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值  \nwrapS - 默认为ClampToEdgeWrapping  \nwrapT - 默认为ClampToEdgeWrapping  \nmagFilter - 默认为LinearFilter  \nminFilter - 默认为LinearFilter  \nformat - 默认为RGBAFormat  \ntype - 默认为UnsignedByteType  \nanisotropy - 默认值为1  \nencoding - 默认为LinearEncoding  \ndepthBuffer - 默认为true。 如果您不需要，请将此设置为false  \nstencilBuffer - 默认为true。 如果您不需要，请将此设置为false  \n## 属性\n### activeCubeFace : integer\n对应于立方体侧（PX 0，NX 1，PY 2，NY 3，PZ 4，NZ 5），由CubeCamera内部使用和设置\n### 继承\n继承自**WebGLRenderTarget**\n## 方法\n继承自**WebGLRenderTarget**\n\n\n\n","source":"_posts/threejs解读 webGLRender.md","raw":"title:      \"threejs解读 webGLRender\"\ntags:\n    - js threejs\n---\n\n# WebGLRender\n## 概念\n使用WebGL渲染场景\n\n## 使用\n```\nWebGLRenderer( parameters : Object )\n```\n\n* **canvas** - 绘制输出的canvas。这对应于下面的domElement属性。如果没有传值，则将创建新的canvas元素。\n\n* **context** - 可用于将渲染器添加到现有的RenderingContext。默认值为null\n* **precision** - 着色器精度。可以是“highp”，“mediump”或“lowp”。如果设备支持，则默认为“highp”\n*  **alpha** 画布是否包含alpha（透明度）缓冲区。默认值为false\n*  **premultipliedAlpha** 渲染器是否会假设颜色具有预乘alpha。默认为true\n*  **antialias** 是否执行抗锯齿,默认值为false\n*  **stencil** 绘图缓冲区是否具有至少8位的模板缓冲区。默认为true\n*  **preserveDrawingBuffer** 在手动清除或覆盖之前是否保留缓冲区。默认值为false\n*  **powerPreference** 向用户代理提供一个提示，指示适用于此WebGL上下文的GPU配置。可以是“high-performance”，“low-power”或“default”。默认为“default”\n* **depth** 绘图缓冲区是否具有至少16位的深度缓冲区。 默认为true\n* **logarithmicDepthBuffer** 是否使用对数深度缓冲区。 如果在单个场景中处理规模的巨大差异，则可能需要使用它。 默认值为false\n\n## 属性\n### autoClear: Boolean\n定义渲染器是否应在渲染帧之前自动清除其输出\n\n### autoClearColor: Boolean\n如果**autoClear**为true，则定义渲染器是否应清除颜色缓冲区, 默认为true\n\n### autoClearDepth: Boolean\n如果**autoClear**为true，则定义渲染器是否应清除深度缓冲区, 默认为true\n\n### autoClearStencil: Boolean\n如果autoClear为true，则定义渲染器是否应清除模板缓冲区, 默认为true\n\n### capabilities: Object\n包含当前RenderingContext功能详细信息d的对象  \n// TODO 对象属性待补充  \n\n### clippingPlanes : Array\n用户定义的在世界坐标系的裁剪平面对象。这些平面全局可用。空间中的点和该平面的点积为负将被裁剪掉。默认为 [].\n\n### context : WebGLRenderingContext\n渲染器默认通过HTMLCanvasElement.getContext（）方法其domElement获取RenderingContext上下文。  \n您可以手动创建它，但它必须与domElement对应才能渲染到屏幕\n\n### domElement：DOMElement\ncanvas元素。\n这是由构造函数中的渲染器自动创建的（如果调用WebGLRenderer没有传入canvas）; 你只需将它添加到你的页面就像这样：\n```\ndocument.body.appendChild（renderer.domElement）;\n```\n\n### extensions : Object\n**extensions.get**方法的封装，用于检查是否支持各种WebGL扩展。\n\n### gammaFactor: Float\n 默认是\n \n### gammaInput：Boolean\n如果设置，则所有纹理和颜色都是预乘伽马因子值。 默认值为false\n\n### gammaOutput：Boolean\n如果设置，则所有纹理和颜色需要以预乘伽马输出。 默认值为false\n\n### info: Object\n一个关于显卡内存和渲染过程统计信息的对象。便于调试和分析。该对象包含如下字段\n\n* memory:\n * geometries\n * textures\n* render:\n * calls\n * vertices\n * faces\n * points\n* programs\n\n\n默认情况下，这些数据会在每次渲染调用时重置，但在使用一个或多个镜像时，最好使用自定义模式重置它们：\n\n\trenderer.info.autoReset = false;\n\trenderer.info.reset();\n\t\n\t\n### localClippingEnabled : Boolean\n定义渲染器是否遵循对象级剪切平面。 默认值为false\n\n### maxMorphTargets : Integer\n着色器中允许的最大变形目标数。标准材料仅允许8个变形目标。默认值为8\n\n### maxMorphNormals : Integer\n着色器中允许的最大变形法线数。标准材料仅允许4个变形法线。默认值为4\n\n### physicallyCorrectLights : Boolean\n是否使用物理上正确的照明模式。 默认值为false\n\n### properties : Object\n由渲染器在内部使用，以跟踪各种子对象属性\n\n### renderLists : WebGLRenderLists\n在内部用于处理场景对象渲染的排序\n\nshadowMap : WebGLShadowMap\n如果使用，它包含阴影贴图的引用\n\n### shadowMap.enabled : Boolean\n如果为true,在场景中使用阴影贴图。 默认值为false\n\n### shadowMap.autoUpdate : Boolean\n启用场景中阴影的自动更新。 默认为true  \n如果不需要动态光照/阴影，则可以在实例化渲染器时将其设置为false\n\n### shadowMap.needsUpdate : Boolean\n设置为true时，场景中的阴影贴图将在下一个渲染调用中更新,默认值为false\n如果禁用了阴影贴图的自动更新\n```shadowMap.autoUpdate = false\n```\n则需要将其设置为true，然后进行渲染调用以更新场景中的阴影\n\n### shadowMap.type : Integer\n定义阴影贴图类型  \n选项有**THREE.BasicShadowMap**，**THREE.PCFShadowMap**（默认），**THREE.PCFSoftShadowMap**\n\n### sortObjects : Boolean\n定义渲染器是否应对对象进行排序。 默认为true  \n注意：排序用于尝试正确渲染具有一定透明度的对象。 根据定义，排序对象可能无法在所有情况下使用。 根据应用的需要，可能需要关闭排序并使用其他方法来处理透明度渲染，例如， 手动确定每个对象的渲染顺序\n\n### state : Object\n包含用于设置WebGLRenderer.context状态的各种属性的函数\n\n### toneMapping: Constant\n默认为**LinearToneMapping**\n\n### toneMappingExposur： Number\n色调映射的曝光级别。 默认值为1\n\n### toneMappingWhitePoint : Number\n色调映射白点。 默认值为1\n\n## 方法\n### allocTextureUnit : Integer\n尝试分配纹理单元以供着色器使用。 如果尝试分配比GPU支持更多的纹理单元，则会发出警告。 这主要用于内部\n\n### clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : null\n\n告诉渲染器清除其颜色，深度或模板绘制缓冲区。 此方法将颜色缓冲区初始化为当前的清除色。\n参数默认为true\n\n### clearColor ( ) : null\n清除颜色缓冲区。 相当于调用```clear（true，false，false）```\n\n### clearDepth(): null\n清除深度缓冲区。相当于调用```clear（false，true，false）```\n\n### clearStencil ( ) : null\n清除模板缓冲区。相当于调用```clear（false，false，true）```\n\n### compile ( scene : Scene, camera : Camera ) : null\n使用相机编译场景中的所有材质。 这对于在第一次渲染之前预编译着色器很有用\n\n### copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null\n将当前WebGLFramebuffer中的像素复制到2D纹理中\n\n### copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null\n将纹理的所有像素复制到从给定位置开始的现有纹理\n\n### dispose(): null\n处理当前渲染上下文\n\n### extensions.get ( extensionName : String ) : Object\n用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息（如果可用）。 此方法可以检查以下扩展名：\n\n\t\t- WEBGL_depth_texture\n\t\t- EXT_texture_filter_anisotropic\n\t\t- WEBGL_compressed_texture_s3tc\n\t\t- WEBGL_compressed_texture_pvrtc\n\t\t- WEBGL_compressed_texture_etc1\n\n### forceContextLoss ( ) : null\n模拟WebGL上下文的丢失。 这需要支持WEBGL_lose_context扩展\n\n### getClearAlpha () : Float\n返回具有当前clear alpha的float。 范围从0到1\n\n### getClearColor () : Color\n返回具有当前清除色的THREE.Color实例\n\n### getContext () : WebGLRenderingContext\n返回当前WebGL上下文\n\n### getContextAttributes () : WebGLContextAttributes\n返回描述在创建WebGL上下文时设置的属性的对象\n\n### getRenderTarget () : RenderTarget\n返回当前的RenderTarget（如果有）\n\n### getCurrentViewport () : RenderTarget\n返回当前视口\n\n### getDrawingBufferSize () : Object\n返回包含渲染器绘图缓冲区宽度和高度的对象，单位px\n\n### getPixelRatio () : number\n返回当前设备像素比率\n\n### getSize () : Object\n返回包含渲染器输出画布的宽度和高度的对象（单位px)\n\n### resetGLState ( ) : null\n将GL状态重置为默认值。 如果WebGL上下文丢失，则在内部调用\n\n### readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null\n\n将renderTarget中的像素数据读入的缓冲区。这是WebGLRenderingContext.readPixels（）的封装函数\n\n### render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null\n\n使用相机渲染场景   \n渲染到r**enderTarget**或canvas\n如果**forceClear**为true，则即使**autoClear**属性为false，也会在渲染之前清除深度，模板和颜色缓冲区  \n即使将**forceClear**设置为true，也可以通过将**autoClearColor**，**autoClearStencil**或**autoClearDepth**属性设置为false来阻止清除某些缓冲区\n\n\n### renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null\n使用相机和指定材质渲染缓冲几何集合\n\n### renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null\nobject - Object3D实例   \nprogram - shaderProgram实例   \n着色 -  Material实例   \n\n渲染立即缓冲区。 由renderImmediateObject调用\n\n### setAnimationLoop ( callback : Function ) : null\ncallback - 将在每个可用帧中调用该函数。 如果传递`null`，它将停止任何已经在进行的动画   \n\n可以用来代替requestAnimationFrame的内置函数。 对于WebVR项目，必须使用此功能\n\n\n### setClearAlpha ( alpha : Float ) : null\n设置清除的alpha。 有效输入是介于0.0和1.0之间的浮点数\n\n### setClearColor ( color : Color, alpha : Float ) : null\n设置清除色和不透明度\n\n### setPixelRatio ( value : number ) : null\n设置设备像素比率。 这通常用于HiDPI设备，以防止画面模糊。\n\n### setRenderTarget ( renderTarget : WebGLRenderTarget ) : null\nrenderTarget - 需要激活的renderTarget（可选）\n\n此方法设置活动的rendertarget。 如果省略该参数，则将画布设置为活动的rendertarget\n\n### setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\n将裁剪区域设置为（x，y）到（x + width，y + height）\n\n### setScissorTest ( boolean : Boolean ) : null\n启用或禁用裁剪测试。 启用此选项后，只有定义的裁剪区域内的像素才会受到其他渲染器操作的影响\n\n### setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null\n\n将输出画布的大小调整为（width，height），并考虑设备像素比率，将视口调整为从（0,0）开始适应该尺寸的大小。 将updateStyle设置为false可防止对输出画布进行任何样式更改\n\n### setTexture2D ( texture : Texture, slot : number ) : null\ntexture - 需要设置的纹理  \nslot - 指示纹理应使用哪个槽的数字  \n\n此方法将正确的纹理设置为WebGL着色器的正确插槽。 可以找到槽号作为采样器的均匀值\n\n### setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null\n\ntexture - 需要设置的cubeTexture。\nslot - 指示纹理应使用哪个槽的数字。\n\n此方法将正确的纹理设置为WebGL着色器的正确插槽， 可以找到槽号作为采样器的均匀值\n\nsetViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\n将视口设置为从（x，y）到（x + width，y + height）\n\n\n# WebGLRenderTarget\n## 概念\n显卡为后台渲染场景的缓冲区，它用于不同的效果，例如在渲染图像显示在屏幕进行后期处理\n\n## 使用\n```\nWebGLRenderTarget(width : Number, height : Number, options : Object)\n```\nwidth -- renderTarget的宽度      \nheight -- renderTarget的高度   \noptions是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值  \nwrapS - 默认为ClampToEdgeWrapping  \nwrapT - 默认为ClampToEdgeWrapping  \nmagFilter - 默认为LinearFilter  \nminFilter - 默认为LinearFilter  \nformat - 默认为RGBAFormat  \ntype - 默认为UnsignedByteType  \nanisotropy - 默认值为1  \nencoding - 默认为LinearEncoding  \ndepthBuffer - 默认为true。 如果您不需要，请将此设置为false  \nstencilBuffer - 默认为true。 如果您不需要，请将此设置为false  \n\n\n## 属性\n\n### width : number\n渲染目标的宽度\n\n### height : number\n渲染目标的高度\n\n### scissor : Vector4\n渲染目标视口内的矩形区域。 区域外的部分将被裁剪\n\n### scissorTest : boolean\n是否激活裁剪测试\n\n### viewport : Vector4\n渲染目标的视口\n\n### texture\n此纹理实例保存渲染的像素,将其用作输入以进行进一步处理\n\n### depthBuffer : boolean\n渲染到深度缓冲区。 默认为true\n\n### stencilBuffer\n渲染到深度缓冲区。 默认为true\n\n### depthTexture : DepthTexture\n如果设置，则场景深度将呈现给此纹理。 默认值为null\n\n## 方法\n### setSize ( width : Number, height : Number ) : null\n设置渲染目标的尺寸\n\n### clone () : WebGLRenderTarget\n创建渲染目标的克隆\n\n### copy ( source : WebGLRenderTarget ) : WebGLRenderTarget\n采用source中渲染目标的设置到该渲染目标\n\n### dispose () : null\n调用dispose事件\n\n# WebGLRenderTargetCube\n## 概念\n使用立方体相机(CubeCamera)对象来作为WebGL渲染器目标(WebGLRenderTarget)\n\n## 使用\n```\nWebGLRenderTargetCube(width : Number, height : Number, options : Object)\n```\nwidth -- renderTarget的宽度    \nheight -- renderTarget的高度  \noptions是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值  \nwrapS - 默认为ClampToEdgeWrapping  \nwrapT - 默认为ClampToEdgeWrapping  \nmagFilter - 默认为LinearFilter  \nminFilter - 默认为LinearFilter  \nformat - 默认为RGBAFormat  \ntype - 默认为UnsignedByteType  \nanisotropy - 默认值为1  \nencoding - 默认为LinearEncoding  \ndepthBuffer - 默认为true。 如果您不需要，请将此设置为false  \nstencilBuffer - 默认为true。 如果您不需要，请将此设置为false  \n## 属性\n### activeCubeFace : integer\n对应于立方体侧（PX 0，NX 1，PY 2，NY 3，PZ 4，NZ 5），由CubeCamera内部使用和设置\n### 继承\n继承自**WebGLRenderTarget**\n## 方法\n继承自**WebGLRenderTarget**\n\n\n\n","slug":"threejs解读 webGLRender","published":1,"date":"2018-12-11T14:58:14.720Z","updated":"2018-12-11T14:58:14.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpjvf0e500005yjihv9nn3h4","content":"<h1 id=\"WebGLRender\"><a href=\"#WebGLRender\" class=\"headerlink\" title=\"WebGLRender\"></a>WebGLRender</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>使用WebGL渲染场景</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderer( parameters : Object )</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>canvas</strong> - 绘制输出的canvas。这对应于下面的domElement属性。如果没有传值，则将创建新的canvas元素。</p>\n</li>\n<li><p><strong>context</strong> - 可用于将渲染器添加到现有的RenderingContext。默认值为null</p>\n</li>\n<li><strong>precision</strong> - 着色器精度。可以是“highp”，“mediump”或“lowp”。如果设备支持，则默认为“highp”</li>\n<li><strong>alpha</strong> 画布是否包含alpha（透明度）缓冲区。默认值为false</li>\n<li><strong>premultipliedAlpha</strong> 渲染器是否会假设颜色具有预乘alpha。默认为true</li>\n<li><strong>antialias</strong> 是否执行抗锯齿,默认值为false</li>\n<li><strong>stencil</strong> 绘图缓冲区是否具有至少8位的模板缓冲区。默认为true</li>\n<li><strong>preserveDrawingBuffer</strong> 在手动清除或覆盖之前是否保留缓冲区。默认值为false</li>\n<li><strong>powerPreference</strong> 向用户代理提供一个提示，指示适用于此WebGL上下文的GPU配置。可以是“high-performance”，“low-power”或“default”。默认为“default”</li>\n<li><strong>depth</strong> 绘图缓冲区是否具有至少16位的深度缓冲区。 默认为true</li>\n<li><strong>logarithmicDepthBuffer</strong> 是否使用对数深度缓冲区。 如果在单个场景中处理规模的巨大差异，则可能需要使用它。 默认值为false</li>\n</ul>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"autoClear-Boolean\"><a href=\"#autoClear-Boolean\" class=\"headerlink\" title=\"autoClear: Boolean\"></a>autoClear: Boolean</h3><p>定义渲染器是否应在渲染帧之前自动清除其输出</p>\n<h3 id=\"autoClearColor-Boolean\"><a href=\"#autoClearColor-Boolean\" class=\"headerlink\" title=\"autoClearColor: Boolean\"></a>autoClearColor: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除颜色缓冲区, 默认为true</p>\n<h3 id=\"autoClearDepth-Boolean\"><a href=\"#autoClearDepth-Boolean\" class=\"headerlink\" title=\"autoClearDepth: Boolean\"></a>autoClearDepth: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除深度缓冲区, 默认为true</p>\n<h3 id=\"autoClearStencil-Boolean\"><a href=\"#autoClearStencil-Boolean\" class=\"headerlink\" title=\"autoClearStencil: Boolean\"></a>autoClearStencil: Boolean</h3><p>如果autoClear为true，则定义渲染器是否应清除模板缓冲区, 默认为true</p>\n<h3 id=\"capabilities-Object\"><a href=\"#capabilities-Object\" class=\"headerlink\" title=\"capabilities: Object\"></a>capabilities: Object</h3><p>包含当前RenderingContext功能详细信息d的对象<br>// TODO 对象属性待补充  </p>\n<h3 id=\"clippingPlanes-Array\"><a href=\"#clippingPlanes-Array\" class=\"headerlink\" title=\"clippingPlanes : Array\"></a>clippingPlanes : Array</h3><p>用户定义的在世界坐标系的裁剪平面对象。这些平面全局可用。空间中的点和该平面的点积为负将被裁剪掉。默认为 [].</p>\n<h3 id=\"context-WebGLRenderingContext\"><a href=\"#context-WebGLRenderingContext\" class=\"headerlink\" title=\"context : WebGLRenderingContext\"></a>context : WebGLRenderingContext</h3><p>渲染器默认通过HTMLCanvasElement.getContext（）方法其domElement获取RenderingContext上下文。<br>您可以手动创建它，但它必须与domElement对应才能渲染到屏幕</p>\n<h3 id=\"domElement：DOMElement\"><a href=\"#domElement：DOMElement\" class=\"headerlink\" title=\"domElement：DOMElement\"></a>domElement：DOMElement</h3><p>canvas元素。<br>这是由构造函数中的渲染器自动创建的（如果调用WebGLRenderer没有传入canvas）; 你只需将它添加到你的页面就像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild（renderer.domElement）;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"extensions-Object\"><a href=\"#extensions-Object\" class=\"headerlink\" title=\"extensions : Object\"></a>extensions : Object</h3><p><strong>extensions.get</strong>方法的封装，用于检查是否支持各种WebGL扩展。</p>\n<h3 id=\"gammaFactor-Float\"><a href=\"#gammaFactor-Float\" class=\"headerlink\" title=\"gammaFactor: Float\"></a>gammaFactor: Float</h3><p> 默认是</p>\n<h3 id=\"gammaInput：Boolean\"><a href=\"#gammaInput：Boolean\" class=\"headerlink\" title=\"gammaInput：Boolean\"></a>gammaInput：Boolean</h3><p>如果设置，则所有纹理和颜色都是预乘伽马因子值。 默认值为false</p>\n<h3 id=\"gammaOutput：Boolean\"><a href=\"#gammaOutput：Boolean\" class=\"headerlink\" title=\"gammaOutput：Boolean\"></a>gammaOutput：Boolean</h3><p>如果设置，则所有纹理和颜色需要以预乘伽马输出。 默认值为false</p>\n<h3 id=\"info-Object\"><a href=\"#info-Object\" class=\"headerlink\" title=\"info: Object\"></a>info: Object</h3><p>一个关于显卡内存和渲染过程统计信息的对象。便于调试和分析。该对象包含如下字段</p>\n<ul>\n<li>memory:<ul>\n<li>geometries</li>\n<li>textures</li>\n</ul>\n</li>\n<li>render:<ul>\n<li>calls</li>\n<li>vertices</li>\n<li>faces</li>\n<li>points</li>\n</ul>\n</li>\n<li>programs</li>\n</ul>\n<p>默认情况下，这些数据会在每次渲染调用时重置，但在使用一个或多个镜像时，最好使用自定义模式重置它们：</p>\n<pre><code>renderer.info.autoReset = false;\nrenderer.info.reset();\n</code></pre><h3 id=\"localClippingEnabled-Boolean\"><a href=\"#localClippingEnabled-Boolean\" class=\"headerlink\" title=\"localClippingEnabled : Boolean\"></a>localClippingEnabled : Boolean</h3><p>定义渲染器是否遵循对象级剪切平面。 默认值为false</p>\n<h3 id=\"maxMorphTargets-Integer\"><a href=\"#maxMorphTargets-Integer\" class=\"headerlink\" title=\"maxMorphTargets : Integer\"></a>maxMorphTargets : Integer</h3><p>着色器中允许的最大变形目标数。标准材料仅允许8个变形目标。默认值为8</p>\n<h3 id=\"maxMorphNormals-Integer\"><a href=\"#maxMorphNormals-Integer\" class=\"headerlink\" title=\"maxMorphNormals : Integer\"></a>maxMorphNormals : Integer</h3><p>着色器中允许的最大变形法线数。标准材料仅允许4个变形法线。默认值为4</p>\n<h3 id=\"physicallyCorrectLights-Boolean\"><a href=\"#physicallyCorrectLights-Boolean\" class=\"headerlink\" title=\"physicallyCorrectLights : Boolean\"></a>physicallyCorrectLights : Boolean</h3><p>是否使用物理上正确的照明模式。 默认值为false</p>\n<h3 id=\"properties-Object\"><a href=\"#properties-Object\" class=\"headerlink\" title=\"properties : Object\"></a>properties : Object</h3><p>由渲染器在内部使用，以跟踪各种子对象属性</p>\n<h3 id=\"renderLists-WebGLRenderLists\"><a href=\"#renderLists-WebGLRenderLists\" class=\"headerlink\" title=\"renderLists : WebGLRenderLists\"></a>renderLists : WebGLRenderLists</h3><p>在内部用于处理场景对象渲染的排序</p>\n<p>shadowMap : WebGLShadowMap<br>如果使用，它包含阴影贴图的引用</p>\n<h3 id=\"shadowMap-enabled-Boolean\"><a href=\"#shadowMap-enabled-Boolean\" class=\"headerlink\" title=\"shadowMap.enabled : Boolean\"></a>shadowMap.enabled : Boolean</h3><p>如果为true,在场景中使用阴影贴图。 默认值为false</p>\n<h3 id=\"shadowMap-autoUpdate-Boolean\"><a href=\"#shadowMap-autoUpdate-Boolean\" class=\"headerlink\" title=\"shadowMap.autoUpdate : Boolean\"></a>shadowMap.autoUpdate : Boolean</h3><p>启用场景中阴影的自动更新。 默认为true<br>如果不需要动态光照/阴影，则可以在实例化渲染器时将其设置为false</p>\n<h3 id=\"shadowMap-needsUpdate-Boolean\"><a href=\"#shadowMap-needsUpdate-Boolean\" class=\"headerlink\" title=\"shadowMap.needsUpdate : Boolean\"></a>shadowMap.needsUpdate : Boolean</h3><p>设置为true时，场景中的阴影贴图将在下一个渲染调用中更新,默认值为false<br>如果禁用了阴影贴图的自动更新<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">则需要将其设置为true，然后进行渲染调用以更新场景中的阴影</span><br><span class=\"line\"></span><br><span class=\"line\">### shadowMap.type : Integer</span><br><span class=\"line\">定义阴影贴图类型  </span><br><span class=\"line\">选项有**THREE.BasicShadowMap**，**THREE.PCFShadowMap**（默认），**THREE.PCFSoftShadowMap**</span><br><span class=\"line\"></span><br><span class=\"line\">### sortObjects : Boolean</span><br><span class=\"line\">定义渲染器是否应对对象进行排序。 默认为true  </span><br><span class=\"line\">注意：排序用于尝试正确渲染具有一定透明度的对象。 根据定义，排序对象可能无法在所有情况下使用。 根据应用的需要，可能需要关闭排序并使用其他方法来处理透明度渲染，例如， 手动确定每个对象的渲染顺序</span><br><span class=\"line\"></span><br><span class=\"line\">### state : Object</span><br><span class=\"line\">包含用于设置WebGLRenderer.context状态的各种属性的函数</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMapping: Constant</span><br><span class=\"line\">默认为**LinearToneMapping**</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMappingExposur： Number</span><br><span class=\"line\">色调映射的曝光级别。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMappingWhitePoint : Number</span><br><span class=\"line\">色调映射白点。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### allocTextureUnit : Integer</span><br><span class=\"line\">尝试分配纹理单元以供着色器使用。 如果尝试分配比GPU支持更多的纹理单元，则会发出警告。 这主要用于内部</span><br><span class=\"line\"></span><br><span class=\"line\">### clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : null</span><br><span class=\"line\"></span><br><span class=\"line\">告诉渲染器清除其颜色，深度或模板绘制缓冲区。 此方法将颜色缓冲区初始化为当前的清除色。</span><br><span class=\"line\">参数默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">### clearColor ( ) : null</span><br><span class=\"line\">清除颜色缓冲区。 相当于调用```clear（true，false，false）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"clearDepth-null\"><a href=\"#clearDepth-null\" class=\"headerlink\" title=\"clearDepth(): null\"></a>clearDepth(): null</h3><p>清除深度缓冲区。相当于调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### clearStencil ( ) : null</span><br><span class=\"line\">清除模板缓冲区。相当于调用```clear（false，false，true）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"compile-scene-Scene-camera-Camera-null\"><a href=\"#compile-scene-Scene-camera-Camera-null\" class=\"headerlink\" title=\"compile ( scene : Scene, camera : Camera ) : null\"></a>compile ( scene : Scene, camera : Camera ) : null</h3><p>使用相机编译场景中的所有材质。 这对于在第一次渲染之前预编译着色器很有用</p>\n<h3 id=\"copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null\"><a href=\"#copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null\" class=\"headerlink\" title=\"copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null\"></a>copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null</h3><p>将当前WebGLFramebuffer中的像素复制到2D纹理中</p>\n<h3 id=\"copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null\"><a href=\"#copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null\" class=\"headerlink\" title=\"copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null\"></a>copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null</h3><p>将纹理的所有像素复制到从给定位置开始的现有纹理</p>\n<h3 id=\"dispose-null\"><a href=\"#dispose-null\" class=\"headerlink\" title=\"dispose(): null\"></a>dispose(): null</h3><p>处理当前渲染上下文</p>\n<h3 id=\"extensions-get-extensionName-String-Object\"><a href=\"#extensions-get-extensionName-String-Object\" class=\"headerlink\" title=\"extensions.get ( extensionName : String ) : Object\"></a>extensions.get ( extensionName : String ) : Object</h3><p>用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息（如果可用）。 此方法可以检查以下扩展名：</p>\n<pre><code>- WEBGL_depth_texture\n- EXT_texture_filter_anisotropic\n- WEBGL_compressed_texture_s3tc\n- WEBGL_compressed_texture_pvrtc\n- WEBGL_compressed_texture_etc1\n</code></pre><h3 id=\"forceContextLoss-null\"><a href=\"#forceContextLoss-null\" class=\"headerlink\" title=\"forceContextLoss ( ) : null\"></a>forceContextLoss ( ) : null</h3><p>模拟WebGL上下文的丢失。 这需要支持WEBGL_lose_context扩展</p>\n<h3 id=\"getClearAlpha-Float\"><a href=\"#getClearAlpha-Float\" class=\"headerlink\" title=\"getClearAlpha () : Float\"></a>getClearAlpha () : Float</h3><p>返回具有当前clear alpha的float。 范围从0到1</p>\n<h3 id=\"getClearColor-Color\"><a href=\"#getClearColor-Color\" class=\"headerlink\" title=\"getClearColor () : Color\"></a>getClearColor () : Color</h3><p>返回具有当前清除色的THREE.Color实例</p>\n<h3 id=\"getContext-WebGLRenderingContext\"><a href=\"#getContext-WebGLRenderingContext\" class=\"headerlink\" title=\"getContext () : WebGLRenderingContext\"></a>getContext () : WebGLRenderingContext</h3><p>返回当前WebGL上下文</p>\n<h3 id=\"getContextAttributes-WebGLContextAttributes\"><a href=\"#getContextAttributes-WebGLContextAttributes\" class=\"headerlink\" title=\"getContextAttributes () : WebGLContextAttributes\"></a>getContextAttributes () : WebGLContextAttributes</h3><p>返回描述在创建WebGL上下文时设置的属性的对象</p>\n<h3 id=\"getRenderTarget-RenderTarget\"><a href=\"#getRenderTarget-RenderTarget\" class=\"headerlink\" title=\"getRenderTarget () : RenderTarget\"></a>getRenderTarget () : RenderTarget</h3><p>返回当前的RenderTarget（如果有）</p>\n<h3 id=\"getCurrentViewport-RenderTarget\"><a href=\"#getCurrentViewport-RenderTarget\" class=\"headerlink\" title=\"getCurrentViewport () : RenderTarget\"></a>getCurrentViewport () : RenderTarget</h3><p>返回当前视口</p>\n<h3 id=\"getDrawingBufferSize-Object\"><a href=\"#getDrawingBufferSize-Object\" class=\"headerlink\" title=\"getDrawingBufferSize () : Object\"></a>getDrawingBufferSize () : Object</h3><p>返回包含渲染器绘图缓冲区宽度和高度的对象，单位px</p>\n<h3 id=\"getPixelRatio-number\"><a href=\"#getPixelRatio-number\" class=\"headerlink\" title=\"getPixelRatio () : number\"></a>getPixelRatio () : number</h3><p>返回当前设备像素比率</p>\n<h3 id=\"getSize-Object\"><a href=\"#getSize-Object\" class=\"headerlink\" title=\"getSize () : Object\"></a>getSize () : Object</h3><p>返回包含渲染器输出画布的宽度和高度的对象（单位px)</p>\n<h3 id=\"resetGLState-null\"><a href=\"#resetGLState-null\" class=\"headerlink\" title=\"resetGLState ( ) : null\"></a>resetGLState ( ) : null</h3><p>将GL状态重置为默认值。 如果WebGL上下文丢失，则在内部调用</p>\n<h3 id=\"readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null\"><a href=\"#readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null\" class=\"headerlink\" title=\"readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null\"></a>readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null</h3><p>将renderTarget中的像素数据读入的缓冲区。这是WebGLRenderingContext.readPixels（）的封装函数</p>\n<h3 id=\"render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null\"><a href=\"#render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null\" class=\"headerlink\" title=\"render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null\"></a>render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null</h3><p>使用相机渲染场景<br>渲染到r<strong>enderTarget</strong>或canvas<br>如果<strong>forceClear</strong>为true，则即使<strong>autoClear</strong>属性为false，也会在渲染之前清除深度，模板和颜色缓冲区<br>即使将<strong>forceClear</strong>设置为true，也可以通过将<strong>autoClearColor</strong>，<strong>autoClearStencil</strong>或<strong>autoClearDepth</strong>属性设置为false来阻止清除某些缓冲区</p>\n<h3 id=\"renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null\"><a href=\"#renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null\" class=\"headerlink\" title=\"renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null\"></a>renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null</h3><p>使用相机和指定材质渲染缓冲几何集合</p>\n<h3 id=\"renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null\"><a href=\"#renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null\" class=\"headerlink\" title=\"renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null\"></a>renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null</h3><p>object - Object3D实例<br>program - shaderProgram实例<br>着色 -  Material实例   </p>\n<p>渲染立即缓冲区。 由renderImmediateObject调用</p>\n<h3 id=\"setAnimationLoop-callback-Function-null\"><a href=\"#setAnimationLoop-callback-Function-null\" class=\"headerlink\" title=\"setAnimationLoop ( callback : Function ) : null\"></a>setAnimationLoop ( callback : Function ) : null</h3><p>callback - 将在每个可用帧中调用该函数。 如果传递<code>null</code>，它将停止任何已经在进行的动画   </p>\n<p>可以用来代替requestAnimationFrame的内置函数。 对于WebVR项目，必须使用此功能</p>\n<h3 id=\"setClearAlpha-alpha-Float-null\"><a href=\"#setClearAlpha-alpha-Float-null\" class=\"headerlink\" title=\"setClearAlpha ( alpha : Float ) : null\"></a>setClearAlpha ( alpha : Float ) : null</h3><p>设置清除的alpha。 有效输入是介于0.0和1.0之间的浮点数</p>\n<h3 id=\"setClearColor-color-Color-alpha-Float-null\"><a href=\"#setClearColor-color-Color-alpha-Float-null\" class=\"headerlink\" title=\"setClearColor ( color : Color, alpha : Float ) : null\"></a>setClearColor ( color : Color, alpha : Float ) : null</h3><p>设置清除色和不透明度</p>\n<h3 id=\"setPixelRatio-value-number-null\"><a href=\"#setPixelRatio-value-number-null\" class=\"headerlink\" title=\"setPixelRatio ( value : number ) : null\"></a>setPixelRatio ( value : number ) : null</h3><p>设置设备像素比率。 这通常用于HiDPI设备，以防止画面模糊。</p>\n<h3 id=\"setRenderTarget-renderTarget-WebGLRenderTarget-null\"><a href=\"#setRenderTarget-renderTarget-WebGLRenderTarget-null\" class=\"headerlink\" title=\"setRenderTarget ( renderTarget : WebGLRenderTarget ) : null\"></a>setRenderTarget ( renderTarget : WebGLRenderTarget ) : null</h3><p>renderTarget - 需要激活的renderTarget（可选）</p>\n<p>此方法设置活动的rendertarget。 如果省略该参数，则将画布设置为活动的rendertarget</p>\n<h3 id=\"setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null\"><a href=\"#setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null\" class=\"headerlink\" title=\"setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\"></a>setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null</h3><p>将裁剪区域设置为（x，y）到（x + width，y + height）</p>\n<h3 id=\"setScissorTest-boolean-Boolean-null\"><a href=\"#setScissorTest-boolean-Boolean-null\" class=\"headerlink\" title=\"setScissorTest ( boolean : Boolean ) : null\"></a>setScissorTest ( boolean : Boolean ) : null</h3><p>启用或禁用裁剪测试。 启用此选项后，只有定义的裁剪区域内的像素才会受到其他渲染器操作的影响</p>\n<h3 id=\"setSize-width-Integer-height-Integer-updateStyle-Boolean-null\"><a href=\"#setSize-width-Integer-height-Integer-updateStyle-Boolean-null\" class=\"headerlink\" title=\"setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null\"></a>setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null</h3><p>将输出画布的大小调整为（width，height），并考虑设备像素比率，将视口调整为从（0,0）开始适应该尺寸的大小。 将updateStyle设置为false可防止对输出画布进行任何样式更改</p>\n<h3 id=\"setTexture2D-texture-Texture-slot-number-null\"><a href=\"#setTexture2D-texture-Texture-slot-number-null\" class=\"headerlink\" title=\"setTexture2D ( texture : Texture, slot : number ) : null\"></a>setTexture2D ( texture : Texture, slot : number ) : null</h3><p>texture - 需要设置的纹理<br>slot - 指示纹理应使用哪个槽的数字  </p>\n<p>此方法将正确的纹理设置为WebGL着色器的正确插槽。 可以找到槽号作为采样器的均匀值</p>\n<h3 id=\"setTextureCube-cubeTexture-CubeTexture-slot-Number-null\"><a href=\"#setTextureCube-cubeTexture-CubeTexture-slot-Number-null\" class=\"headerlink\" title=\"setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null\"></a>setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null</h3><p>texture - 需要设置的cubeTexture。<br>slot - 指示纹理应使用哪个槽的数字。</p>\n<p>此方法将正确的纹理设置为WebGL着色器的正确插槽， 可以找到槽号作为采样器的均匀值</p>\n<p>setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null<br>将视口设置为从（x，y）到（x + width，y + height）</p>\n<h1 id=\"WebGLRenderTarget\"><a href=\"#WebGLRenderTarget\" class=\"headerlink\" title=\"WebGLRenderTarget\"></a>WebGLRenderTarget</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>显卡为后台渲染场景的缓冲区，它用于不同的效果，例如在渲染图像显示在屏幕进行后期处理</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderTarget(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>\n<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"width-number\"><a href=\"#width-number\" class=\"headerlink\" title=\"width : number\"></a>width : number</h3><p>渲染目标的宽度</p>\n<h3 id=\"height-number\"><a href=\"#height-number\" class=\"headerlink\" title=\"height : number\"></a>height : number</h3><p>渲染目标的高度</p>\n<h3 id=\"scissor-Vector4\"><a href=\"#scissor-Vector4\" class=\"headerlink\" title=\"scissor : Vector4\"></a>scissor : Vector4</h3><p>渲染目标视口内的矩形区域。 区域外的部分将被裁剪</p>\n<h3 id=\"scissorTest-boolean\"><a href=\"#scissorTest-boolean\" class=\"headerlink\" title=\"scissorTest : boolean\"></a>scissorTest : boolean</h3><p>是否激活裁剪测试</p>\n<h3 id=\"viewport-Vector4\"><a href=\"#viewport-Vector4\" class=\"headerlink\" title=\"viewport : Vector4\"></a>viewport : Vector4</h3><p>渲染目标的视口</p>\n<h3 id=\"texture\"><a href=\"#texture\" class=\"headerlink\" title=\"texture\"></a>texture</h3><p>此纹理实例保存渲染的像素,将其用作输入以进行进一步处理</p>\n<h3 id=\"depthBuffer-boolean\"><a href=\"#depthBuffer-boolean\" class=\"headerlink\" title=\"depthBuffer : boolean\"></a>depthBuffer : boolean</h3><p>渲染到深度缓冲区。 默认为true</p>\n<h3 id=\"stencilBuffer\"><a href=\"#stencilBuffer\" class=\"headerlink\" title=\"stencilBuffer\"></a>stencilBuffer</h3><p>渲染到深度缓冲区。 默认为true</p>\n<h3 id=\"depthTexture-DepthTexture\"><a href=\"#depthTexture-DepthTexture\" class=\"headerlink\" title=\"depthTexture : DepthTexture\"></a>depthTexture : DepthTexture</h3><p>如果设置，则场景深度将呈现给此纹理。 默认值为null</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"setSize-width-Number-height-Number-null\"><a href=\"#setSize-width-Number-height-Number-null\" class=\"headerlink\" title=\"setSize ( width : Number, height : Number ) : null\"></a>setSize ( width : Number, height : Number ) : null</h3><p>设置渲染目标的尺寸</p>\n<h3 id=\"clone-WebGLRenderTarget\"><a href=\"#clone-WebGLRenderTarget\" class=\"headerlink\" title=\"clone () : WebGLRenderTarget\"></a>clone () : WebGLRenderTarget</h3><p>创建渲染目标的克隆</p>\n<h3 id=\"copy-source-WebGLRenderTarget-WebGLRenderTarget\"><a href=\"#copy-source-WebGLRenderTarget-WebGLRenderTarget\" class=\"headerlink\" title=\"copy ( source : WebGLRenderTarget ) : WebGLRenderTarget\"></a>copy ( source : WebGLRenderTarget ) : WebGLRenderTarget</h3><p>采用source中渲染目标的设置到该渲染目标</p>\n<h3 id=\"dispose-null-1\"><a href=\"#dispose-null-1\" class=\"headerlink\" title=\"dispose () : null\"></a>dispose () : null</h3><p>调用dispose事件</p>\n<h1 id=\"WebGLRenderTargetCube\"><a href=\"#WebGLRenderTargetCube\" class=\"headerlink\" title=\"WebGLRenderTargetCube\"></a>WebGLRenderTargetCube</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>使用立方体相机(CubeCamera)对象来作为WebGL渲染器目标(WebGLRenderTarget)</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderTargetCube(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>\n<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"activeCubeFace-integer\"><a href=\"#activeCubeFace-integer\" class=\"headerlink\" title=\"activeCubeFace : integer\"></a>activeCubeFace : integer</h3><p>对应于立方体侧（PX 0，NX 1，PY 2，NY 3，PZ 4，NZ 5），由CubeCamera内部使用和设置</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承自<strong>WebGLRenderTarget</strong></p>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>继承自<strong>WebGLRenderTarget</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WebGLRender\"><a href=\"#WebGLRender\" class=\"headerlink\" title=\"WebGLRender\"></a>WebGLRender</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>使用WebGL渲染场景</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderer( parameters : Object )</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>canvas</strong> - 绘制输出的canvas。这对应于下面的domElement属性。如果没有传值，则将创建新的canvas元素。</p>\n</li>\n<li><p><strong>context</strong> - 可用于将渲染器添加到现有的RenderingContext。默认值为null</p>\n</li>\n<li><strong>precision</strong> - 着色器精度。可以是“highp”，“mediump”或“lowp”。如果设备支持，则默认为“highp”</li>\n<li><strong>alpha</strong> 画布是否包含alpha（透明度）缓冲区。默认值为false</li>\n<li><strong>premultipliedAlpha</strong> 渲染器是否会假设颜色具有预乘alpha。默认为true</li>\n<li><strong>antialias</strong> 是否执行抗锯齿,默认值为false</li>\n<li><strong>stencil</strong> 绘图缓冲区是否具有至少8位的模板缓冲区。默认为true</li>\n<li><strong>preserveDrawingBuffer</strong> 在手动清除或覆盖之前是否保留缓冲区。默认值为false</li>\n<li><strong>powerPreference</strong> 向用户代理提供一个提示，指示适用于此WebGL上下文的GPU配置。可以是“high-performance”，“low-power”或“default”。默认为“default”</li>\n<li><strong>depth</strong> 绘图缓冲区是否具有至少16位的深度缓冲区。 默认为true</li>\n<li><strong>logarithmicDepthBuffer</strong> 是否使用对数深度缓冲区。 如果在单个场景中处理规模的巨大差异，则可能需要使用它。 默认值为false</li>\n</ul>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"autoClear-Boolean\"><a href=\"#autoClear-Boolean\" class=\"headerlink\" title=\"autoClear: Boolean\"></a>autoClear: Boolean</h3><p>定义渲染器是否应在渲染帧之前自动清除其输出</p>\n<h3 id=\"autoClearColor-Boolean\"><a href=\"#autoClearColor-Boolean\" class=\"headerlink\" title=\"autoClearColor: Boolean\"></a>autoClearColor: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除颜色缓冲区, 默认为true</p>\n<h3 id=\"autoClearDepth-Boolean\"><a href=\"#autoClearDepth-Boolean\" class=\"headerlink\" title=\"autoClearDepth: Boolean\"></a>autoClearDepth: Boolean</h3><p>如果<strong>autoClear</strong>为true，则定义渲染器是否应清除深度缓冲区, 默认为true</p>\n<h3 id=\"autoClearStencil-Boolean\"><a href=\"#autoClearStencil-Boolean\" class=\"headerlink\" title=\"autoClearStencil: Boolean\"></a>autoClearStencil: Boolean</h3><p>如果autoClear为true，则定义渲染器是否应清除模板缓冲区, 默认为true</p>\n<h3 id=\"capabilities-Object\"><a href=\"#capabilities-Object\" class=\"headerlink\" title=\"capabilities: Object\"></a>capabilities: Object</h3><p>包含当前RenderingContext功能详细信息d的对象<br>// TODO 对象属性待补充  </p>\n<h3 id=\"clippingPlanes-Array\"><a href=\"#clippingPlanes-Array\" class=\"headerlink\" title=\"clippingPlanes : Array\"></a>clippingPlanes : Array</h3><p>用户定义的在世界坐标系的裁剪平面对象。这些平面全局可用。空间中的点和该平面的点积为负将被裁剪掉。默认为 [].</p>\n<h3 id=\"context-WebGLRenderingContext\"><a href=\"#context-WebGLRenderingContext\" class=\"headerlink\" title=\"context : WebGLRenderingContext\"></a>context : WebGLRenderingContext</h3><p>渲染器默认通过HTMLCanvasElement.getContext（）方法其domElement获取RenderingContext上下文。<br>您可以手动创建它，但它必须与domElement对应才能渲染到屏幕</p>\n<h3 id=\"domElement：DOMElement\"><a href=\"#domElement：DOMElement\" class=\"headerlink\" title=\"domElement：DOMElement\"></a>domElement：DOMElement</h3><p>canvas元素。<br>这是由构造函数中的渲染器自动创建的（如果调用WebGLRenderer没有传入canvas）; 你只需将它添加到你的页面就像这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.appendChild（renderer.domElement）;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"extensions-Object\"><a href=\"#extensions-Object\" class=\"headerlink\" title=\"extensions : Object\"></a>extensions : Object</h3><p><strong>extensions.get</strong>方法的封装，用于检查是否支持各种WebGL扩展。</p>\n<h3 id=\"gammaFactor-Float\"><a href=\"#gammaFactor-Float\" class=\"headerlink\" title=\"gammaFactor: Float\"></a>gammaFactor: Float</h3><p> 默认是</p>\n<h3 id=\"gammaInput：Boolean\"><a href=\"#gammaInput：Boolean\" class=\"headerlink\" title=\"gammaInput：Boolean\"></a>gammaInput：Boolean</h3><p>如果设置，则所有纹理和颜色都是预乘伽马因子值。 默认值为false</p>\n<h3 id=\"gammaOutput：Boolean\"><a href=\"#gammaOutput：Boolean\" class=\"headerlink\" title=\"gammaOutput：Boolean\"></a>gammaOutput：Boolean</h3><p>如果设置，则所有纹理和颜色需要以预乘伽马输出。 默认值为false</p>\n<h3 id=\"info-Object\"><a href=\"#info-Object\" class=\"headerlink\" title=\"info: Object\"></a>info: Object</h3><p>一个关于显卡内存和渲染过程统计信息的对象。便于调试和分析。该对象包含如下字段</p>\n<ul>\n<li>memory:<ul>\n<li>geometries</li>\n<li>textures</li>\n</ul>\n</li>\n<li>render:<ul>\n<li>calls</li>\n<li>vertices</li>\n<li>faces</li>\n<li>points</li>\n</ul>\n</li>\n<li>programs</li>\n</ul>\n<p>默认情况下，这些数据会在每次渲染调用时重置，但在使用一个或多个镜像时，最好使用自定义模式重置它们：</p>\n<pre><code>renderer.info.autoReset = false;\nrenderer.info.reset();\n</code></pre><h3 id=\"localClippingEnabled-Boolean\"><a href=\"#localClippingEnabled-Boolean\" class=\"headerlink\" title=\"localClippingEnabled : Boolean\"></a>localClippingEnabled : Boolean</h3><p>定义渲染器是否遵循对象级剪切平面。 默认值为false</p>\n<h3 id=\"maxMorphTargets-Integer\"><a href=\"#maxMorphTargets-Integer\" class=\"headerlink\" title=\"maxMorphTargets : Integer\"></a>maxMorphTargets : Integer</h3><p>着色器中允许的最大变形目标数。标准材料仅允许8个变形目标。默认值为8</p>\n<h3 id=\"maxMorphNormals-Integer\"><a href=\"#maxMorphNormals-Integer\" class=\"headerlink\" title=\"maxMorphNormals : Integer\"></a>maxMorphNormals : Integer</h3><p>着色器中允许的最大变形法线数。标准材料仅允许4个变形法线。默认值为4</p>\n<h3 id=\"physicallyCorrectLights-Boolean\"><a href=\"#physicallyCorrectLights-Boolean\" class=\"headerlink\" title=\"physicallyCorrectLights : Boolean\"></a>physicallyCorrectLights : Boolean</h3><p>是否使用物理上正确的照明模式。 默认值为false</p>\n<h3 id=\"properties-Object\"><a href=\"#properties-Object\" class=\"headerlink\" title=\"properties : Object\"></a>properties : Object</h3><p>由渲染器在内部使用，以跟踪各种子对象属性</p>\n<h3 id=\"renderLists-WebGLRenderLists\"><a href=\"#renderLists-WebGLRenderLists\" class=\"headerlink\" title=\"renderLists : WebGLRenderLists\"></a>renderLists : WebGLRenderLists</h3><p>在内部用于处理场景对象渲染的排序</p>\n<p>shadowMap : WebGLShadowMap<br>如果使用，它包含阴影贴图的引用</p>\n<h3 id=\"shadowMap-enabled-Boolean\"><a href=\"#shadowMap-enabled-Boolean\" class=\"headerlink\" title=\"shadowMap.enabled : Boolean\"></a>shadowMap.enabled : Boolean</h3><p>如果为true,在场景中使用阴影贴图。 默认值为false</p>\n<h3 id=\"shadowMap-autoUpdate-Boolean\"><a href=\"#shadowMap-autoUpdate-Boolean\" class=\"headerlink\" title=\"shadowMap.autoUpdate : Boolean\"></a>shadowMap.autoUpdate : Boolean</h3><p>启用场景中阴影的自动更新。 默认为true<br>如果不需要动态光照/阴影，则可以在实例化渲染器时将其设置为false</p>\n<h3 id=\"shadowMap-needsUpdate-Boolean\"><a href=\"#shadowMap-needsUpdate-Boolean\" class=\"headerlink\" title=\"shadowMap.needsUpdate : Boolean\"></a>shadowMap.needsUpdate : Boolean</h3><p>设置为true时，场景中的阴影贴图将在下一个渲染调用中更新,默认值为false<br>如果禁用了阴影贴图的自动更新<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">则需要将其设置为true，然后进行渲染调用以更新场景中的阴影</span><br><span class=\"line\"></span><br><span class=\"line\">### shadowMap.type : Integer</span><br><span class=\"line\">定义阴影贴图类型  </span><br><span class=\"line\">选项有**THREE.BasicShadowMap**，**THREE.PCFShadowMap**（默认），**THREE.PCFSoftShadowMap**</span><br><span class=\"line\"></span><br><span class=\"line\">### sortObjects : Boolean</span><br><span class=\"line\">定义渲染器是否应对对象进行排序。 默认为true  </span><br><span class=\"line\">注意：排序用于尝试正确渲染具有一定透明度的对象。 根据定义，排序对象可能无法在所有情况下使用。 根据应用的需要，可能需要关闭排序并使用其他方法来处理透明度渲染，例如， 手动确定每个对象的渲染顺序</span><br><span class=\"line\"></span><br><span class=\"line\">### state : Object</span><br><span class=\"line\">包含用于设置WebGLRenderer.context状态的各种属性的函数</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMapping: Constant</span><br><span class=\"line\">默认为**LinearToneMapping**</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMappingExposur： Number</span><br><span class=\"line\">色调映射的曝光级别。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### toneMappingWhitePoint : Number</span><br><span class=\"line\">色调映射白点。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### allocTextureUnit : Integer</span><br><span class=\"line\">尝试分配纹理单元以供着色器使用。 如果尝试分配比GPU支持更多的纹理单元，则会发出警告。 这主要用于内部</span><br><span class=\"line\"></span><br><span class=\"line\">### clear ( color : Boolean, depth : Boolean, stencil : Boolean ) : null</span><br><span class=\"line\"></span><br><span class=\"line\">告诉渲染器清除其颜色，深度或模板绘制缓冲区。 此方法将颜色缓冲区初始化为当前的清除色。</span><br><span class=\"line\">参数默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">### clearColor ( ) : null</span><br><span class=\"line\">清除颜色缓冲区。 相当于调用```clear（true，false，false）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"clearDepth-null\"><a href=\"#clearDepth-null\" class=\"headerlink\" title=\"clearDepth(): null\"></a>clearDepth(): null</h3><p>清除深度缓冲区。相当于调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### clearStencil ( ) : null</span><br><span class=\"line\">清除模板缓冲区。相当于调用```clear（false，false，true）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"compile-scene-Scene-camera-Camera-null\"><a href=\"#compile-scene-Scene-camera-Camera-null\" class=\"headerlink\" title=\"compile ( scene : Scene, camera : Camera ) : null\"></a>compile ( scene : Scene, camera : Camera ) : null</h3><p>使用相机编译场景中的所有材质。 这对于在第一次渲染之前预编译着色器很有用</p>\n<h3 id=\"copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null\"><a href=\"#copyFramebufferToTexture-position-Vector2-texture-Texture-level-Number-null\" class=\"headerlink\" title=\"copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null\"></a>copyFramebufferToTexture ( position : Vector2, texture : Texture, level : Number ) : null</h3><p>将当前WebGLFramebuffer中的像素复制到2D纹理中</p>\n<h3 id=\"copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null\"><a href=\"#copyTextureToTexture-position-Vector2-srcTexture-Texture-dstTexture-Texture-level-Number-null\" class=\"headerlink\" title=\"copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null\"></a>copyTextureToTexture ( position : Vector2, srcTexture : Texture, dstTexture : Texture, level : Number ) : null</h3><p>将纹理的所有像素复制到从给定位置开始的现有纹理</p>\n<h3 id=\"dispose-null\"><a href=\"#dispose-null\" class=\"headerlink\" title=\"dispose(): null\"></a>dispose(): null</h3><p>处理当前渲染上下文</p>\n<h3 id=\"extensions-get-extensionName-String-Object\"><a href=\"#extensions-get-extensionName-String-Object\" class=\"headerlink\" title=\"extensions.get ( extensionName : String ) : Object\"></a>extensions.get ( extensionName : String ) : Object</h3><p>用于检查是否支持各种扩展，并返回一个对象，其中包含扩展的详细信息（如果可用）。 此方法可以检查以下扩展名：</p>\n<pre><code>- WEBGL_depth_texture\n- EXT_texture_filter_anisotropic\n- WEBGL_compressed_texture_s3tc\n- WEBGL_compressed_texture_pvrtc\n- WEBGL_compressed_texture_etc1\n</code></pre><h3 id=\"forceContextLoss-null\"><a href=\"#forceContextLoss-null\" class=\"headerlink\" title=\"forceContextLoss ( ) : null\"></a>forceContextLoss ( ) : null</h3><p>模拟WebGL上下文的丢失。 这需要支持WEBGL_lose_context扩展</p>\n<h3 id=\"getClearAlpha-Float\"><a href=\"#getClearAlpha-Float\" class=\"headerlink\" title=\"getClearAlpha () : Float\"></a>getClearAlpha () : Float</h3><p>返回具有当前clear alpha的float。 范围从0到1</p>\n<h3 id=\"getClearColor-Color\"><a href=\"#getClearColor-Color\" class=\"headerlink\" title=\"getClearColor () : Color\"></a>getClearColor () : Color</h3><p>返回具有当前清除色的THREE.Color实例</p>\n<h3 id=\"getContext-WebGLRenderingContext\"><a href=\"#getContext-WebGLRenderingContext\" class=\"headerlink\" title=\"getContext () : WebGLRenderingContext\"></a>getContext () : WebGLRenderingContext</h3><p>返回当前WebGL上下文</p>\n<h3 id=\"getContextAttributes-WebGLContextAttributes\"><a href=\"#getContextAttributes-WebGLContextAttributes\" class=\"headerlink\" title=\"getContextAttributes () : WebGLContextAttributes\"></a>getContextAttributes () : WebGLContextAttributes</h3><p>返回描述在创建WebGL上下文时设置的属性的对象</p>\n<h3 id=\"getRenderTarget-RenderTarget\"><a href=\"#getRenderTarget-RenderTarget\" class=\"headerlink\" title=\"getRenderTarget () : RenderTarget\"></a>getRenderTarget () : RenderTarget</h3><p>返回当前的RenderTarget（如果有）</p>\n<h3 id=\"getCurrentViewport-RenderTarget\"><a href=\"#getCurrentViewport-RenderTarget\" class=\"headerlink\" title=\"getCurrentViewport () : RenderTarget\"></a>getCurrentViewport () : RenderTarget</h3><p>返回当前视口</p>\n<h3 id=\"getDrawingBufferSize-Object\"><a href=\"#getDrawingBufferSize-Object\" class=\"headerlink\" title=\"getDrawingBufferSize () : Object\"></a>getDrawingBufferSize () : Object</h3><p>返回包含渲染器绘图缓冲区宽度和高度的对象，单位px</p>\n<h3 id=\"getPixelRatio-number\"><a href=\"#getPixelRatio-number\" class=\"headerlink\" title=\"getPixelRatio () : number\"></a>getPixelRatio () : number</h3><p>返回当前设备像素比率</p>\n<h3 id=\"getSize-Object\"><a href=\"#getSize-Object\" class=\"headerlink\" title=\"getSize () : Object\"></a>getSize () : Object</h3><p>返回包含渲染器输出画布的宽度和高度的对象（单位px)</p>\n<h3 id=\"resetGLState-null\"><a href=\"#resetGLState-null\" class=\"headerlink\" title=\"resetGLState ( ) : null\"></a>resetGLState ( ) : null</h3><p>将GL状态重置为默认值。 如果WebGL上下文丢失，则在内部调用</p>\n<h3 id=\"readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null\"><a href=\"#readRenderTargetPixels-renderTarget-WebGLRenderTarget-x-Float-y-Float-width-Float-height-Float-buffer-null\" class=\"headerlink\" title=\"readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null\"></a>readRenderTargetPixels ( renderTarget : WebGLRenderTarget, x : Float, y : Float, width : Float, height : Float, buffer ) : null</h3><p>将renderTarget中的像素数据读入的缓冲区。这是WebGLRenderingContext.readPixels（）的封装函数</p>\n<h3 id=\"render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null\"><a href=\"#render-scene-Scene-camera-Camera-renderTarget-WebGLRenderTarget-forceClear-Boolean-null\" class=\"headerlink\" title=\"render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null\"></a>render ( scene : Scene, camera : Camera, renderTarget : WebGLRenderTarget, forceClear : Boolean ) : null</h3><p>使用相机渲染场景<br>渲染到r<strong>enderTarget</strong>或canvas<br>如果<strong>forceClear</strong>为true，则即使<strong>autoClear</strong>属性为false，也会在渲染之前清除深度，模板和颜色缓冲区<br>即使将<strong>forceClear</strong>设置为true，也可以通过将<strong>autoClearColor</strong>，<strong>autoClearStencil</strong>或<strong>autoClearDepth</strong>属性设置为false来阻止清除某些缓冲区</p>\n<h3 id=\"renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null\"><a href=\"#renderBufferDirect-camera-Camera-fog-Fog-geometry-Geometry-material-Material-object-Object3D-group-Object-null\" class=\"headerlink\" title=\"renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null\"></a>renderBufferDirect ( camera : Camera, fog : Fog, geometry : Geometry, material : Material, object : Object3D, group : Object ) : null</h3><p>使用相机和指定材质渲染缓冲几何集合</p>\n<h3 id=\"renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null\"><a href=\"#renderBufferImmediate-object-Object3D-program-shaderprogram-shading-Material-null\" class=\"headerlink\" title=\"renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null\"></a>renderBufferImmediate ( object : Object3D, program : shaderprogram, shading : Material ) : null</h3><p>object - Object3D实例<br>program - shaderProgram实例<br>着色 -  Material实例   </p>\n<p>渲染立即缓冲区。 由renderImmediateObject调用</p>\n<h3 id=\"setAnimationLoop-callback-Function-null\"><a href=\"#setAnimationLoop-callback-Function-null\" class=\"headerlink\" title=\"setAnimationLoop ( callback : Function ) : null\"></a>setAnimationLoop ( callback : Function ) : null</h3><p>callback - 将在每个可用帧中调用该函数。 如果传递<code>null</code>，它将停止任何已经在进行的动画   </p>\n<p>可以用来代替requestAnimationFrame的内置函数。 对于WebVR项目，必须使用此功能</p>\n<h3 id=\"setClearAlpha-alpha-Float-null\"><a href=\"#setClearAlpha-alpha-Float-null\" class=\"headerlink\" title=\"setClearAlpha ( alpha : Float ) : null\"></a>setClearAlpha ( alpha : Float ) : null</h3><p>设置清除的alpha。 有效输入是介于0.0和1.0之间的浮点数</p>\n<h3 id=\"setClearColor-color-Color-alpha-Float-null\"><a href=\"#setClearColor-color-Color-alpha-Float-null\" class=\"headerlink\" title=\"setClearColor ( color : Color, alpha : Float ) : null\"></a>setClearColor ( color : Color, alpha : Float ) : null</h3><p>设置清除色和不透明度</p>\n<h3 id=\"setPixelRatio-value-number-null\"><a href=\"#setPixelRatio-value-number-null\" class=\"headerlink\" title=\"setPixelRatio ( value : number ) : null\"></a>setPixelRatio ( value : number ) : null</h3><p>设置设备像素比率。 这通常用于HiDPI设备，以防止画面模糊。</p>\n<h3 id=\"setRenderTarget-renderTarget-WebGLRenderTarget-null\"><a href=\"#setRenderTarget-renderTarget-WebGLRenderTarget-null\" class=\"headerlink\" title=\"setRenderTarget ( renderTarget : WebGLRenderTarget ) : null\"></a>setRenderTarget ( renderTarget : WebGLRenderTarget ) : null</h3><p>renderTarget - 需要激活的renderTarget（可选）</p>\n<p>此方法设置活动的rendertarget。 如果省略该参数，则将画布设置为活动的rendertarget</p>\n<h3 id=\"setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null\"><a href=\"#setScissor-x-Integer-y-Integer-width-Integer-height-Integer-null\" class=\"headerlink\" title=\"setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null\"></a>setScissor ( x : Integer, y : Integer, width : Integer, height : Integer ) : null</h3><p>将裁剪区域设置为（x，y）到（x + width，y + height）</p>\n<h3 id=\"setScissorTest-boolean-Boolean-null\"><a href=\"#setScissorTest-boolean-Boolean-null\" class=\"headerlink\" title=\"setScissorTest ( boolean : Boolean ) : null\"></a>setScissorTest ( boolean : Boolean ) : null</h3><p>启用或禁用裁剪测试。 启用此选项后，只有定义的裁剪区域内的像素才会受到其他渲染器操作的影响</p>\n<h3 id=\"setSize-width-Integer-height-Integer-updateStyle-Boolean-null\"><a href=\"#setSize-width-Integer-height-Integer-updateStyle-Boolean-null\" class=\"headerlink\" title=\"setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null\"></a>setSize ( width : Integer, height : Integer, updateStyle : Boolean ) : null</h3><p>将输出画布的大小调整为（width，height），并考虑设备像素比率，将视口调整为从（0,0）开始适应该尺寸的大小。 将updateStyle设置为false可防止对输出画布进行任何样式更改</p>\n<h3 id=\"setTexture2D-texture-Texture-slot-number-null\"><a href=\"#setTexture2D-texture-Texture-slot-number-null\" class=\"headerlink\" title=\"setTexture2D ( texture : Texture, slot : number ) : null\"></a>setTexture2D ( texture : Texture, slot : number ) : null</h3><p>texture - 需要设置的纹理<br>slot - 指示纹理应使用哪个槽的数字  </p>\n<p>此方法将正确的纹理设置为WebGL着色器的正确插槽。 可以找到槽号作为采样器的均匀值</p>\n<h3 id=\"setTextureCube-cubeTexture-CubeTexture-slot-Number-null\"><a href=\"#setTextureCube-cubeTexture-CubeTexture-slot-Number-null\" class=\"headerlink\" title=\"setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null\"></a>setTextureCube ( cubeTexture : CubeTexture, slot : Number ) : null</h3><p>texture - 需要设置的cubeTexture。<br>slot - 指示纹理应使用哪个槽的数字。</p>\n<p>此方法将正确的纹理设置为WebGL着色器的正确插槽， 可以找到槽号作为采样器的均匀值</p>\n<p>setViewport ( x : Integer, y : Integer, width : Integer, height : Integer ) : null<br>将视口设置为从（x，y）到（x + width，y + height）</p>\n<h1 id=\"WebGLRenderTarget\"><a href=\"#WebGLRenderTarget\" class=\"headerlink\" title=\"WebGLRenderTarget\"></a>WebGLRenderTarget</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>显卡为后台渲染场景的缓冲区，它用于不同的效果，例如在渲染图像显示在屏幕进行后期处理</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderTarget(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>\n<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"width-number\"><a href=\"#width-number\" class=\"headerlink\" title=\"width : number\"></a>width : number</h3><p>渲染目标的宽度</p>\n<h3 id=\"height-number\"><a href=\"#height-number\" class=\"headerlink\" title=\"height : number\"></a>height : number</h3><p>渲染目标的高度</p>\n<h3 id=\"scissor-Vector4\"><a href=\"#scissor-Vector4\" class=\"headerlink\" title=\"scissor : Vector4\"></a>scissor : Vector4</h3><p>渲染目标视口内的矩形区域。 区域外的部分将被裁剪</p>\n<h3 id=\"scissorTest-boolean\"><a href=\"#scissorTest-boolean\" class=\"headerlink\" title=\"scissorTest : boolean\"></a>scissorTest : boolean</h3><p>是否激活裁剪测试</p>\n<h3 id=\"viewport-Vector4\"><a href=\"#viewport-Vector4\" class=\"headerlink\" title=\"viewport : Vector4\"></a>viewport : Vector4</h3><p>渲染目标的视口</p>\n<h3 id=\"texture\"><a href=\"#texture\" class=\"headerlink\" title=\"texture\"></a>texture</h3><p>此纹理实例保存渲染的像素,将其用作输入以进行进一步处理</p>\n<h3 id=\"depthBuffer-boolean\"><a href=\"#depthBuffer-boolean\" class=\"headerlink\" title=\"depthBuffer : boolean\"></a>depthBuffer : boolean</h3><p>渲染到深度缓冲区。 默认为true</p>\n<h3 id=\"stencilBuffer\"><a href=\"#stencilBuffer\" class=\"headerlink\" title=\"stencilBuffer\"></a>stencilBuffer</h3><p>渲染到深度缓冲区。 默认为true</p>\n<h3 id=\"depthTexture-DepthTexture\"><a href=\"#depthTexture-DepthTexture\" class=\"headerlink\" title=\"depthTexture : DepthTexture\"></a>depthTexture : DepthTexture</h3><p>如果设置，则场景深度将呈现给此纹理。 默认值为null</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"setSize-width-Number-height-Number-null\"><a href=\"#setSize-width-Number-height-Number-null\" class=\"headerlink\" title=\"setSize ( width : Number, height : Number ) : null\"></a>setSize ( width : Number, height : Number ) : null</h3><p>设置渲染目标的尺寸</p>\n<h3 id=\"clone-WebGLRenderTarget\"><a href=\"#clone-WebGLRenderTarget\" class=\"headerlink\" title=\"clone () : WebGLRenderTarget\"></a>clone () : WebGLRenderTarget</h3><p>创建渲染目标的克隆</p>\n<h3 id=\"copy-source-WebGLRenderTarget-WebGLRenderTarget\"><a href=\"#copy-source-WebGLRenderTarget-WebGLRenderTarget\" class=\"headerlink\" title=\"copy ( source : WebGLRenderTarget ) : WebGLRenderTarget\"></a>copy ( source : WebGLRenderTarget ) : WebGLRenderTarget</h3><p>采用source中渲染目标的设置到该渲染目标</p>\n<h3 id=\"dispose-null-1\"><a href=\"#dispose-null-1\" class=\"headerlink\" title=\"dispose () : null\"></a>dispose () : null</h3><p>调用dispose事件</p>\n<h1 id=\"WebGLRenderTargetCube\"><a href=\"#WebGLRenderTargetCube\" class=\"headerlink\" title=\"WebGLRenderTargetCube\"></a>WebGLRenderTargetCube</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>使用立方体相机(CubeCamera)对象来作为WebGL渲染器目标(WebGLRenderTarget)</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebGLRenderTargetCube(width : Number, height : Number, options : Object)</span><br></pre></td></tr></table></figure>\n<p>width – renderTarget的宽度<br>height – renderTarget的高度<br>options是可选的对象，保存一个自动生成的目标纹理的纹理参数以及depthBuffer / stencilBuffer布尔值<br>wrapS - 默认为ClampToEdgeWrapping<br>wrapT - 默认为ClampToEdgeWrapping<br>magFilter - 默认为LinearFilter<br>minFilter - 默认为LinearFilter<br>format - 默认为RGBAFormat<br>type - 默认为UnsignedByteType<br>anisotropy - 默认值为1<br>encoding - 默认为LinearEncoding<br>depthBuffer - 默认为true。 如果您不需要，请将此设置为false<br>stencilBuffer - 默认为true。 如果您不需要，请将此设置为false  </p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"activeCubeFace-integer\"><a href=\"#activeCubeFace-integer\" class=\"headerlink\" title=\"activeCubeFace : integer\"></a>activeCubeFace : integer</h3><p>对应于立方体侧（PX 0，NX 1，PY 2，NY 3，PZ 4，NZ 5），由CubeCamera内部使用和设置</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承自<strong>WebGLRenderTarget</strong></p>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>继承自<strong>WebGLRenderTarget</strong></p>\n"},{"title":"threejs 解读  camera","_content":"\n# Camera\n## 概念\n相机的抽象类，新构建的相机都继承自此类\n\n## 使用\n创建相机：\n```\nCamera()\n```\n\n## 属性\n### isCamera\n用于检查此类或派生类是否为相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### layers\n相机所属的layers  。 这是Object3D的继承属性。  \n在渲染相机的视点时，对象必须与相机共享至少一个图层。\n\n### matrixWorldInverse\n这是matrixWorld的逆矩阵,matrixWorld包含相机在世界坐标系的变换矩阵\n\n### projectionMatrix\n包含相机的投影矩阵\n\n### projectionMatrixInverse\nprojectionMatrix的逆矩阵\n\n## 方法\n### clone()\n返回具有与此相同属性的新相机\n\n### copy ( source : Camera, recursive : Boolean )\n将源摄像头中的属性复制到此摄像头中\n\n### getWorldDirection ( target : Vector3 )\ntarget - 结果将被复制到此Vector3中   \n返回表示摄像机正在查看的世界空间方向的Vector3\n\n\n# CubeCamera\n## 概念\n创建6个渲染到**WebGLRenderTargetCube**的摄像机\n\n\n## 使用\n```\nCubeCamera( near : Number, far : Number, cubeResolution : Number, options : Object )\n```\nnear - 相机近剪裁距离  \nfar - 相机远裁剪距离   \ncubeResolution - 设置立方体边缘的长度，体现为清晰度  \noptions - （可选）保存传递给自动生成的WebGLRenderTargetCube的纹理参数的对象。 如果未指定，则选项默认为：  \n```\n{format：RGBFormat，magFilter：LinearFilter，minFilter：LinearFilter}\n```  \n构造一个包含6个PerspectiveCameras相机渲染到WebGLRenderTargetCube\n\n## 属性\n### renderTarget\n生成的立方体纹理\n\n## 方法\n### update( renderer : WebGLRenderer, scene : Scene)\n\n调用它来更新renderTarget\n\n### clear( renderer : WebGLRenderer, color : Boolean, depth : Boolean, stencil : Boolean )\n调用此方法以清除renderTarget颜色，深度和/或模板缓冲区。 颜色缓冲区设置为渲染器的当前清晰颜色。 参数默认为true\n\n# OrthographicCamera\n## 概念\n在此投影模式下，无论距离相机的距离如何，渲染图像中的对象大小都保持不变\n这对于渲染2D场景和UI元素等非常有用\n\n## 使用\n```\nOrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )\n```\n\nleft — 相机视锥体的左平面\nright — 相机视锥体的右平面\ntop — 相机视锥体的上平面\nbottom — 相机视锥体的下平面\nnear — 相机视锥体的近平面\nfar — 相机视锥体的原平面\n\n这些一起定义了[相机的视锥体](https://en.wikipedia.org/wiki/Viewing_frustum)\n\n## 属性\n### bottom\n相机视锥体的下平面\n\n### far\n相机视锥体的远平面。默认是2000\n有效范围介于近平面和无穷远之间\n\n### isOrthographicCamera\n用于检查此类或派生类是否为正交相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### left\n相机视锥体的左平面\n\n### near\n相机视锥体的近平面。默认是0.1\n有效范围介于0和远平面\n\n### right\n相机视锥体的右平面\n\n### top\n相机视锥体的上平面\n\n### view\n通过**setViewOffset**方法设置，默认是null\n\n### zoom\n获取或设置摄像机的缩放系数, 默认值为1\n\n## 方法\n### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float )\n\nfullWidth - 多视图设置的全宽   \nfullHeight - 多视图设置的全高  \nx - 副摄像机的水平偏移   \ny - 副摄像机的垂直偏移   \nwidth - 副摄像机的宽度   \nheight - 副摄像机的高度  \n \n### clearViewOffset ()\n清除所有视图偏移\n\n### updateProjectionMatrix ()\n更新相机投影矩阵，必须在参数发生变化后调用\n\n### toJSON ()\n返回JSON格式的相机数据\n\n# PerspectiveCamera\n## 概念\n透视相机，这种投影模式旨在模仿人眼看到的方式，它是用于渲染3D场景的最常见投影模式。\n\n## 使用\n```\nPerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n```\nfov — 相机视锥体垂直视角  \naspect — 相机视锥体宽高比  \nnear — 相机视锥体近平面  \nfar — 相机视锥体远平面  \n\n## 属性\n### aspect\n相机视锥体宽高比，通常是画布宽度除以高度。默认是1\n\n### far\n相机视锥体的远截平面。默认是2000。  \n有效范围介于近平面和无穷远之间。\n\n### filmGauge\n用于较大轴的胶片尺寸。 默认值为35（毫米）。 除非**filmOffset**设置为非零值，否则此参数不会影响投影矩阵。\n\n### filmOffset\n与**filmGauge**相同单位的水平偏移，默认值为0\n\n### focus\n用于立体视觉和景深效果的物距。 除非使用**StereoCamera**，否则此参数不会影响投影矩阵。 默认值为10。\n\n### fov\n相机视锥体垂直视野，从底部到顶部的视图的角度度。 默认值为50\n\n### isPerspectiveCamera\n用于检查此类或派生类是否为透视相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### near\n相机视锥体的近截平面。默认是0.1  \n有效范围大于0且小于远平面\n\n### view\n视锥体窗口规范或null。 这是使用**setViewOffset**方法设置的，并使用**clearViewOffset**清除。\n\n### zoom\n获取或设置摄像机的缩放系数, 默认值为1\n\n## 方法\n### clearViewOffset ()\n删除**setViewOffset**方法设置的任何偏移量\n\n### getEffectiveFOV()\n返回乘以缩放系数 **zoom** 的当前视角，单位为角度（°）。\n\n### getFilmHeight()\n返回胶片上图像的高度,如果.aspect小于或等于1（纵向格式），则结果等于**filmGauge**\n\n### getFilmWidth()\n返回胶片上图像的宽度。 如果.aspect大于或等于1（横向格式），则结果等于**filmGauge**\n\n### getFocalLength ()\n返回当前和 **filmGauge** 有关的 **fov** 的焦距\n\n\n### setFocalLength ( focalLength : Float )\n设置当前和**filmGauge**有关的**fov**的焦距。\n默认情况下，焦距为35mm全幅相机\n\n### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) \n\n\nfullWidth - 多视图设置的全宽   \nfullHeight - 多视图设置的全高  \nx - 副摄像机的水平偏移   \ny - 副摄像机的垂直偏移   \nwidth - 副摄像机的宽度   \nheight - 副摄像机的高度  \n\n该方法用于在一个较大的视椎体中设置视图偏移。这对于多窗口或多监视器/多机设置是有用的。\n\n\n.updateProjectionMatrix ()\n更新相机投影矩阵，必须在参数发生变化后调用\n### clone ()\n返回一个 PerspectiveCamera 对象的克隆\n\n### toJSON ()\n返回JSON格式的相机数据\n\n# StereoCamera\n## 概念\n立体相机。用于双透视相机，例如[3D Anaglyph](https://en.wikipedia.org/wiki/Anaglyph_3D)或者[Parallax Barrier](https://en.wikipedia.org/wiki/Parallax_barrier).\n\n## 使用\n```\nStereoCamera()\n```\n\n## 属性\n### aspect\n相机视锥体宽高比，默认为1\n\n### eyeSep\n默认0.064\n\n### cameraL\n左相机。 这将添加到图层 - 左相机要渲染的对象也必须添加到此图层\n\n### cameraR\n右相机。 这将添加到图层 - 右相机要渲染的对象也必须添加到此图层\n\n## 方法\n### update\n根据传入的相机更新立体相机\n\n# ArrayCamera\n## 概念\nArrayCamera使用预定义的一相机有效地渲染场景。 这对于渲染VR场景是重要性能考虑。\nArrayCamera的一个实例总是有一个子摄像头数组。 必须为每个子摄像机定义bounds属性，该属性确定使用此摄像机渲染的视口部分\n\n## 使用\n```\nArrayCamera( array : Array )\n```\n相机数组\n\n## 属性\n### cameras \n相机数组","source":"_posts/threejs 解读  camera.md","raw":"title:      \"threejs 解读  camera\"\ntags:\n    - js threejs\n---\n\n# Camera\n## 概念\n相机的抽象类，新构建的相机都继承自此类\n\n## 使用\n创建相机：\n```\nCamera()\n```\n\n## 属性\n### isCamera\n用于检查此类或派生类是否为相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### layers\n相机所属的layers  。 这是Object3D的继承属性。  \n在渲染相机的视点时，对象必须与相机共享至少一个图层。\n\n### matrixWorldInverse\n这是matrixWorld的逆矩阵,matrixWorld包含相机在世界坐标系的变换矩阵\n\n### projectionMatrix\n包含相机的投影矩阵\n\n### projectionMatrixInverse\nprojectionMatrix的逆矩阵\n\n## 方法\n### clone()\n返回具有与此相同属性的新相机\n\n### copy ( source : Camera, recursive : Boolean )\n将源摄像头中的属性复制到此摄像头中\n\n### getWorldDirection ( target : Vector3 )\ntarget - 结果将被复制到此Vector3中   \n返回表示摄像机正在查看的世界空间方向的Vector3\n\n\n# CubeCamera\n## 概念\n创建6个渲染到**WebGLRenderTargetCube**的摄像机\n\n\n## 使用\n```\nCubeCamera( near : Number, far : Number, cubeResolution : Number, options : Object )\n```\nnear - 相机近剪裁距离  \nfar - 相机远裁剪距离   \ncubeResolution - 设置立方体边缘的长度，体现为清晰度  \noptions - （可选）保存传递给自动生成的WebGLRenderTargetCube的纹理参数的对象。 如果未指定，则选项默认为：  \n```\n{format：RGBFormat，magFilter：LinearFilter，minFilter：LinearFilter}\n```  \n构造一个包含6个PerspectiveCameras相机渲染到WebGLRenderTargetCube\n\n## 属性\n### renderTarget\n生成的立方体纹理\n\n## 方法\n### update( renderer : WebGLRenderer, scene : Scene)\n\n调用它来更新renderTarget\n\n### clear( renderer : WebGLRenderer, color : Boolean, depth : Boolean, stencil : Boolean )\n调用此方法以清除renderTarget颜色，深度和/或模板缓冲区。 颜色缓冲区设置为渲染器的当前清晰颜色。 参数默认为true\n\n# OrthographicCamera\n## 概念\n在此投影模式下，无论距离相机的距离如何，渲染图像中的对象大小都保持不变\n这对于渲染2D场景和UI元素等非常有用\n\n## 使用\n```\nOrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )\n```\n\nleft — 相机视锥体的左平面\nright — 相机视锥体的右平面\ntop — 相机视锥体的上平面\nbottom — 相机视锥体的下平面\nnear — 相机视锥体的近平面\nfar — 相机视锥体的原平面\n\n这些一起定义了[相机的视锥体](https://en.wikipedia.org/wiki/Viewing_frustum)\n\n## 属性\n### bottom\n相机视锥体的下平面\n\n### far\n相机视锥体的远平面。默认是2000\n有效范围介于近平面和无穷远之间\n\n### isOrthographicCamera\n用于检查此类或派生类是否为正交相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### left\n相机视锥体的左平面\n\n### near\n相机视锥体的近平面。默认是0.1\n有效范围介于0和远平面\n\n### right\n相机视锥体的右平面\n\n### top\n相机视锥体的上平面\n\n### view\n通过**setViewOffset**方法设置，默认是null\n\n### zoom\n获取或设置摄像机的缩放系数, 默认值为1\n\n## 方法\n### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float )\n\nfullWidth - 多视图设置的全宽   \nfullHeight - 多视图设置的全高  \nx - 副摄像机的水平偏移   \ny - 副摄像机的垂直偏移   \nwidth - 副摄像机的宽度   \nheight - 副摄像机的高度  \n \n### clearViewOffset ()\n清除所有视图偏移\n\n### updateProjectionMatrix ()\n更新相机投影矩阵，必须在参数发生变化后调用\n\n### toJSON ()\n返回JSON格式的相机数据\n\n# PerspectiveCamera\n## 概念\n透视相机，这种投影模式旨在模仿人眼看到的方式，它是用于渲染3D场景的最常见投影模式。\n\n## 使用\n```\nPerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n```\nfov — 相机视锥体垂直视角  \naspect — 相机视锥体宽高比  \nnear — 相机视锥体近平面  \nfar — 相机视锥体远平面  \n\n## 属性\n### aspect\n相机视锥体宽高比，通常是画布宽度除以高度。默认是1\n\n### far\n相机视锥体的远截平面。默认是2000。  \n有效范围介于近平面和无穷远之间。\n\n### filmGauge\n用于较大轴的胶片尺寸。 默认值为35（毫米）。 除非**filmOffset**设置为非零值，否则此参数不会影响投影矩阵。\n\n### filmOffset\n与**filmGauge**相同单位的水平偏移，默认值为0\n\n### focus\n用于立体视觉和景深效果的物距。 除非使用**StereoCamera**，否则此参数不会影响投影矩阵。 默认值为10。\n\n### fov\n相机视锥体垂直视野，从底部到顶部的视图的角度度。 默认值为50\n\n### isPerspectiveCamera\n用于检查此类或派生类是否为透视相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。\n\n### near\n相机视锥体的近截平面。默认是0.1  \n有效范围大于0且小于远平面\n\n### view\n视锥体窗口规范或null。 这是使用**setViewOffset**方法设置的，并使用**clearViewOffset**清除。\n\n### zoom\n获取或设置摄像机的缩放系数, 默认值为1\n\n## 方法\n### clearViewOffset ()\n删除**setViewOffset**方法设置的任何偏移量\n\n### getEffectiveFOV()\n返回乘以缩放系数 **zoom** 的当前视角，单位为角度（°）。\n\n### getFilmHeight()\n返回胶片上图像的高度,如果.aspect小于或等于1（纵向格式），则结果等于**filmGauge**\n\n### getFilmWidth()\n返回胶片上图像的宽度。 如果.aspect大于或等于1（横向格式），则结果等于**filmGauge**\n\n### getFocalLength ()\n返回当前和 **filmGauge** 有关的 **fov** 的焦距\n\n\n### setFocalLength ( focalLength : Float )\n设置当前和**filmGauge**有关的**fov**的焦距。\n默认情况下，焦距为35mm全幅相机\n\n### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) \n\n\nfullWidth - 多视图设置的全宽   \nfullHeight - 多视图设置的全高  \nx - 副摄像机的水平偏移   \ny - 副摄像机的垂直偏移   \nwidth - 副摄像机的宽度   \nheight - 副摄像机的高度  \n\n该方法用于在一个较大的视椎体中设置视图偏移。这对于多窗口或多监视器/多机设置是有用的。\n\n\n.updateProjectionMatrix ()\n更新相机投影矩阵，必须在参数发生变化后调用\n### clone ()\n返回一个 PerspectiveCamera 对象的克隆\n\n### toJSON ()\n返回JSON格式的相机数据\n\n# StereoCamera\n## 概念\n立体相机。用于双透视相机，例如[3D Anaglyph](https://en.wikipedia.org/wiki/Anaglyph_3D)或者[Parallax Barrier](https://en.wikipedia.org/wiki/Parallax_barrier).\n\n## 使用\n```\nStereoCamera()\n```\n\n## 属性\n### aspect\n相机视锥体宽高比，默认为1\n\n### eyeSep\n默认0.064\n\n### cameraL\n左相机。 这将添加到图层 - 左相机要渲染的对象也必须添加到此图层\n\n### cameraR\n右相机。 这将添加到图层 - 右相机要渲染的对象也必须添加到此图层\n\n## 方法\n### update\n根据传入的相机更新立体相机\n\n# ArrayCamera\n## 概念\nArrayCamera使用预定义的一相机有效地渲染场景。 这对于渲染VR场景是重要性能考虑。\nArrayCamera的一个实例总是有一个子摄像头数组。 必须为每个子摄像机定义bounds属性，该属性确定使用此摄像机渲染的视口部分\n\n## 使用\n```\nArrayCamera( array : Array )\n```\n相机数组\n\n## 属性\n### cameras \n相机数组","slug":"threejs 解读  camera","published":1,"date":"2018-12-16T06:47:13.504Z","updated":"2018-12-16T06:47:13.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpqj2xnl0000yrji9bzomw33","content":"<h1 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a>Camera</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>相机的抽象类，新构建的相机都继承自此类</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建相机：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Camera()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"isCamera\"><a href=\"#isCamera\" class=\"headerlink\" title=\"isCamera\"></a>isCamera</h3><p>用于检查此类或派生类是否为相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</p>\n<h3 id=\"layers\"><a href=\"#layers\" class=\"headerlink\" title=\"layers\"></a>layers</h3><p>相机所属的layers  。 这是Object3D的继承属性。<br>在渲染相机的视点时，对象必须与相机共享至少一个图层。</p>\n<h3 id=\"matrixWorldInverse\"><a href=\"#matrixWorldInverse\" class=\"headerlink\" title=\"matrixWorldInverse\"></a>matrixWorldInverse</h3><p>这是matrixWorld的逆矩阵,matrixWorld包含相机在世界坐标系的变换矩阵</p>\n<h3 id=\"projectionMatrix\"><a href=\"#projectionMatrix\" class=\"headerlink\" title=\"projectionMatrix\"></a>projectionMatrix</h3><p>包含相机的投影矩阵</p>\n<h3 id=\"projectionMatrixInverse\"><a href=\"#projectionMatrixInverse\" class=\"headerlink\" title=\"projectionMatrixInverse\"></a>projectionMatrixInverse</h3><p>projectionMatrix的逆矩阵</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone()\"></a>clone()</h3><p>返回具有与此相同属性的新相机</p>\n<h3 id=\"copy-source-Camera-recursive-Boolean\"><a href=\"#copy-source-Camera-recursive-Boolean\" class=\"headerlink\" title=\"copy ( source : Camera, recursive : Boolean )\"></a>copy ( source : Camera, recursive : Boolean )</h3><p>将源摄像头中的属性复制到此摄像头中</p>\n<h3 id=\"getWorldDirection-target-Vector3\"><a href=\"#getWorldDirection-target-Vector3\" class=\"headerlink\" title=\"getWorldDirection ( target : Vector3 )\"></a>getWorldDirection ( target : Vector3 )</h3><p>target - 结果将被复制到此Vector3中<br>返回表示摄像机正在查看的世界空间方向的Vector3</p>\n<h1 id=\"CubeCamera\"><a href=\"#CubeCamera\" class=\"headerlink\" title=\"CubeCamera\"></a>CubeCamera</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建6个渲染到<strong>WebGLRenderTargetCube</strong>的摄像机</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CubeCamera( near : Number, far : Number, cubeResolution : Number, options : Object )</span><br></pre></td></tr></table></figure>\n<p>near - 相机近剪裁距离<br>far - 相机远裁剪距离<br>cubeResolution - 设置立方体边缘的长度，体现为清晰度<br>options - （可选）保存传递给自动生成的WebGLRenderTargetCube的纹理参数的对象。 如果未指定，则选项默认为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;format：RGBFormat，magFilter：LinearFilter，minFilter：LinearFilter&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">构造一个包含6个PerspectiveCameras相机渲染到WebGLRenderTargetCube</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### renderTarget</span><br><span class=\"line\">生成的立方体纹理</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### update( renderer : WebGLRenderer, scene : Scene)</span><br><span class=\"line\"></span><br><span class=\"line\">调用它来更新renderTarget</span><br><span class=\"line\"></span><br><span class=\"line\">### clear( renderer : WebGLRenderer, color : Boolean, depth : Boolean, stencil : Boolean )</span><br><span class=\"line\">调用此方法以清除renderTarget颜色，深度和/或模板缓冲区。 颜色缓冲区设置为渲染器的当前清晰颜色。 参数默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"># OrthographicCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">在此投影模式下，无论距离相机的距离如何，渲染图像中的对象大小都保持不变</span><br><span class=\"line\">这对于渲染2D场景和UI元素等非常有用</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">left — 相机视锥体的左平面</span><br><span class=\"line\">right — 相机视锥体的右平面</span><br><span class=\"line\">top — 相机视锥体的上平面</span><br><span class=\"line\">bottom — 相机视锥体的下平面</span><br><span class=\"line\">near — 相机视锥体的近平面</span><br><span class=\"line\">far — 相机视锥体的原平面</span><br><span class=\"line\"></span><br><span class=\"line\">这些一起定义了[相机的视锥体](https://en.wikipedia.org/wiki/Viewing_frustum)</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### bottom</span><br><span class=\"line\">相机视锥体的下平面</span><br><span class=\"line\"></span><br><span class=\"line\">### far</span><br><span class=\"line\">相机视锥体的远平面。默认是2000</span><br><span class=\"line\">有效范围介于近平面和无穷远之间</span><br><span class=\"line\"></span><br><span class=\"line\">### isOrthographicCamera</span><br><span class=\"line\">用于检查此类或派生类是否为正交相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### left</span><br><span class=\"line\">相机视锥体的左平面</span><br><span class=\"line\"></span><br><span class=\"line\">### near</span><br><span class=\"line\">相机视锥体的近平面。默认是0.1</span><br><span class=\"line\">有效范围介于0和远平面</span><br><span class=\"line\"></span><br><span class=\"line\">### right</span><br><span class=\"line\">相机视锥体的右平面</span><br><span class=\"line\"></span><br><span class=\"line\">### top</span><br><span class=\"line\">相机视锥体的上平面</span><br><span class=\"line\"></span><br><span class=\"line\">### view</span><br><span class=\"line\">通过**setViewOffset**方法设置，默认是null</span><br><span class=\"line\"></span><br><span class=\"line\">### zoom</span><br><span class=\"line\">获取或设置摄像机的缩放系数, 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float )</span><br><span class=\"line\"></span><br><span class=\"line\">fullWidth - 多视图设置的全宽   </span><br><span class=\"line\">fullHeight - 多视图设置的全高  </span><br><span class=\"line\">x - 副摄像机的水平偏移   </span><br><span class=\"line\">y - 副摄像机的垂直偏移   </span><br><span class=\"line\">width - 副摄像机的宽度   </span><br><span class=\"line\">height - 副摄像机的高度  </span><br><span class=\"line\"> </span><br><span class=\"line\">### clearViewOffset ()</span><br><span class=\"line\">清除所有视图偏移</span><br><span class=\"line\"></span><br><span class=\"line\">### updateProjectionMatrix ()</span><br><span class=\"line\">更新相机投影矩阵，必须在参数发生变化后调用</span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ()</span><br><span class=\"line\">返回JSON格式的相机数据</span><br><span class=\"line\"></span><br><span class=\"line\"># PerspectiveCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">透视相机，这种投影模式旨在模仿人眼看到的方式，它是用于渲染3D场景的最常见投影模式。</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fov — 相机视锥体垂直视角  </span><br><span class=\"line\">aspect — 相机视锥体宽高比  </span><br><span class=\"line\">near — 相机视锥体近平面  </span><br><span class=\"line\">far — 相机视锥体远平面  </span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### aspect</span><br><span class=\"line\">相机视锥体宽高比，通常是画布宽度除以高度。默认是1</span><br><span class=\"line\"></span><br><span class=\"line\">### far</span><br><span class=\"line\">相机视锥体的远截平面。默认是2000。  </span><br><span class=\"line\">有效范围介于近平面和无穷远之间。</span><br><span class=\"line\"></span><br><span class=\"line\">### filmGauge</span><br><span class=\"line\">用于较大轴的胶片尺寸。 默认值为35（毫米）。 除非**filmOffset**设置为非零值，否则此参数不会影响投影矩阵。</span><br><span class=\"line\"></span><br><span class=\"line\">### filmOffset</span><br><span class=\"line\">与**filmGauge**相同单位的水平偏移，默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### focus</span><br><span class=\"line\">用于立体视觉和景深效果的物距。 除非使用**StereoCamera**，否则此参数不会影响投影矩阵。 默认值为10。</span><br><span class=\"line\"></span><br><span class=\"line\">### fov</span><br><span class=\"line\">相机视锥体垂直视野，从底部到顶部的视图的角度度。 默认值为50</span><br><span class=\"line\"></span><br><span class=\"line\">### isPerspectiveCamera</span><br><span class=\"line\">用于检查此类或派生类是否为透视相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### near</span><br><span class=\"line\">相机视锥体的近截平面。默认是0.1  </span><br><span class=\"line\">有效范围大于0且小于远平面</span><br><span class=\"line\"></span><br><span class=\"line\">### view</span><br><span class=\"line\">视锥体窗口规范或null。 这是使用**setViewOffset**方法设置的，并使用**clearViewOffset**清除。</span><br><span class=\"line\"></span><br><span class=\"line\">### zoom</span><br><span class=\"line\">获取或设置摄像机的缩放系数, 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### clearViewOffset ()</span><br><span class=\"line\">删除**setViewOffset**方法设置的任何偏移量</span><br><span class=\"line\"></span><br><span class=\"line\">### getEffectiveFOV()</span><br><span class=\"line\">返回乘以缩放系数 **zoom** 的当前视角，单位为角度（°）。</span><br><span class=\"line\"></span><br><span class=\"line\">### getFilmHeight()</span><br><span class=\"line\">返回胶片上图像的高度,如果.aspect小于或等于1（纵向格式），则结果等于**filmGauge**</span><br><span class=\"line\"></span><br><span class=\"line\">### getFilmWidth()</span><br><span class=\"line\">返回胶片上图像的宽度。 如果.aspect大于或等于1（横向格式），则结果等于**filmGauge**</span><br><span class=\"line\"></span><br><span class=\"line\">### getFocalLength ()</span><br><span class=\"line\">返回当前和 **filmGauge** 有关的 **fov** 的焦距</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### setFocalLength ( focalLength : Float )</span><br><span class=\"line\">设置当前和**filmGauge**有关的**fov**的焦距。</span><br><span class=\"line\">默认情况下，焦距为35mm全幅相机</span><br><span class=\"line\"></span><br><span class=\"line\">### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">fullWidth - 多视图设置的全宽   </span><br><span class=\"line\">fullHeight - 多视图设置的全高  </span><br><span class=\"line\">x - 副摄像机的水平偏移   </span><br><span class=\"line\">y - 副摄像机的垂直偏移   </span><br><span class=\"line\">width - 副摄像机的宽度   </span><br><span class=\"line\">height - 副摄像机的高度  </span><br><span class=\"line\"></span><br><span class=\"line\">该方法用于在一个较大的视椎体中设置视图偏移。这对于多窗口或多监视器/多机设置是有用的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.updateProjectionMatrix ()</span><br><span class=\"line\">更新相机投影矩阵，必须在参数发生变化后调用</span><br><span class=\"line\">### clone ()</span><br><span class=\"line\">返回一个 PerspectiveCamera 对象的克隆</span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ()</span><br><span class=\"line\">返回JSON格式的相机数据</span><br><span class=\"line\"></span><br><span class=\"line\"># StereoCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">立体相机。用于双透视相机，例如[3D Anaglyph](https://en.wikipedia.org/wiki/Anaglyph_3D)或者[Parallax Barrier](https://en.wikipedia.org/wiki/Parallax_barrier).</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>StereoCamera()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### aspect</span><br><span class=\"line\">相机视锥体宽高比，默认为1</span><br><span class=\"line\"></span><br><span class=\"line\">### eyeSep</span><br><span class=\"line\">默认0.064</span><br><span class=\"line\"></span><br><span class=\"line\">### cameraL</span><br><span class=\"line\">左相机。 这将添加到图层 - 左相机要渲染的对象也必须添加到此图层</span><br><span class=\"line\"></span><br><span class=\"line\">### cameraR</span><br><span class=\"line\">右相机。 这将添加到图层 - 右相机要渲染的对象也必须添加到此图层</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### update</span><br><span class=\"line\">根据传入的相机更新立体相机</span><br><span class=\"line\"></span><br><span class=\"line\"># ArrayCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">ArrayCamera使用预定义的一相机有效地渲染场景。 这对于渲染VR场景是重要性能考虑。</span><br><span class=\"line\">ArrayCamera的一个实例总是有一个子摄像头数组。 必须为每个子摄像机定义bounds属性，该属性确定使用此摄像机渲染的视口部分</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>ArrayCamera( array : Array )<br><code>`</code><br>相机数组</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"cameras\"><a href=\"#cameras\" class=\"headerlink\" title=\"cameras\"></a>cameras</h3><p>相机数组</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Camera\"><a href=\"#Camera\" class=\"headerlink\" title=\"Camera\"></a>Camera</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>相机的抽象类，新构建的相机都继承自此类</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>创建相机：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Camera()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"isCamera\"><a href=\"#isCamera\" class=\"headerlink\" title=\"isCamera\"></a>isCamera</h3><p>用于检查此类或派生类是否为相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</p>\n<h3 id=\"layers\"><a href=\"#layers\" class=\"headerlink\" title=\"layers\"></a>layers</h3><p>相机所属的layers  。 这是Object3D的继承属性。<br>在渲染相机的视点时，对象必须与相机共享至少一个图层。</p>\n<h3 id=\"matrixWorldInverse\"><a href=\"#matrixWorldInverse\" class=\"headerlink\" title=\"matrixWorldInverse\"></a>matrixWorldInverse</h3><p>这是matrixWorld的逆矩阵,matrixWorld包含相机在世界坐标系的变换矩阵</p>\n<h3 id=\"projectionMatrix\"><a href=\"#projectionMatrix\" class=\"headerlink\" title=\"projectionMatrix\"></a>projectionMatrix</h3><p>包含相机的投影矩阵</p>\n<h3 id=\"projectionMatrixInverse\"><a href=\"#projectionMatrixInverse\" class=\"headerlink\" title=\"projectionMatrixInverse\"></a>projectionMatrixInverse</h3><p>projectionMatrix的逆矩阵</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone()\"></a>clone()</h3><p>返回具有与此相同属性的新相机</p>\n<h3 id=\"copy-source-Camera-recursive-Boolean\"><a href=\"#copy-source-Camera-recursive-Boolean\" class=\"headerlink\" title=\"copy ( source : Camera, recursive : Boolean )\"></a>copy ( source : Camera, recursive : Boolean )</h3><p>将源摄像头中的属性复制到此摄像头中</p>\n<h3 id=\"getWorldDirection-target-Vector3\"><a href=\"#getWorldDirection-target-Vector3\" class=\"headerlink\" title=\"getWorldDirection ( target : Vector3 )\"></a>getWorldDirection ( target : Vector3 )</h3><p>target - 结果将被复制到此Vector3中<br>返回表示摄像机正在查看的世界空间方向的Vector3</p>\n<h1 id=\"CubeCamera\"><a href=\"#CubeCamera\" class=\"headerlink\" title=\"CubeCamera\"></a>CubeCamera</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建6个渲染到<strong>WebGLRenderTargetCube</strong>的摄像机</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CubeCamera( near : Number, far : Number, cubeResolution : Number, options : Object )</span><br></pre></td></tr></table></figure>\n<p>near - 相机近剪裁距离<br>far - 相机远裁剪距离<br>cubeResolution - 设置立方体边缘的长度，体现为清晰度<br>options - （可选）保存传递给自动生成的WebGLRenderTargetCube的纹理参数的对象。 如果未指定，则选项默认为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;format：RGBFormat，magFilter：LinearFilter，minFilter：LinearFilter&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">构造一个包含6个PerspectiveCameras相机渲染到WebGLRenderTargetCube</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### renderTarget</span><br><span class=\"line\">生成的立方体纹理</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### update( renderer : WebGLRenderer, scene : Scene)</span><br><span class=\"line\"></span><br><span class=\"line\">调用它来更新renderTarget</span><br><span class=\"line\"></span><br><span class=\"line\">### clear( renderer : WebGLRenderer, color : Boolean, depth : Boolean, stencil : Boolean )</span><br><span class=\"line\">调用此方法以清除renderTarget颜色，深度和/或模板缓冲区。 颜色缓冲区设置为渲染器的当前清晰颜色。 参数默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"># OrthographicCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">在此投影模式下，无论距离相机的距离如何，渲染图像中的对象大小都保持不变</span><br><span class=\"line\">这对于渲染2D场景和UI元素等非常有用</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>OrthographicCamera( left : Number, right : Number, top : Number, bottom : Number, near : Number, far : Number )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">left — 相机视锥体的左平面</span><br><span class=\"line\">right — 相机视锥体的右平面</span><br><span class=\"line\">top — 相机视锥体的上平面</span><br><span class=\"line\">bottom — 相机视锥体的下平面</span><br><span class=\"line\">near — 相机视锥体的近平面</span><br><span class=\"line\">far — 相机视锥体的原平面</span><br><span class=\"line\"></span><br><span class=\"line\">这些一起定义了[相机的视锥体](https://en.wikipedia.org/wiki/Viewing_frustum)</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### bottom</span><br><span class=\"line\">相机视锥体的下平面</span><br><span class=\"line\"></span><br><span class=\"line\">### far</span><br><span class=\"line\">相机视锥体的远平面。默认是2000</span><br><span class=\"line\">有效范围介于近平面和无穷远之间</span><br><span class=\"line\"></span><br><span class=\"line\">### isOrthographicCamera</span><br><span class=\"line\">用于检查此类或派生类是否为正交相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### left</span><br><span class=\"line\">相机视锥体的左平面</span><br><span class=\"line\"></span><br><span class=\"line\">### near</span><br><span class=\"line\">相机视锥体的近平面。默认是0.1</span><br><span class=\"line\">有效范围介于0和远平面</span><br><span class=\"line\"></span><br><span class=\"line\">### right</span><br><span class=\"line\">相机视锥体的右平面</span><br><span class=\"line\"></span><br><span class=\"line\">### top</span><br><span class=\"line\">相机视锥体的上平面</span><br><span class=\"line\"></span><br><span class=\"line\">### view</span><br><span class=\"line\">通过**setViewOffset**方法设置，默认是null</span><br><span class=\"line\"></span><br><span class=\"line\">### zoom</span><br><span class=\"line\">获取或设置摄像机的缩放系数, 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float )</span><br><span class=\"line\"></span><br><span class=\"line\">fullWidth - 多视图设置的全宽   </span><br><span class=\"line\">fullHeight - 多视图设置的全高  </span><br><span class=\"line\">x - 副摄像机的水平偏移   </span><br><span class=\"line\">y - 副摄像机的垂直偏移   </span><br><span class=\"line\">width - 副摄像机的宽度   </span><br><span class=\"line\">height - 副摄像机的高度  </span><br><span class=\"line\"> </span><br><span class=\"line\">### clearViewOffset ()</span><br><span class=\"line\">清除所有视图偏移</span><br><span class=\"line\"></span><br><span class=\"line\">### updateProjectionMatrix ()</span><br><span class=\"line\">更新相机投影矩阵，必须在参数发生变化后调用</span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ()</span><br><span class=\"line\">返回JSON格式的相机数据</span><br><span class=\"line\"></span><br><span class=\"line\"># PerspectiveCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">透视相机，这种投影模式旨在模仿人眼看到的方式，它是用于渲染3D场景的最常见投影模式。</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fov — 相机视锥体垂直视角  </span><br><span class=\"line\">aspect — 相机视锥体宽高比  </span><br><span class=\"line\">near — 相机视锥体近平面  </span><br><span class=\"line\">far — 相机视锥体远平面  </span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### aspect</span><br><span class=\"line\">相机视锥体宽高比，通常是画布宽度除以高度。默认是1</span><br><span class=\"line\"></span><br><span class=\"line\">### far</span><br><span class=\"line\">相机视锥体的远截平面。默认是2000。  </span><br><span class=\"line\">有效范围介于近平面和无穷远之间。</span><br><span class=\"line\"></span><br><span class=\"line\">### filmGauge</span><br><span class=\"line\">用于较大轴的胶片尺寸。 默认值为35（毫米）。 除非**filmOffset**设置为非零值，否则此参数不会影响投影矩阵。</span><br><span class=\"line\"></span><br><span class=\"line\">### filmOffset</span><br><span class=\"line\">与**filmGauge**相同单位的水平偏移，默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### focus</span><br><span class=\"line\">用于立体视觉和景深效果的物距。 除非使用**StereoCamera**，否则此参数不会影响投影矩阵。 默认值为10。</span><br><span class=\"line\"></span><br><span class=\"line\">### fov</span><br><span class=\"line\">相机视锥体垂直视野，从底部到顶部的视图的角度度。 默认值为50</span><br><span class=\"line\"></span><br><span class=\"line\">### isPerspectiveCamera</span><br><span class=\"line\">用于检查此类或派生类是否为透视相机。 不应该更改此属性，因为渲染器在内部使用它进行优化。默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### near</span><br><span class=\"line\">相机视锥体的近截平面。默认是0.1  </span><br><span class=\"line\">有效范围大于0且小于远平面</span><br><span class=\"line\"></span><br><span class=\"line\">### view</span><br><span class=\"line\">视锥体窗口规范或null。 这是使用**setViewOffset**方法设置的，并使用**clearViewOffset**清除。</span><br><span class=\"line\"></span><br><span class=\"line\">### zoom</span><br><span class=\"line\">获取或设置摄像机的缩放系数, 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### clearViewOffset ()</span><br><span class=\"line\">删除**setViewOffset**方法设置的任何偏移量</span><br><span class=\"line\"></span><br><span class=\"line\">### getEffectiveFOV()</span><br><span class=\"line\">返回乘以缩放系数 **zoom** 的当前视角，单位为角度（°）。</span><br><span class=\"line\"></span><br><span class=\"line\">### getFilmHeight()</span><br><span class=\"line\">返回胶片上图像的高度,如果.aspect小于或等于1（纵向格式），则结果等于**filmGauge**</span><br><span class=\"line\"></span><br><span class=\"line\">### getFilmWidth()</span><br><span class=\"line\">返回胶片上图像的宽度。 如果.aspect大于或等于1（横向格式），则结果等于**filmGauge**</span><br><span class=\"line\"></span><br><span class=\"line\">### getFocalLength ()</span><br><span class=\"line\">返回当前和 **filmGauge** 有关的 **fov** 的焦距</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### setFocalLength ( focalLength : Float )</span><br><span class=\"line\">设置当前和**filmGauge**有关的**fov**的焦距。</span><br><span class=\"line\">默认情况下，焦距为35mm全幅相机</span><br><span class=\"line\"></span><br><span class=\"line\">### setViewOffset ( fullWidth : Float, fullHeight : Float, x : Float, y : Float, width : Float, height : Float ) </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">fullWidth - 多视图设置的全宽   </span><br><span class=\"line\">fullHeight - 多视图设置的全高  </span><br><span class=\"line\">x - 副摄像机的水平偏移   </span><br><span class=\"line\">y - 副摄像机的垂直偏移   </span><br><span class=\"line\">width - 副摄像机的宽度   </span><br><span class=\"line\">height - 副摄像机的高度  </span><br><span class=\"line\"></span><br><span class=\"line\">该方法用于在一个较大的视椎体中设置视图偏移。这对于多窗口或多监视器/多机设置是有用的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.updateProjectionMatrix ()</span><br><span class=\"line\">更新相机投影矩阵，必须在参数发生变化后调用</span><br><span class=\"line\">### clone ()</span><br><span class=\"line\">返回一个 PerspectiveCamera 对象的克隆</span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ()</span><br><span class=\"line\">返回JSON格式的相机数据</span><br><span class=\"line\"></span><br><span class=\"line\"># StereoCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">立体相机。用于双透视相机，例如[3D Anaglyph](https://en.wikipedia.org/wiki/Anaglyph_3D)或者[Parallax Barrier](https://en.wikipedia.org/wiki/Parallax_barrier).</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>StereoCamera()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### aspect</span><br><span class=\"line\">相机视锥体宽高比，默认为1</span><br><span class=\"line\"></span><br><span class=\"line\">### eyeSep</span><br><span class=\"line\">默认0.064</span><br><span class=\"line\"></span><br><span class=\"line\">### cameraL</span><br><span class=\"line\">左相机。 这将添加到图层 - 左相机要渲染的对象也必须添加到此图层</span><br><span class=\"line\"></span><br><span class=\"line\">### cameraR</span><br><span class=\"line\">右相机。 这将添加到图层 - 右相机要渲染的对象也必须添加到此图层</span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### update</span><br><span class=\"line\">根据传入的相机更新立体相机</span><br><span class=\"line\"></span><br><span class=\"line\"># ArrayCamera</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">ArrayCamera使用预定义的一相机有效地渲染场景。 这对于渲染VR场景是重要性能考虑。</span><br><span class=\"line\">ArrayCamera的一个实例总是有一个子摄像头数组。 必须为每个子摄像机定义bounds属性，该属性确定使用此摄像机渲染的视口部分</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>ArrayCamera( array : Array )<br><code>`</code><br>相机数组</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"cameras\"><a href=\"#cameras\" class=\"headerlink\" title=\"cameras\"></a>cameras</h3><p>相机数组</p>\n"},{"title":"threejs 解读  material","_content":"\n# LineBasicMaterial\n\n## 概念\n用于绘制线框样式几何图形的材质  \n\n\n## 使用\n```\nLineBasicMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n## 属性\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### isLineBasicMaterial : Boolean\n用于检查此类或派生类是否为行基本材质。 默认为true。  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材料是否受灯光影响。 默认值为false\n\n### linewidth : Float\n控制线条粗细。 默认值为1  \n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  \n\n### linecap : String\n定义线端的外观。 可能的值是'butt'，'round'和'square'。 默认为'round'.  \n对于2D Canvas lineCap属性，WebGL渲染器会忽略该属性  \n\n### linejoin : String\n定义线关节的连接点。 可能的值是'round'，'bevel'和'miter'。 默认为'round'  \n对于2D Canvas lineJoin属性，WebGL渲染器会忽略该属性   \n\n\n# LineDashedMaterial\n## 概念\n用虚线绘制线框样式几何图形的材质\n\n## 使用\n```\nLineBDashedMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n\n## 属性\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### dashSize : number  \n短划线的大小, 默认值为3。\n\n### gapSize : number\n短划线间隙的大小, 默认值为1\n\n### isLineDashedMaterial : Boolean\n用于检查此类或派生类是否为行基本材质。 默认为true。  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材料是否受灯光影响。 默认值为false\n\n### linewidth : Float\n控制线条粗细。 默认值为1  \n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  \n\n### scale : number\n线的虚线部分的比例。 默认值为1。\n\n\n# Material\n## 概念\n\n材料的基础抽象类  \n\n材质描述了对象的外观。 它们以（主要）与渲染器无关的方式定义，因此如果您决定使用不同的渲染器，则不必重写材质。\n\n所有其他材质类型都继承了该类的属性和方法（尽管它们可能具有不同的默认值）\n\n## 使用\n\n```\nMaterial()\n```\n\n创建通用材质\n\n## 属性\n### alphaTest : Float\n设置运行alpha测试时要使用的alpha值。 如果不透明度低于此值，则不会渲染材质。 默认值为0  \n\n### blendDst : Integer\n混合目标。这是Three.js中定义的一个混合模式常量。默认为 OneMinusSrcAlphaFactor  \n必须将材质blending设置为CustomBlending才能生效  \n\n### blendDstAlpha : Integer\nblendDst的透明度。 默认值为null\n\n### blendEquation : Integer \n应用混合时所用的混合方程式。这是Three.js中定义的一个常量。 默认为 AddEquation  \n必须将材质blending设置为CustomBlending才能生效   \n\n### blendEquationAlpha : Integer\nblendEquation的透明度。 默认值为null\n\n### blending : Blending\n当显示该材质的对象时使用何种混合模式， 必须将其设置为CustomBlending才能使用自定义blendSrc，blendDst或blendEquation，默认为 NormalBlending  \n\n### blendSrc : Integer\n混合来源。 默认为SrcAlphaFactor  \n必须将材质的混合设置为CustomBlending才能生效  \n\n### blendSrcAlpha : Integer\nblendSrc的透明度。 默认值为null  \n\n### clipIntersection : Boolean \n更改剪裁平面的方式，仅剪切其交交集，而不是它们的并集。 默认值为false  \n\n### clippingPlanes : Array  \n用户定义的剪裁平,指定为世界空间中的THREE.Plane对象。 这些平面适用于此材质所附着的对象。 空间中与平面的符号距离为负的点被剪裁（未渲染）。 这需要WebGLRenderer.localClippingEnabled为true。 默认值为null。\n\n### clipShadows : Boolean\n定义是否根据此材质上指定的剪裁平面剪切阴影。 默认值为false\n\n### colorWrite : Boolean\n是否渲染材质的颜色。 这可以与网格renderOrde属性结合使用，以创建遮挡其他对象的不可见对象，默认为true \n\n### customDepthMaterial : Material\n渲染到深度贴图时此材质要使用的通用深度材质。 当使用DirectionalLight或SpotLight进行阴影投射时，如果您是  \n（a）修改顶点着色器中的顶点位置，  \n（b）使用置换贴图，  \n（c）使用带alphaTest的alpha贴图  \n（d）使用透明纹理 使用alphaTest  \n必须为正确的阴影指定customDepthMaterial。 默认值undefined  \n\ncustomDistanceMaterial : Material  \n与customDepthMaterial相同，但与PointLight一起使用。 默认值undefined  \n\n### defines : Object  \n\n注入着色器的自定义定义。 它们以对象键/值对传递。 ```{MY_CUSTOM_DEFINE：''，PI2：Math.PI * 2}```。 这些键/值对在顶点和片段着色器中定义。 默认值undefined \n\n### depthFunc : Integer\n使用哪种深度功能。 默认值为LessEqualDepth \n\n### depthTest : Boolean\n是否在渲染此材质时启用深度测试。 默认为true\n\n### depthWrite : Boolean\n渲染此材质是否对深度缓冲区有任何影响。 默认为true   \n在绘制2D叠加时，禁用深度写入以将多个事物分层在一起而不创建z-index伪像会很有用 \n\n### flatShading : Boolean\n定义材质是否使用平面阴影进行渲染。 默认值为false   \n\n### fog : Boolean\n材料是否受场景中fog的影响。 默认为true \n\n### id : Integer\n此材质实例的唯一编号  \n\nisMaterial : Boolean\n\n用于检查此类或派生类是否为material。 默认为true,  \n不应该更改它，因为它在内部用于优化  \n\n### lights : Boolean\n材质是否受光照影响，默认是true\n\n### name : String\n对象的可选名称（不必是唯一的）。 默认值为空字符串  \n\n### needsUpdate : Boolean\n指定需要重新编译材质  \n实例化新材料时，此属性自动设置为true\n\n### opacity : Float  \n值得范围在0.0 - 1.0之间，表示材料的透明度。 值0.0表示完全透明，1.0表示完全不透明，  \n如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色   \n默认值为1.0\n\n### polygonOffset : Boolean\n是否使用多边形偏移。 默认值为false。 这对应于WebGL的GL_POLYGON_OFFSET_FILL 功能。\n\n\n### polygonOffsetFactor : Integer\n设置多边形偏移系数。 默认值为0\n\n### polygonOffsetUnits : Integer\n设置多边形偏移单位。 默认值为0\n\n### precision : String\n覆盖此材质的渲染器的默认精度。 可以是“highp”，“mediump”或“lowp”。 默认值为null\n\n### premultipliedAlpha : Boolean \n是否预乘alpha（透明度）值。 默认值为false \n\n### dithering : Boolean\n是否对颜色应用抖动以消除条带的外观。 默认值为false\n\n### shadowSide : Integer\n定义面部投射阴影的哪一侧。 设置时，可以是THREE.FrontSide，THREE.BackSide或THREE.DoubleSide。 默认值为null。\n如果为null，则侧面投射阴影确定如下: \n\nMaterial.side    | Side casting shadows\n-------------    | -------------\nTHREE.FrontSide  | back side\nTHREE.BackSide   | front side\nTHREE.DoubleSide | both side\n\n### side : Integer\n定义将要渲染面部的哪一面 - 正面，背面或两者。 默认为THREE.FrontSide, 其他选项有THREE.BackSide和THREE.DoubleSide  \n\n### transparent : Boolean\n定义此材质是否透明。 这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后呈现  \n设置为true时，通过设置材质的不透明度属性来控制材质透明的程度  \n默认值为false \n\n### type : String  \n值是字符串'Material'。 这不应该更改，并且可以用于在场景中查找此类型的所有对象  \n\n\n### uuid : String\n此材质实例的UUID。 这会自动分配，因此不应编辑\n\n### vertexColors : Integer\n定义是否使用顶点着色。 默认值为THREE.NoColors。 其他选项有THREE.VertexColors和THREE.FaceColors。\n\n### visible : Boolean\n定义此材质是否可见。 默认为true。\n\n### userData : object\n可用于存储有关Material的自定义数据的对象。 它不应该包含对函数的引用，因为这些函数不会被克隆  \n\n##  方法\n### clone ( ) : Material \n返回与此材质具有相同参数的新材质\n\n### copy ( material : material ) : Material\n将传递材质中的参数复制到此材质中\n\n### dispose () : null\n释放材质。 材质的纹理不会被释放。 这些需要通过Texture释放  \n\n### onBeforeCompile ( shader : Object, renderer : WebGLRenderer ) : null\n在编译着色器程序之前立即执行的可选回调。 使用着色器源代码作为参数调用此函数。 用于修改内置材料 \n\n### setValues ( values : object ) : null\nvalues - 具有参数的容器  \n根据值设置属性  \n\n### toJSON ( meta : object ) : null\n元对象，包含元素，例如材质的纹理或图像。\n将材质转换为three.js JSON格式\n\n\n# MeshBasicMaterial\n## 概念\n以简单着色（平面或线框）方式来绘制几何形状的材料  \n这种材质不受光照影响  \n\n## 使用\n```\nMeshBasicMaterial( parameters : Object )\n```\n\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n### aoMap : Texture\n该纹理的红色通道用作环境遮挡贴图。 默认值为null。  \n aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n \n### aoMapIntensity : Float\n环境遮挡效应的强度。 默认值为1.零 不遮挡效果\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### combine : Integer\n如何将表面颜色的结果与环境贴图（如果有）结合起来  \n选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合\n\n### isMeshBasicMaterial : Boolean\n用于检查此类或派生类是否为网格基础材质。 默认为true。\n不应该更改它，因为它在内部用于优化。\n\n### envMap : TextureCube\n环境贴图。 默认值为null\n\n### lightMap : Texture\n光照贴图。 默认值为null, \nlightMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n\n### lightMapIntensity : Float\n烤光的强度。 默认值为1\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### map : Texture\n颜色贴图, 默认值为null\n\n### .morphTargets : Boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### reflectivity : Float\n环境贴图对表面的影响程度。 默认值为1，有效范围介于0（无反射）和1（完全反射）之间\n\n### refractionRatio : Float\n空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false\n\n### specularMap : Texture\n材质使用的高光贴图。 默认值为null\n\n### wireframe : Boolean\n将几何图形渲染为线框。 默认值为false（即渲染为平面多边形）\n\n### wireframeLinecap : String\n定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为'round'。\n\n这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它\n\n### wireframeLinejoin : String\n定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为'round'。\n\n这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n# MeshDepthMaterial\n## 概念\n 用于按深度绘制几何图形的材质。 深度基于相机近远平面。 白色最近，黑色最远\n \n## 使用\n```\nMeshDepthMaterial( parameters : Object )\n```\n\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递\n\n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n\n### depthPacking : Constant\n用于深度包装的编码, 默认为BasicDepthPacking\n\n### displacementMap : Texture\n置换贴图会影响网格顶点的位置。 与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象，以及充当真实的几何体。 位移纹理是这样的图像，其中每个像素的值（白色是最高的）被映射，并且重新定位网格的顶点。\n\n### displacementScale : Float\n置换贴图对网格的影响程度（黑色是不位移，白色是最大位移）。 如果没有设置置换贴图，则不会应用此值。 默认值为1。\n\n### displacementBias : Float\n位移贴图在网格顶点上的偏移量。 如果没有设置置换贴图，则不会应用此值。 默认值为0。\n\n### fog : Boolean\n材质是否受场景中fog影响。 默认值为false\n\n### isMeshDepthMaterial : Boolean\n\n用于检查此类或派生类是否为网格深度材质。 默认为true  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### map : Texture\n颜色贴图，默认为null\n\n### morphTargets : boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n\n# MeshLambertMaterial\n## 概念\n用于非光泽表面的材料，没有镜面高光  \n该材料使用基于非物理的朗伯模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）   \n使用Gouraud着色模型计算着色。 这将计算每个顶点的着色（即在顶点着色器中）并在多边形的面上插入结果。\n由于反射率和照明模型的简单性，当使用这种材料而不是MeshPhongMaterial，MeshStandardMaterial或MeshPhysicalMaterial时，性能会更高，但可能影响某些图形精度\n\n## 使用\n```\nMeshLambertMaterial( parameters : Object )\n```  \nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用 \n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n### aoMap : Texture\n该纹理的红色通道用作环境遮挡贴图。 默认值为null。  \n aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n \n### aoMapIntensity : Float\n环境遮挡效应的强度。 默认值为1.零 不遮挡效果\n\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### combine : Integer\n如何将表面颜色的结果与环境贴图（如果有）结合起来  \n选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合\n\n### emissive : Color\n材料的发光颜色，基本上是不受其他照明影响的纯色。 默认为黑色。\n\n### emissiveMap : Texture\n设置自发光（发光）贴图。 默认值为null。 发射性地图颜色由发射颜色和发射强度调制。 如果您有自发光贴图，请务必将发光颜色设置为黑色以外的其他颜色 \n\n### emissiveIntensity : Float\n发射光的强度。 调节发光颜色。 默认值为1\n\n### envMap : TextureCube\n环境贴图。 默认值为null\n\n### isMeshLambertMaterial : Boolean\n用于检查此类或派生类是否为网格Lambert材质。 默认为true。\n不应该更改它，因为它在内部用于优化\n\n### lightMap : Texture\n光照贴图。 默认值为null。 lightMap需要第二组UV，因此将忽略重复和偏移纹理属性\n\n\n### lightMapIntensity : Float\n烤光的强度。 默认值为1\n\n### .map : Texture\n色彩贴图，默认为null\n\n\n### morphNormals : boolean\n定义材质是否使用morphNormals。 设置为true可将morphNormal属性从Geometry传递到着色器。 默认值为false\n\n### morphTargets : Boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### reflectivity : Float\n环境贴图对几何表面的影响程度\n\n### refractionRatio : Float\n空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。\n\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false。\n\n### specularMap : Texture\n材质使用的高光贴图。 默认值为null。\n\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n\n### wireframeLinecap : String\n定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为'round'。\n\n这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它\n\n### wireframeLinejoin : String\n定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为'round'。\n\n这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n\n\n# MeshNormalMaterial\n## 概念\n将法线矢量映射到RGB颜色的材质\n\n## 使用\n```\nMeshNormalMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n## 属性\n### fog : Boolean\n材质是否受场景中fog影响。 默认值为false\n\n### isMeshNormalMaterial : Boolean\n用于检查此类或派生类是否为MeshNormalMaterial材质。 默认为true  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### morphTargets : boolean\n定义材质是否使用morphTargets, 默认值为false\n\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n","source":"_posts/threejs 解读 materilas.md","raw":"title:      \"threejs 解读  material\"\ntags:\n    - js threejs\n---\n\n# LineBasicMaterial\n\n## 概念\n用于绘制线框样式几何图形的材质  \n\n\n## 使用\n```\nLineBasicMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n## 属性\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### isLineBasicMaterial : Boolean\n用于检查此类或派生类是否为行基本材质。 默认为true。  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材料是否受灯光影响。 默认值为false\n\n### linewidth : Float\n控制线条粗细。 默认值为1  \n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  \n\n### linecap : String\n定义线端的外观。 可能的值是'butt'，'round'和'square'。 默认为'round'.  \n对于2D Canvas lineCap属性，WebGL渲染器会忽略该属性  \n\n### linejoin : String\n定义线关节的连接点。 可能的值是'round'，'bevel'和'miter'。 默认为'round'  \n对于2D Canvas lineJoin属性，WebGL渲染器会忽略该属性   \n\n\n# LineDashedMaterial\n## 概念\n用虚线绘制线框样式几何图形的材质\n\n## 使用\n```\nLineBDashedMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n\n## 属性\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### dashSize : number  \n短划线的大小, 默认值为3。\n\n### gapSize : number\n短划线间隙的大小, 默认值为1\n\n### isLineDashedMaterial : Boolean\n用于检查此类或派生类是否为行基本材质。 默认为true。  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材料是否受灯光影响。 默认值为false\n\n### linewidth : Float\n控制线条粗细。 默认值为1  \n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  \n\n### scale : number\n线的虚线部分的比例。 默认值为1。\n\n\n# Material\n## 概念\n\n材料的基础抽象类  \n\n材质描述了对象的外观。 它们以（主要）与渲染器无关的方式定义，因此如果您决定使用不同的渲染器，则不必重写材质。\n\n所有其他材质类型都继承了该类的属性和方法（尽管它们可能具有不同的默认值）\n\n## 使用\n\n```\nMaterial()\n```\n\n创建通用材质\n\n## 属性\n### alphaTest : Float\n设置运行alpha测试时要使用的alpha值。 如果不透明度低于此值，则不会渲染材质。 默认值为0  \n\n### blendDst : Integer\n混合目标。这是Three.js中定义的一个混合模式常量。默认为 OneMinusSrcAlphaFactor  \n必须将材质blending设置为CustomBlending才能生效  \n\n### blendDstAlpha : Integer\nblendDst的透明度。 默认值为null\n\n### blendEquation : Integer \n应用混合时所用的混合方程式。这是Three.js中定义的一个常量。 默认为 AddEquation  \n必须将材质blending设置为CustomBlending才能生效   \n\n### blendEquationAlpha : Integer\nblendEquation的透明度。 默认值为null\n\n### blending : Blending\n当显示该材质的对象时使用何种混合模式， 必须将其设置为CustomBlending才能使用自定义blendSrc，blendDst或blendEquation，默认为 NormalBlending  \n\n### blendSrc : Integer\n混合来源。 默认为SrcAlphaFactor  \n必须将材质的混合设置为CustomBlending才能生效  \n\n### blendSrcAlpha : Integer\nblendSrc的透明度。 默认值为null  \n\n### clipIntersection : Boolean \n更改剪裁平面的方式，仅剪切其交交集，而不是它们的并集。 默认值为false  \n\n### clippingPlanes : Array  \n用户定义的剪裁平,指定为世界空间中的THREE.Plane对象。 这些平面适用于此材质所附着的对象。 空间中与平面的符号距离为负的点被剪裁（未渲染）。 这需要WebGLRenderer.localClippingEnabled为true。 默认值为null。\n\n### clipShadows : Boolean\n定义是否根据此材质上指定的剪裁平面剪切阴影。 默认值为false\n\n### colorWrite : Boolean\n是否渲染材质的颜色。 这可以与网格renderOrde属性结合使用，以创建遮挡其他对象的不可见对象，默认为true \n\n### customDepthMaterial : Material\n渲染到深度贴图时此材质要使用的通用深度材质。 当使用DirectionalLight或SpotLight进行阴影投射时，如果您是  \n（a）修改顶点着色器中的顶点位置，  \n（b）使用置换贴图，  \n（c）使用带alphaTest的alpha贴图  \n（d）使用透明纹理 使用alphaTest  \n必须为正确的阴影指定customDepthMaterial。 默认值undefined  \n\ncustomDistanceMaterial : Material  \n与customDepthMaterial相同，但与PointLight一起使用。 默认值undefined  \n\n### defines : Object  \n\n注入着色器的自定义定义。 它们以对象键/值对传递。 ```{MY_CUSTOM_DEFINE：''，PI2：Math.PI * 2}```。 这些键/值对在顶点和片段着色器中定义。 默认值undefined \n\n### depthFunc : Integer\n使用哪种深度功能。 默认值为LessEqualDepth \n\n### depthTest : Boolean\n是否在渲染此材质时启用深度测试。 默认为true\n\n### depthWrite : Boolean\n渲染此材质是否对深度缓冲区有任何影响。 默认为true   \n在绘制2D叠加时，禁用深度写入以将多个事物分层在一起而不创建z-index伪像会很有用 \n\n### flatShading : Boolean\n定义材质是否使用平面阴影进行渲染。 默认值为false   \n\n### fog : Boolean\n材料是否受场景中fog的影响。 默认为true \n\n### id : Integer\n此材质实例的唯一编号  \n\nisMaterial : Boolean\n\n用于检查此类或派生类是否为material。 默认为true,  \n不应该更改它，因为它在内部用于优化  \n\n### lights : Boolean\n材质是否受光照影响，默认是true\n\n### name : String\n对象的可选名称（不必是唯一的）。 默认值为空字符串  \n\n### needsUpdate : Boolean\n指定需要重新编译材质  \n实例化新材料时，此属性自动设置为true\n\n### opacity : Float  \n值得范围在0.0 - 1.0之间，表示材料的透明度。 值0.0表示完全透明，1.0表示完全不透明，  \n如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色   \n默认值为1.0\n\n### polygonOffset : Boolean\n是否使用多边形偏移。 默认值为false。 这对应于WebGL的GL_POLYGON_OFFSET_FILL 功能。\n\n\n### polygonOffsetFactor : Integer\n设置多边形偏移系数。 默认值为0\n\n### polygonOffsetUnits : Integer\n设置多边形偏移单位。 默认值为0\n\n### precision : String\n覆盖此材质的渲染器的默认精度。 可以是“highp”，“mediump”或“lowp”。 默认值为null\n\n### premultipliedAlpha : Boolean \n是否预乘alpha（透明度）值。 默认值为false \n\n### dithering : Boolean\n是否对颜色应用抖动以消除条带的外观。 默认值为false\n\n### shadowSide : Integer\n定义面部投射阴影的哪一侧。 设置时，可以是THREE.FrontSide，THREE.BackSide或THREE.DoubleSide。 默认值为null。\n如果为null，则侧面投射阴影确定如下: \n\nMaterial.side    | Side casting shadows\n-------------    | -------------\nTHREE.FrontSide  | back side\nTHREE.BackSide   | front side\nTHREE.DoubleSide | both side\n\n### side : Integer\n定义将要渲染面部的哪一面 - 正面，背面或两者。 默认为THREE.FrontSide, 其他选项有THREE.BackSide和THREE.DoubleSide  \n\n### transparent : Boolean\n定义此材质是否透明。 这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后呈现  \n设置为true时，通过设置材质的不透明度属性来控制材质透明的程度  \n默认值为false \n\n### type : String  \n值是字符串'Material'。 这不应该更改，并且可以用于在场景中查找此类型的所有对象  \n\n\n### uuid : String\n此材质实例的UUID。 这会自动分配，因此不应编辑\n\n### vertexColors : Integer\n定义是否使用顶点着色。 默认值为THREE.NoColors。 其他选项有THREE.VertexColors和THREE.FaceColors。\n\n### visible : Boolean\n定义此材质是否可见。 默认为true。\n\n### userData : object\n可用于存储有关Material的自定义数据的对象。 它不应该包含对函数的引用，因为这些函数不会被克隆  \n\n##  方法\n### clone ( ) : Material \n返回与此材质具有相同参数的新材质\n\n### copy ( material : material ) : Material\n将传递材质中的参数复制到此材质中\n\n### dispose () : null\n释放材质。 材质的纹理不会被释放。 这些需要通过Texture释放  \n\n### onBeforeCompile ( shader : Object, renderer : WebGLRenderer ) : null\n在编译着色器程序之前立即执行的可选回调。 使用着色器源代码作为参数调用此函数。 用于修改内置材料 \n\n### setValues ( values : object ) : null\nvalues - 具有参数的容器  \n根据值设置属性  \n\n### toJSON ( meta : object ) : null\n元对象，包含元素，例如材质的纹理或图像。\n将材质转换为three.js JSON格式\n\n\n# MeshBasicMaterial\n## 概念\n以简单着色（平面或线框）方式来绘制几何形状的材料  \n这种材质不受光照影响  \n\n## 使用\n```\nMeshBasicMaterial( parameters : Object )\n```\n\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。\n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n### aoMap : Texture\n该纹理的红色通道用作环境遮挡贴图。 默认值为null。  \n aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n \n### aoMapIntensity : Float\n环境遮挡效应的强度。 默认值为1.零 不遮挡效果\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### combine : Integer\n如何将表面颜色的结果与环境贴图（如果有）结合起来  \n选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合\n\n### isMeshBasicMaterial : Boolean\n用于检查此类或派生类是否为网格基础材质。 默认为true。\n不应该更改它，因为它在内部用于优化。\n\n### envMap : TextureCube\n环境贴图。 默认值为null\n\n### lightMap : Texture\n光照贴图。 默认值为null, \nlightMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n\n### lightMapIntensity : Float\n烤光的强度。 默认值为1\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### map : Texture\n颜色贴图, 默认值为null\n\n### .morphTargets : Boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### reflectivity : Float\n环境贴图对表面的影响程度。 默认值为1，有效范围介于0（无反射）和1（完全反射）之间\n\n### refractionRatio : Float\n空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false\n\n### specularMap : Texture\n材质使用的高光贴图。 默认值为null\n\n### wireframe : Boolean\n将几何图形渲染为线框。 默认值为false（即渲染为平面多边形）\n\n### wireframeLinecap : String\n定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为'round'。\n\n这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它\n\n### wireframeLinejoin : String\n定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为'round'。\n\n这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n# MeshDepthMaterial\n## 概念\n 用于按深度绘制几何图形的材质。 深度基于相机近远平面。 白色最近，黑色最远\n \n## 使用\n```\nMeshDepthMaterial( parameters : Object )\n```\n\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递\n\n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n\n### depthPacking : Constant\n用于深度包装的编码, 默认为BasicDepthPacking\n\n### displacementMap : Texture\n置换贴图会影响网格顶点的位置。 与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象，以及充当真实的几何体。 位移纹理是这样的图像，其中每个像素的值（白色是最高的）被映射，并且重新定位网格的顶点。\n\n### displacementScale : Float\n置换贴图对网格的影响程度（黑色是不位移，白色是最大位移）。 如果没有设置置换贴图，则不会应用此值。 默认值为1。\n\n### displacementBias : Float\n位移贴图在网格顶点上的偏移量。 如果没有设置置换贴图，则不会应用此值。 默认值为0。\n\n### fog : Boolean\n材质是否受场景中fog影响。 默认值为false\n\n### isMeshDepthMaterial : Boolean\n\n用于检查此类或派生类是否为网格深度材质。 默认为true  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### map : Texture\n颜色贴图，默认为null\n\n### morphTargets : boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n\n# MeshLambertMaterial\n## 概念\n用于非光泽表面的材料，没有镜面高光  \n该材料使用基于非物理的朗伯模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）   \n使用Gouraud着色模型计算着色。 这将计算每个顶点的着色（即在顶点着色器中）并在多边形的面上插入结果。\n由于反射率和照明模型的简单性，当使用这种材料而不是MeshPhongMaterial，MeshStandardMaterial或MeshPhysicalMaterial时，性能会更高，但可能影响某些图形精度\n\n## 使用\n```\nMeshLambertMaterial( parameters : Object )\n```  \nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用 \n\n## 属性\n### alphaMap : Texture\nalpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。\n\n仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。\n\n### aoMap : Texture\n该纹理的红色通道用作环境遮挡贴图。 默认值为null。  \n aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。\n \n### aoMapIntensity : Float\n环境遮挡效应的强度。 默认值为1.零 不遮挡效果\n\n\n### color : Color\n材质的颜色，默认设置为白色（0xffffff）\n\n### combine : Integer\n如何将表面颜色的结果与环境贴图（如果有）结合起来  \n选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合\n\n### emissive : Color\n材料的发光颜色，基本上是不受其他照明影响的纯色。 默认为黑色。\n\n### emissiveMap : Texture\n设置自发光（发光）贴图。 默认值为null。 发射性地图颜色由发射颜色和发射强度调制。 如果您有自发光贴图，请务必将发光颜色设置为黑色以外的其他颜色 \n\n### emissiveIntensity : Float\n发射光的强度。 调节发光颜色。 默认值为1\n\n### envMap : TextureCube\n环境贴图。 默认值为null\n\n### isMeshLambertMaterial : Boolean\n用于检查此类或派生类是否为网格Lambert材质。 默认为true。\n不应该更改它，因为它在内部用于优化\n\n### lightMap : Texture\n光照贴图。 默认值为null。 lightMap需要第二组UV，因此将忽略重复和偏移纹理属性\n\n\n### lightMapIntensity : Float\n烤光的强度。 默认值为1\n\n### .map : Texture\n色彩贴图，默认为null\n\n\n### morphNormals : boolean\n定义材质是否使用morphNormals。 设置为true可将morphNormal属性从Geometry传递到着色器。 默认值为false\n\n### morphTargets : Boolean\n定义材质是否使用morphTargets。 默认值为false\n\n### reflectivity : Float\n环境贴图对几何表面的影响程度\n\n### refractionRatio : Float\n空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。\n\n\n### skinning : Boolean\n定义材质是否使用蒙皮。 默认值为false。\n\n### specularMap : Texture\n材质使用的高光贴图。 默认值为null。\n\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n\n### wireframeLinecap : String\n定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为'round'。\n\n这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它\n\n### wireframeLinejoin : String\n定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为'round'。\n\n这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n\n\n# MeshNormalMaterial\n## 概念\n将法线矢量映射到RGB颜色的材质\n\n## 使用\n```\nMeshNormalMaterial( parameters : Object )\n```\nparameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。\n\n## 属性\n### fog : Boolean\n材质是否受场景中fog影响。 默认值为false\n\n### isMeshNormalMaterial : Boolean\n用于检查此类或派生类是否为MeshNormalMaterial材质。 默认为true  \n不应该更改它，因为它在内部用于优化\n\n### lights : Boolean\n材质是否受光照影响。 默认值为false\n\n### morphTargets : boolean\n定义材质是否使用morphTargets, 默认值为false\n\n\n### wireframe : boolean\n将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)\n\n\n### wireframeLinewidth : Float\n控制线框厚度。 默认值为1。\n\n由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 \n\n","slug":"threejs 解读 materilas","published":1,"date":"2018-12-17T14:38:23.516Z","updated":"2018-12-17T14:38:23.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpsfcjzc0000yiji53zzxcdx","content":"<h1 id=\"LineBasicMaterial\"><a href=\"#LineBasicMaterial\" class=\"headerlink\" title=\"LineBasicMaterial\"></a>LineBasicMaterial</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于绘制线框样式几何图形的材质  </p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LineBasicMaterial( parameters : Object )</span><br></pre></td></tr></table></figure>\n<p>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<p>属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color\"><a href=\"#color-Color\" class=\"headerlink\" title=\"color : Color\"></a>color : Color</h3><p>材质的颜色，默认设置为白色（0xffffff）</p>\n<h3 id=\"isLineBasicMaterial-Boolean\"><a href=\"#isLineBasicMaterial-Boolean\" class=\"headerlink\" title=\"isLineBasicMaterial : Boolean\"></a>isLineBasicMaterial : Boolean</h3><p>用于检查此类或派生类是否为行基本材质。 默认为true。<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean\"><a href=\"#lights-Boolean\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材料是否受灯光影响。 默认值为false</p>\n<h3 id=\"linewidth-Float\"><a href=\"#linewidth-Float\" class=\"headerlink\" title=\"linewidth : Float\"></a>linewidth : Float</h3><p>控制线条粗细。 默认值为1<br>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  </p>\n<h3 id=\"linecap-String\"><a href=\"#linecap-String\" class=\"headerlink\" title=\"linecap : String\"></a>linecap : String</h3><p>定义线端的外观。 可能的值是’butt’，’round’和’square’。 默认为’round’.<br>对于2D Canvas lineCap属性，WebGL渲染器会忽略该属性  </p>\n<h3 id=\"linejoin-String\"><a href=\"#linejoin-String\" class=\"headerlink\" title=\"linejoin : String\"></a>linejoin : String</h3><p>定义线关节的连接点。 可能的值是’round’，’bevel’和’miter’。 默认为’round’<br>对于2D Canvas lineJoin属性，WebGL渲染器会忽略该属性   </p>\n<h1 id=\"LineDashedMaterial\"><a href=\"#LineDashedMaterial\" class=\"headerlink\" title=\"LineDashedMaterial\"></a>LineDashedMaterial</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用虚线绘制线框样式几何图形的材质</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LineBDashedMaterial( parameters : Object )</span><br></pre></td></tr></table></figure>\n<p>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<p>属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color-1\"><a href=\"#color-Color-1\" class=\"headerlink\" title=\"color : Color\"></a>color : Color</h3><p>材质的颜色，默认设置为白色（0xffffff）</p>\n<h3 id=\"dashSize-number\"><a href=\"#dashSize-number\" class=\"headerlink\" title=\"dashSize : number\"></a>dashSize : number</h3><p>短划线的大小, 默认值为3。</p>\n<h3 id=\"gapSize-number\"><a href=\"#gapSize-number\" class=\"headerlink\" title=\"gapSize : number\"></a>gapSize : number</h3><p>短划线间隙的大小, 默认值为1</p>\n<h3 id=\"isLineDashedMaterial-Boolean\"><a href=\"#isLineDashedMaterial-Boolean\" class=\"headerlink\" title=\"isLineDashedMaterial : Boolean\"></a>isLineDashedMaterial : Boolean</h3><p>用于检查此类或派生类是否为行基本材质。 默认为true。<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean-1\"><a href=\"#lights-Boolean-1\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材料是否受灯光影响。 默认值为false</p>\n<h3 id=\"linewidth-Float-1\"><a href=\"#linewidth-Float-1\" class=\"headerlink\" title=\"linewidth : Float\"></a>linewidth : Float</h3><p>控制线条粗细。 默认值为1<br>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  </p>\n<h3 id=\"scale-number\"><a href=\"#scale-number\" class=\"headerlink\" title=\"scale : number\"></a>scale : number</h3><p>线的虚线部分的比例。 默认值为1。</p>\n<h1 id=\"Material\"><a href=\"#Material\" class=\"headerlink\" title=\"Material\"></a>Material</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>材料的基础抽象类  </p>\n<p>材质描述了对象的外观。 它们以（主要）与渲染器无关的方式定义，因此如果您决定使用不同的渲染器，则不必重写材质。</p>\n<p>所有其他材质类型都继承了该类的属性和方法（尽管它们可能具有不同的默认值）</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Material()</span><br></pre></td></tr></table></figure>\n<p>创建通用材质</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"alphaTest-Float\"><a href=\"#alphaTest-Float\" class=\"headerlink\" title=\"alphaTest : Float\"></a>alphaTest : Float</h3><p>设置运行alpha测试时要使用的alpha值。 如果不透明度低于此值，则不会渲染材质。 默认值为0  </p>\n<h3 id=\"blendDst-Integer\"><a href=\"#blendDst-Integer\" class=\"headerlink\" title=\"blendDst : Integer\"></a>blendDst : Integer</h3><p>混合目标。这是Three.js中定义的一个混合模式常量。默认为 OneMinusSrcAlphaFactor<br>必须将材质blending设置为CustomBlending才能生效  </p>\n<h3 id=\"blendDstAlpha-Integer\"><a href=\"#blendDstAlpha-Integer\" class=\"headerlink\" title=\"blendDstAlpha : Integer\"></a>blendDstAlpha : Integer</h3><p>blendDst的透明度。 默认值为null</p>\n<h3 id=\"blendEquation-Integer\"><a href=\"#blendEquation-Integer\" class=\"headerlink\" title=\"blendEquation : Integer\"></a>blendEquation : Integer</h3><p>应用混合时所用的混合方程式。这是Three.js中定义的一个常量。 默认为 AddEquation<br>必须将材质blending设置为CustomBlending才能生效   </p>\n<h3 id=\"blendEquationAlpha-Integer\"><a href=\"#blendEquationAlpha-Integer\" class=\"headerlink\" title=\"blendEquationAlpha : Integer\"></a>blendEquationAlpha : Integer</h3><p>blendEquation的透明度。 默认值为null</p>\n<h3 id=\"blending-Blending\"><a href=\"#blending-Blending\" class=\"headerlink\" title=\"blending : Blending\"></a>blending : Blending</h3><p>当显示该材质的对象时使用何种混合模式， 必须将其设置为CustomBlending才能使用自定义blendSrc，blendDst或blendEquation，默认为 NormalBlending  </p>\n<h3 id=\"blendSrc-Integer\"><a href=\"#blendSrc-Integer\" class=\"headerlink\" title=\"blendSrc : Integer\"></a>blendSrc : Integer</h3><p>混合来源。 默认为SrcAlphaFactor<br>必须将材质的混合设置为CustomBlending才能生效  </p>\n<h3 id=\"blendSrcAlpha-Integer\"><a href=\"#blendSrcAlpha-Integer\" class=\"headerlink\" title=\"blendSrcAlpha : Integer\"></a>blendSrcAlpha : Integer</h3><p>blendSrc的透明度。 默认值为null  </p>\n<h3 id=\"clipIntersection-Boolean\"><a href=\"#clipIntersection-Boolean\" class=\"headerlink\" title=\"clipIntersection : Boolean\"></a>clipIntersection : Boolean</h3><p>更改剪裁平面的方式，仅剪切其交交集，而不是它们的并集。 默认值为false  </p>\n<h3 id=\"clippingPlanes-Array\"><a href=\"#clippingPlanes-Array\" class=\"headerlink\" title=\"clippingPlanes : Array\"></a>clippingPlanes : Array</h3><p>用户定义的剪裁平,指定为世界空间中的THREE.Plane对象。 这些平面适用于此材质所附着的对象。 空间中与平面的符号距离为负的点被剪裁（未渲染）。 这需要WebGLRenderer.localClippingEnabled为true。 默认值为null。</p>\n<h3 id=\"clipShadows-Boolean\"><a href=\"#clipShadows-Boolean\" class=\"headerlink\" title=\"clipShadows : Boolean\"></a>clipShadows : Boolean</h3><p>定义是否根据此材质上指定的剪裁平面剪切阴影。 默认值为false</p>\n<h3 id=\"colorWrite-Boolean\"><a href=\"#colorWrite-Boolean\" class=\"headerlink\" title=\"colorWrite : Boolean\"></a>colorWrite : Boolean</h3><p>是否渲染材质的颜色。 这可以与网格renderOrde属性结合使用，以创建遮挡其他对象的不可见对象，默认为true </p>\n<h3 id=\"customDepthMaterial-Material\"><a href=\"#customDepthMaterial-Material\" class=\"headerlink\" title=\"customDepthMaterial : Material\"></a>customDepthMaterial : Material</h3><p>渲染到深度贴图时此材质要使用的通用深度材质。 当使用DirectionalLight或SpotLight进行阴影投射时，如果您是<br>（a）修改顶点着色器中的顶点位置，<br>（b）使用置换贴图，<br>（c）使用带alphaTest的alpha贴图<br>（d）使用透明纹理 使用alphaTest<br>必须为正确的阴影指定customDepthMaterial。 默认值undefined  </p>\n<p>customDistanceMaterial : Material<br>与customDepthMaterial相同，但与PointLight一起使用。 默认值undefined  </p>\n<h3 id=\"defines-Object\"><a href=\"#defines-Object\" class=\"headerlink\" title=\"defines : Object\"></a>defines : Object</h3><p>注入着色器的自定义定义。 它们以对象键/值对传递。 <figure class=\"highlight plain\"><figcaption><span>* 2&#125;```。 这些键/值对在顶点和片段着色器中定义。 默认值undefined </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### depthFunc : Integer</span><br><span class=\"line\">使用哪种深度功能。 默认值为LessEqualDepth </span><br><span class=\"line\"></span><br><span class=\"line\">### depthTest : Boolean</span><br><span class=\"line\">是否在渲染此材质时启用深度测试。 默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">### depthWrite : Boolean</span><br><span class=\"line\">渲染此材质是否对深度缓冲区有任何影响。 默认为true   </span><br><span class=\"line\">在绘制2D叠加时，禁用深度写入以将多个事物分层在一起而不创建z-index伪像会很有用 </span><br><span class=\"line\"></span><br><span class=\"line\">### flatShading : Boolean</span><br><span class=\"line\">定义材质是否使用平面阴影进行渲染。 默认值为false   </span><br><span class=\"line\"></span><br><span class=\"line\">### fog : Boolean</span><br><span class=\"line\">材料是否受场景中fog的影响。 默认为true </span><br><span class=\"line\"></span><br><span class=\"line\">### id : Integer</span><br><span class=\"line\">此材质实例的唯一编号  </span><br><span class=\"line\"></span><br><span class=\"line\">isMaterial : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为material。 默认为true,  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响，默认是true</span><br><span class=\"line\"></span><br><span class=\"line\">### name : String</span><br><span class=\"line\">对象的可选名称（不必是唯一的）。 默认值为空字符串  </span><br><span class=\"line\"></span><br><span class=\"line\">### needsUpdate : Boolean</span><br><span class=\"line\">指定需要重新编译材质  </span><br><span class=\"line\">实例化新材料时，此属性自动设置为true</span><br><span class=\"line\"></span><br><span class=\"line\">### opacity : Float  </span><br><span class=\"line\">值得范围在0.0 - 1.0之间，表示材料的透明度。 值0.0表示完全透明，1.0表示完全不透明，  </span><br><span class=\"line\">如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色   </span><br><span class=\"line\">默认值为1.0</span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffset : Boolean</span><br><span class=\"line\">是否使用多边形偏移。 默认值为false。 这对应于WebGL的GL_POLYGON_OFFSET_FILL 功能。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffsetFactor : Integer</span><br><span class=\"line\">设置多边形偏移系数。 默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffsetUnits : Integer</span><br><span class=\"line\">设置多边形偏移单位。 默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### precision : String</span><br><span class=\"line\">覆盖此材质的渲染器的默认精度。 可以是“highp”，“mediump”或“lowp”。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### premultipliedAlpha : Boolean </span><br><span class=\"line\">是否预乘alpha（透明度）值。 默认值为false </span><br><span class=\"line\"></span><br><span class=\"line\">### dithering : Boolean</span><br><span class=\"line\">是否对颜色应用抖动以消除条带的外观。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### shadowSide : Integer</span><br><span class=\"line\">定义面部投射阴影的哪一侧。 设置时，可以是THREE.FrontSide，THREE.BackSide或THREE.DoubleSide。 默认值为null。</span><br><span class=\"line\">如果为null，则侧面投射阴影确定如下: </span><br><span class=\"line\"></span><br><span class=\"line\">Material.side    | Side casting shadows</span><br><span class=\"line\">-------------    | -------------</span><br><span class=\"line\">THREE.FrontSide  | back side</span><br><span class=\"line\">THREE.BackSide   | front side</span><br><span class=\"line\">THREE.DoubleSide | both side</span><br><span class=\"line\"></span><br><span class=\"line\">### side : Integer</span><br><span class=\"line\">定义将要渲染面部的哪一面 - 正面，背面或两者。 默认为THREE.FrontSide, 其他选项有THREE.BackSide和THREE.DoubleSide  </span><br><span class=\"line\"></span><br><span class=\"line\">### transparent : Boolean</span><br><span class=\"line\">定义此材质是否透明。 这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后呈现  </span><br><span class=\"line\">设置为true时，通过设置材质的不透明度属性来控制材质透明的程度  </span><br><span class=\"line\">默认值为false </span><br><span class=\"line\"></span><br><span class=\"line\">### type : String  </span><br><span class=\"line\">值是字符串&apos;Material&apos;。 这不应该更改，并且可以用于在场景中查找此类型的所有对象  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### uuid : String</span><br><span class=\"line\">此材质实例的UUID。 这会自动分配，因此不应编辑</span><br><span class=\"line\"></span><br><span class=\"line\">### vertexColors : Integer</span><br><span class=\"line\">定义是否使用顶点着色。 默认值为THREE.NoColors。 其他选项有THREE.VertexColors和THREE.FaceColors。</span><br><span class=\"line\"></span><br><span class=\"line\">### visible : Boolean</span><br><span class=\"line\">定义此材质是否可见。 默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### userData : object</span><br><span class=\"line\">可用于存储有关Material的自定义数据的对象。 它不应该包含对函数的引用，因为这些函数不会被克隆  </span><br><span class=\"line\"></span><br><span class=\"line\">##  方法</span><br><span class=\"line\">### clone ( ) : Material </span><br><span class=\"line\">返回与此材质具有相同参数的新材质</span><br><span class=\"line\"></span><br><span class=\"line\">### copy ( material : material ) : Material</span><br><span class=\"line\">将传递材质中的参数复制到此材质中</span><br><span class=\"line\"></span><br><span class=\"line\">### dispose () : null</span><br><span class=\"line\">释放材质。 材质的纹理不会被释放。 这些需要通过Texture释放  </span><br><span class=\"line\"></span><br><span class=\"line\">### onBeforeCompile ( shader : Object, renderer : WebGLRenderer ) : null</span><br><span class=\"line\">在编译着色器程序之前立即执行的可选回调。 使用着色器源代码作为参数调用此函数。 用于修改内置材料 </span><br><span class=\"line\"></span><br><span class=\"line\">### setValues ( values : object ) : null</span><br><span class=\"line\">values - 具有参数的容器  </span><br><span class=\"line\">根据值设置属性  </span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ( meta : object ) : null</span><br><span class=\"line\">元对象，包含元素，例如材质的纹理或图像。</span><br><span class=\"line\">将材质转换为three.js JSON格式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshBasicMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">以简单着色（平面或线框）方式来绘制几何形状的材料  </span><br><span class=\"line\">这种材质不受光照影响  </span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshBasicMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</span><br><span class=\"line\"></span><br><span class=\"line\">属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\">### aoMap : Texture</span><br><span class=\"line\">该纹理的红色通道用作环境遮挡贴图。 默认值为null。  </span><br><span class=\"line\"> aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"> </span><br><span class=\"line\">### aoMapIntensity : Float</span><br><span class=\"line\">环境遮挡效应的强度。 默认值为1.零 不遮挡效果</span><br><span class=\"line\"></span><br><span class=\"line\">### color : Color</span><br><span class=\"line\">材质的颜色，默认设置为白色（0xffffff）</span><br><span class=\"line\"></span><br><span class=\"line\">### combine : Integer</span><br><span class=\"line\">如何将表面颜色的结果与环境贴图（如果有）结合起来  </span><br><span class=\"line\">选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshBasicMaterial : Boolean</span><br><span class=\"line\">用于检查此类或派生类是否为网格基础材质。 默认为true。</span><br><span class=\"line\">不应该更改它，因为它在内部用于优化。</span><br><span class=\"line\"></span><br><span class=\"line\">### envMap : TextureCube</span><br><span class=\"line\">环境贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMap : Texture</span><br><span class=\"line\">光照贴图。 默认值为null, </span><br><span class=\"line\">lightMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMapIntensity : Float</span><br><span class=\"line\">烤光的强度。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### map : Texture</span><br><span class=\"line\">颜色贴图, 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### .morphTargets : Boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### reflectivity : Float</span><br><span class=\"line\">环境贴图对表面的影响程度。 默认值为1，有效范围介于0（无反射）和1（完全反射）之间</span><br><span class=\"line\"></span><br><span class=\"line\">### refractionRatio : Float</span><br><span class=\"line\">空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。</span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### specularMap : Texture</span><br><span class=\"line\">材质使用的高光贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : Boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即渲染为平面多边形）</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinecap : String</span><br><span class=\"line\">定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinejoin : String</span><br><span class=\"line\">定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"># MeshDepthMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\"> 用于按深度绘制几何图形的材质。 深度基于相机近远平面。 白色最近，黑色最远</span><br><span class=\"line\"> </span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshDepthMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### depthPacking : Constant</span><br><span class=\"line\">用于深度包装的编码, 默认为BasicDepthPacking</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementMap : Texture</span><br><span class=\"line\">置换贴图会影响网格顶点的位置。 与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象，以及充当真实的几何体。 位移纹理是这样的图像，其中每个像素的值（白色是最高的）被映射，并且重新定位网格的顶点。</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementScale : Float</span><br><span class=\"line\">置换贴图对网格的影响程度（黑色是不位移，白色是最大位移）。 如果没有设置置换贴图，则不会应用此值。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementBias : Float</span><br><span class=\"line\">位移贴图在网格顶点上的偏移量。 如果没有设置置换贴图，则不会应用此值。 默认值为0。</span><br><span class=\"line\"></span><br><span class=\"line\">### fog : Boolean</span><br><span class=\"line\">材质是否受场景中fog影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshDepthMaterial : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为网格深度材质。 默认为true  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化</span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### map : Texture</span><br><span class=\"line\">颜色贴图，默认为null</span><br><span class=\"line\"></span><br><span class=\"line\">### morphTargets : boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshLambertMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">用于非光泽表面的材料，没有镜面高光  </span><br><span class=\"line\">该材料使用基于非物理的朗伯模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）   </span><br><span class=\"line\">使用Gouraud着色模型计算着色。 这将计算每个顶点的着色（即在顶点着色器中）并在多边形的面上插入结果。</span><br><span class=\"line\">由于反射率和照明模型的简单性，当使用这种材料而不是MeshPhongMaterial，MeshStandardMaterial或MeshPhysicalMaterial时，性能会更高，但可能影响某些图形精度</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshLambertMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</span><br><span class=\"line\"></span><br><span class=\"line\">属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用 </span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\">### aoMap : Texture</span><br><span class=\"line\">该纹理的红色通道用作环境遮挡贴图。 默认值为null。  </span><br><span class=\"line\"> aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"> </span><br><span class=\"line\">### aoMapIntensity : Float</span><br><span class=\"line\">环境遮挡效应的强度。 默认值为1.零 不遮挡效果</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### color : Color</span><br><span class=\"line\">材质的颜色，默认设置为白色（0xffffff）</span><br><span class=\"line\"></span><br><span class=\"line\">### combine : Integer</span><br><span class=\"line\">如何将表面颜色的结果与环境贴图（如果有）结合起来  </span><br><span class=\"line\">选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合</span><br><span class=\"line\"></span><br><span class=\"line\">### emissive : Color</span><br><span class=\"line\">材料的发光颜色，基本上是不受其他照明影响的纯色。 默认为黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">### emissiveMap : Texture</span><br><span class=\"line\">设置自发光（发光）贴图。 默认值为null。 发射性地图颜色由发射颜色和发射强度调制。 如果您有自发光贴图，请务必将发光颜色设置为黑色以外的其他颜色 </span><br><span class=\"line\"></span><br><span class=\"line\">### emissiveIntensity : Float</span><br><span class=\"line\">发射光的强度。 调节发光颜色。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### envMap : TextureCube</span><br><span class=\"line\">环境贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshLambertMaterial : Boolean</span><br><span class=\"line\">用于检查此类或派生类是否为网格Lambert材质。 默认为true。</span><br><span class=\"line\">不应该更改它，因为它在内部用于优化</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMap : Texture</span><br><span class=\"line\">光照贴图。 默认值为null。 lightMap需要第二组UV，因此将忽略重复和偏移纹理属性</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### lightMapIntensity : Float</span><br><span class=\"line\">烤光的强度。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### .map : Texture</span><br><span class=\"line\">色彩贴图，默认为null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### morphNormals : boolean</span><br><span class=\"line\">定义材质是否使用morphNormals。 设置为true可将morphNormal属性从Geometry传递到着色器。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### morphTargets : Boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### reflectivity : Float</span><br><span class=\"line\">环境贴图对几何表面的影响程度</span><br><span class=\"line\"></span><br><span class=\"line\">### refractionRatio : Float</span><br><span class=\"line\">空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false。</span><br><span class=\"line\"></span><br><span class=\"line\">### specularMap : Texture</span><br><span class=\"line\">材质使用的高光贴图。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinecap : String</span><br><span class=\"line\">定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinejoin : String</span><br><span class=\"line\">定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshNormalMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">将法线矢量映射到RGB颜色的材质</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshNormalMaterial( parameters : Object )<br><code>`</code><br>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"fog-Boolean\"><a href=\"#fog-Boolean\" class=\"headerlink\" title=\"fog : Boolean\"></a>fog : Boolean</h3><p>材质是否受场景中fog影响。 默认值为false</p>\n<h3 id=\"isMeshNormalMaterial-Boolean\"><a href=\"#isMeshNormalMaterial-Boolean\" class=\"headerlink\" title=\"isMeshNormalMaterial : Boolean\"></a>isMeshNormalMaterial : Boolean</h3><p>用于检查此类或派生类是否为MeshNormalMaterial材质。 默认为true<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean-2\"><a href=\"#lights-Boolean-2\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材质是否受光照影响。 默认值为false</p>\n<h3 id=\"morphTargets-boolean\"><a href=\"#morphTargets-boolean\" class=\"headerlink\" title=\"morphTargets : boolean\"></a>morphTargets : boolean</h3><p>定义材质是否使用morphTargets, 默认值为false</p>\n<h3 id=\"wireframe-boolean\"><a href=\"#wireframe-boolean\" class=\"headerlink\" title=\"wireframe : boolean\"></a>wireframe : boolean</h3><p>将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</p>\n<h3 id=\"wireframeLinewidth-Float\"><a href=\"#wireframeLinewidth-Float\" class=\"headerlink\" title=\"wireframeLinewidth : Float\"></a>wireframeLinewidth : Float</h3><p>控制线框厚度。 默认值为1。</p>\n<p>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"LineBasicMaterial\"><a href=\"#LineBasicMaterial\" class=\"headerlink\" title=\"LineBasicMaterial\"></a>LineBasicMaterial</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于绘制线框样式几何图形的材质  </p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LineBasicMaterial( parameters : Object )</span><br></pre></td></tr></table></figure>\n<p>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<p>属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color\"><a href=\"#color-Color\" class=\"headerlink\" title=\"color : Color\"></a>color : Color</h3><p>材质的颜色，默认设置为白色（0xffffff）</p>\n<h3 id=\"isLineBasicMaterial-Boolean\"><a href=\"#isLineBasicMaterial-Boolean\" class=\"headerlink\" title=\"isLineBasicMaterial : Boolean\"></a>isLineBasicMaterial : Boolean</h3><p>用于检查此类或派生类是否为行基本材质。 默认为true。<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean\"><a href=\"#lights-Boolean\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材料是否受灯光影响。 默认值为false</p>\n<h3 id=\"linewidth-Float\"><a href=\"#linewidth-Float\" class=\"headerlink\" title=\"linewidth : Float\"></a>linewidth : Float</h3><p>控制线条粗细。 默认值为1<br>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  </p>\n<h3 id=\"linecap-String\"><a href=\"#linecap-String\" class=\"headerlink\" title=\"linecap : String\"></a>linecap : String</h3><p>定义线端的外观。 可能的值是’butt’，’round’和’square’。 默认为’round’.<br>对于2D Canvas lineCap属性，WebGL渲染器会忽略该属性  </p>\n<h3 id=\"linejoin-String\"><a href=\"#linejoin-String\" class=\"headerlink\" title=\"linejoin : String\"></a>linejoin : String</h3><p>定义线关节的连接点。 可能的值是’round’，’bevel’和’miter’。 默认为’round’<br>对于2D Canvas lineJoin属性，WebGL渲染器会忽略该属性   </p>\n<h1 id=\"LineDashedMaterial\"><a href=\"#LineDashedMaterial\" class=\"headerlink\" title=\"LineDashedMaterial\"></a>LineDashedMaterial</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用虚线绘制线框样式几何图形的材质</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LineBDashedMaterial( parameters : Object )</span><br></pre></td></tr></table></figure>\n<p>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<p>属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color-1\"><a href=\"#color-Color-1\" class=\"headerlink\" title=\"color : Color\"></a>color : Color</h3><p>材质的颜色，默认设置为白色（0xffffff）</p>\n<h3 id=\"dashSize-number\"><a href=\"#dashSize-number\" class=\"headerlink\" title=\"dashSize : number\"></a>dashSize : number</h3><p>短划线的大小, 默认值为3。</p>\n<h3 id=\"gapSize-number\"><a href=\"#gapSize-number\" class=\"headerlink\" title=\"gapSize : number\"></a>gapSize : number</h3><p>短划线间隙的大小, 默认值为1</p>\n<h3 id=\"isLineDashedMaterial-Boolean\"><a href=\"#isLineDashedMaterial-Boolean\" class=\"headerlink\" title=\"isLineDashedMaterial : Boolean\"></a>isLineDashedMaterial : Boolean</h3><p>用于检查此类或派生类是否为行基本材质。 默认为true。<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean-1\"><a href=\"#lights-Boolean-1\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材料是否受灯光影响。 默认值为false</p>\n<h3 id=\"linewidth-Float-1\"><a href=\"#linewidth-Float-1\" class=\"headerlink\" title=\"linewidth : Float\"></a>linewidth : Float</h3><p>控制线条粗细。 默认值为1<br>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1  </p>\n<h3 id=\"scale-number\"><a href=\"#scale-number\" class=\"headerlink\" title=\"scale : number\"></a>scale : number</h3><p>线的虚线部分的比例。 默认值为1。</p>\n<h1 id=\"Material\"><a href=\"#Material\" class=\"headerlink\" title=\"Material\"></a>Material</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>材料的基础抽象类  </p>\n<p>材质描述了对象的外观。 它们以（主要）与渲染器无关的方式定义，因此如果您决定使用不同的渲染器，则不必重写材质。</p>\n<p>所有其他材质类型都继承了该类的属性和方法（尽管它们可能具有不同的默认值）</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Material()</span><br></pre></td></tr></table></figure>\n<p>创建通用材质</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"alphaTest-Float\"><a href=\"#alphaTest-Float\" class=\"headerlink\" title=\"alphaTest : Float\"></a>alphaTest : Float</h3><p>设置运行alpha测试时要使用的alpha值。 如果不透明度低于此值，则不会渲染材质。 默认值为0  </p>\n<h3 id=\"blendDst-Integer\"><a href=\"#blendDst-Integer\" class=\"headerlink\" title=\"blendDst : Integer\"></a>blendDst : Integer</h3><p>混合目标。这是Three.js中定义的一个混合模式常量。默认为 OneMinusSrcAlphaFactor<br>必须将材质blending设置为CustomBlending才能生效  </p>\n<h3 id=\"blendDstAlpha-Integer\"><a href=\"#blendDstAlpha-Integer\" class=\"headerlink\" title=\"blendDstAlpha : Integer\"></a>blendDstAlpha : Integer</h3><p>blendDst的透明度。 默认值为null</p>\n<h3 id=\"blendEquation-Integer\"><a href=\"#blendEquation-Integer\" class=\"headerlink\" title=\"blendEquation : Integer\"></a>blendEquation : Integer</h3><p>应用混合时所用的混合方程式。这是Three.js中定义的一个常量。 默认为 AddEquation<br>必须将材质blending设置为CustomBlending才能生效   </p>\n<h3 id=\"blendEquationAlpha-Integer\"><a href=\"#blendEquationAlpha-Integer\" class=\"headerlink\" title=\"blendEquationAlpha : Integer\"></a>blendEquationAlpha : Integer</h3><p>blendEquation的透明度。 默认值为null</p>\n<h3 id=\"blending-Blending\"><a href=\"#blending-Blending\" class=\"headerlink\" title=\"blending : Blending\"></a>blending : Blending</h3><p>当显示该材质的对象时使用何种混合模式， 必须将其设置为CustomBlending才能使用自定义blendSrc，blendDst或blendEquation，默认为 NormalBlending  </p>\n<h3 id=\"blendSrc-Integer\"><a href=\"#blendSrc-Integer\" class=\"headerlink\" title=\"blendSrc : Integer\"></a>blendSrc : Integer</h3><p>混合来源。 默认为SrcAlphaFactor<br>必须将材质的混合设置为CustomBlending才能生效  </p>\n<h3 id=\"blendSrcAlpha-Integer\"><a href=\"#blendSrcAlpha-Integer\" class=\"headerlink\" title=\"blendSrcAlpha : Integer\"></a>blendSrcAlpha : Integer</h3><p>blendSrc的透明度。 默认值为null  </p>\n<h3 id=\"clipIntersection-Boolean\"><a href=\"#clipIntersection-Boolean\" class=\"headerlink\" title=\"clipIntersection : Boolean\"></a>clipIntersection : Boolean</h3><p>更改剪裁平面的方式，仅剪切其交交集，而不是它们的并集。 默认值为false  </p>\n<h3 id=\"clippingPlanes-Array\"><a href=\"#clippingPlanes-Array\" class=\"headerlink\" title=\"clippingPlanes : Array\"></a>clippingPlanes : Array</h3><p>用户定义的剪裁平,指定为世界空间中的THREE.Plane对象。 这些平面适用于此材质所附着的对象。 空间中与平面的符号距离为负的点被剪裁（未渲染）。 这需要WebGLRenderer.localClippingEnabled为true。 默认值为null。</p>\n<h3 id=\"clipShadows-Boolean\"><a href=\"#clipShadows-Boolean\" class=\"headerlink\" title=\"clipShadows : Boolean\"></a>clipShadows : Boolean</h3><p>定义是否根据此材质上指定的剪裁平面剪切阴影。 默认值为false</p>\n<h3 id=\"colorWrite-Boolean\"><a href=\"#colorWrite-Boolean\" class=\"headerlink\" title=\"colorWrite : Boolean\"></a>colorWrite : Boolean</h3><p>是否渲染材质的颜色。 这可以与网格renderOrde属性结合使用，以创建遮挡其他对象的不可见对象，默认为true </p>\n<h3 id=\"customDepthMaterial-Material\"><a href=\"#customDepthMaterial-Material\" class=\"headerlink\" title=\"customDepthMaterial : Material\"></a>customDepthMaterial : Material</h3><p>渲染到深度贴图时此材质要使用的通用深度材质。 当使用DirectionalLight或SpotLight进行阴影投射时，如果您是<br>（a）修改顶点着色器中的顶点位置，<br>（b）使用置换贴图，<br>（c）使用带alphaTest的alpha贴图<br>（d）使用透明纹理 使用alphaTest<br>必须为正确的阴影指定customDepthMaterial。 默认值undefined  </p>\n<p>customDistanceMaterial : Material<br>与customDepthMaterial相同，但与PointLight一起使用。 默认值undefined  </p>\n<h3 id=\"defines-Object\"><a href=\"#defines-Object\" class=\"headerlink\" title=\"defines : Object\"></a>defines : Object</h3><p>注入着色器的自定义定义。 它们以对象键/值对传递。 <figure class=\"highlight plain\"><figcaption><span>* 2&#125;```。 这些键/值对在顶点和片段着色器中定义。 默认值undefined </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### depthFunc : Integer</span><br><span class=\"line\">使用哪种深度功能。 默认值为LessEqualDepth </span><br><span class=\"line\"></span><br><span class=\"line\">### depthTest : Boolean</span><br><span class=\"line\">是否在渲染此材质时启用深度测试。 默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">### depthWrite : Boolean</span><br><span class=\"line\">渲染此材质是否对深度缓冲区有任何影响。 默认为true   </span><br><span class=\"line\">在绘制2D叠加时，禁用深度写入以将多个事物分层在一起而不创建z-index伪像会很有用 </span><br><span class=\"line\"></span><br><span class=\"line\">### flatShading : Boolean</span><br><span class=\"line\">定义材质是否使用平面阴影进行渲染。 默认值为false   </span><br><span class=\"line\"></span><br><span class=\"line\">### fog : Boolean</span><br><span class=\"line\">材料是否受场景中fog的影响。 默认为true </span><br><span class=\"line\"></span><br><span class=\"line\">### id : Integer</span><br><span class=\"line\">此材质实例的唯一编号  </span><br><span class=\"line\"></span><br><span class=\"line\">isMaterial : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为material。 默认为true,  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响，默认是true</span><br><span class=\"line\"></span><br><span class=\"line\">### name : String</span><br><span class=\"line\">对象的可选名称（不必是唯一的）。 默认值为空字符串  </span><br><span class=\"line\"></span><br><span class=\"line\">### needsUpdate : Boolean</span><br><span class=\"line\">指定需要重新编译材质  </span><br><span class=\"line\">实例化新材料时，此属性自动设置为true</span><br><span class=\"line\"></span><br><span class=\"line\">### opacity : Float  </span><br><span class=\"line\">值得范围在0.0 - 1.0之间，表示材料的透明度。 值0.0表示完全透明，1.0表示完全不透明，  </span><br><span class=\"line\">如果材质的transparent属性未设置为true，则材质将保持完全不透明，此值仅影响其颜色   </span><br><span class=\"line\">默认值为1.0</span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffset : Boolean</span><br><span class=\"line\">是否使用多边形偏移。 默认值为false。 这对应于WebGL的GL_POLYGON_OFFSET_FILL 功能。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffsetFactor : Integer</span><br><span class=\"line\">设置多边形偏移系数。 默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### polygonOffsetUnits : Integer</span><br><span class=\"line\">设置多边形偏移单位。 默认值为0</span><br><span class=\"line\"></span><br><span class=\"line\">### precision : String</span><br><span class=\"line\">覆盖此材质的渲染器的默认精度。 可以是“highp”，“mediump”或“lowp”。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### premultipliedAlpha : Boolean </span><br><span class=\"line\">是否预乘alpha（透明度）值。 默认值为false </span><br><span class=\"line\"></span><br><span class=\"line\">### dithering : Boolean</span><br><span class=\"line\">是否对颜色应用抖动以消除条带的外观。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### shadowSide : Integer</span><br><span class=\"line\">定义面部投射阴影的哪一侧。 设置时，可以是THREE.FrontSide，THREE.BackSide或THREE.DoubleSide。 默认值为null。</span><br><span class=\"line\">如果为null，则侧面投射阴影确定如下: </span><br><span class=\"line\"></span><br><span class=\"line\">Material.side    | Side casting shadows</span><br><span class=\"line\">-------------    | -------------</span><br><span class=\"line\">THREE.FrontSide  | back side</span><br><span class=\"line\">THREE.BackSide   | front side</span><br><span class=\"line\">THREE.DoubleSide | both side</span><br><span class=\"line\"></span><br><span class=\"line\">### side : Integer</span><br><span class=\"line\">定义将要渲染面部的哪一面 - 正面，背面或两者。 默认为THREE.FrontSide, 其他选项有THREE.BackSide和THREE.DoubleSide  </span><br><span class=\"line\"></span><br><span class=\"line\">### transparent : Boolean</span><br><span class=\"line\">定义此材质是否透明。 这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后呈现  </span><br><span class=\"line\">设置为true时，通过设置材质的不透明度属性来控制材质透明的程度  </span><br><span class=\"line\">默认值为false </span><br><span class=\"line\"></span><br><span class=\"line\">### type : String  </span><br><span class=\"line\">值是字符串&apos;Material&apos;。 这不应该更改，并且可以用于在场景中查找此类型的所有对象  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### uuid : String</span><br><span class=\"line\">此材质实例的UUID。 这会自动分配，因此不应编辑</span><br><span class=\"line\"></span><br><span class=\"line\">### vertexColors : Integer</span><br><span class=\"line\">定义是否使用顶点着色。 默认值为THREE.NoColors。 其他选项有THREE.VertexColors和THREE.FaceColors。</span><br><span class=\"line\"></span><br><span class=\"line\">### visible : Boolean</span><br><span class=\"line\">定义此材质是否可见。 默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">### userData : object</span><br><span class=\"line\">可用于存储有关Material的自定义数据的对象。 它不应该包含对函数的引用，因为这些函数不会被克隆  </span><br><span class=\"line\"></span><br><span class=\"line\">##  方法</span><br><span class=\"line\">### clone ( ) : Material </span><br><span class=\"line\">返回与此材质具有相同参数的新材质</span><br><span class=\"line\"></span><br><span class=\"line\">### copy ( material : material ) : Material</span><br><span class=\"line\">将传递材质中的参数复制到此材质中</span><br><span class=\"line\"></span><br><span class=\"line\">### dispose () : null</span><br><span class=\"line\">释放材质。 材质的纹理不会被释放。 这些需要通过Texture释放  </span><br><span class=\"line\"></span><br><span class=\"line\">### onBeforeCompile ( shader : Object, renderer : WebGLRenderer ) : null</span><br><span class=\"line\">在编译着色器程序之前立即执行的可选回调。 使用着色器源代码作为参数调用此函数。 用于修改内置材料 </span><br><span class=\"line\"></span><br><span class=\"line\">### setValues ( values : object ) : null</span><br><span class=\"line\">values - 具有参数的容器  </span><br><span class=\"line\">根据值设置属性  </span><br><span class=\"line\"></span><br><span class=\"line\">### toJSON ( meta : object ) : null</span><br><span class=\"line\">元对象，包含元素，例如材质的纹理或图像。</span><br><span class=\"line\">将材质转换为three.js JSON格式</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshBasicMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">以简单着色（平面或线框）方式来绘制几何形状的材料  </span><br><span class=\"line\">这种材质不受光照影响  </span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshBasicMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</span><br><span class=\"line\"></span><br><span class=\"line\">属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\">### aoMap : Texture</span><br><span class=\"line\">该纹理的红色通道用作环境遮挡贴图。 默认值为null。  </span><br><span class=\"line\"> aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"> </span><br><span class=\"line\">### aoMapIntensity : Float</span><br><span class=\"line\">环境遮挡效应的强度。 默认值为1.零 不遮挡效果</span><br><span class=\"line\"></span><br><span class=\"line\">### color : Color</span><br><span class=\"line\">材质的颜色，默认设置为白色（0xffffff）</span><br><span class=\"line\"></span><br><span class=\"line\">### combine : Integer</span><br><span class=\"line\">如何将表面颜色的结果与环境贴图（如果有）结合起来  </span><br><span class=\"line\">选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshBasicMaterial : Boolean</span><br><span class=\"line\">用于检查此类或派生类是否为网格基础材质。 默认为true。</span><br><span class=\"line\">不应该更改它，因为它在内部用于优化。</span><br><span class=\"line\"></span><br><span class=\"line\">### envMap : TextureCube</span><br><span class=\"line\">环境贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMap : Texture</span><br><span class=\"line\">光照贴图。 默认值为null, </span><br><span class=\"line\">lightMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMapIntensity : Float</span><br><span class=\"line\">烤光的强度。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### map : Texture</span><br><span class=\"line\">颜色贴图, 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### .morphTargets : Boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### reflectivity : Float</span><br><span class=\"line\">环境贴图对表面的影响程度。 默认值为1，有效范围介于0（无反射）和1（完全反射）之间</span><br><span class=\"line\"></span><br><span class=\"line\">### refractionRatio : Float</span><br><span class=\"line\">空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。</span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### specularMap : Texture</span><br><span class=\"line\">材质使用的高光贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : Boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即渲染为平面多边形）</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinecap : String</span><br><span class=\"line\">定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinejoin : String</span><br><span class=\"line\">定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"># MeshDepthMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\"> 用于按深度绘制几何图形的材质。 深度基于相机近远平面。 白色最近，黑色最远</span><br><span class=\"line\"> </span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshDepthMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### depthPacking : Constant</span><br><span class=\"line\">用于深度包装的编码, 默认为BasicDepthPacking</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementMap : Texture</span><br><span class=\"line\">置换贴图会影响网格顶点的位置。 与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象，以及充当真实的几何体。 位移纹理是这样的图像，其中每个像素的值（白色是最高的）被映射，并且重新定位网格的顶点。</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementScale : Float</span><br><span class=\"line\">置换贴图对网格的影响程度（黑色是不位移，白色是最大位移）。 如果没有设置置换贴图，则不会应用此值。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">### displacementBias : Float</span><br><span class=\"line\">位移贴图在网格顶点上的偏移量。 如果没有设置置换贴图，则不会应用此值。 默认值为0。</span><br><span class=\"line\"></span><br><span class=\"line\">### fog : Boolean</span><br><span class=\"line\">材质是否受场景中fog影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshDepthMaterial : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为网格深度材质。 默认为true  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化</span><br><span class=\"line\"></span><br><span class=\"line\">### lights : Boolean</span><br><span class=\"line\">材质是否受光照影响。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### map : Texture</span><br><span class=\"line\">颜色贴图，默认为null</span><br><span class=\"line\"></span><br><span class=\"line\">### morphTargets : boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshLambertMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">用于非光泽表面的材料，没有镜面高光  </span><br><span class=\"line\">该材料使用基于非物理的朗伯模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）   </span><br><span class=\"line\">使用Gouraud着色模型计算着色。 这将计算每个顶点的着色（即在顶点着色器中）并在多边形的面上插入结果。</span><br><span class=\"line\">由于反射率和照明模型的简单性，当使用这种材料而不是MeshPhongMaterial，MeshStandardMaterial或MeshPhysicalMaterial时，性能会更高，但可能影响某些图形精度</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshLambertMaterial( parameters : Object )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</span><br><span class=\"line\"></span><br><span class=\"line\">属性颜色例外，它可以作为十六进制字符串传递，默认情况下为0xffffff（白色）。 Color.set（颜色）在内部调用 </span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### alphaMap : Texture</span><br><span class=\"line\">alpha贴图是一种灰度纹理，用于控制整个表面的不透明度（黑色：完全透明;白色：完全不透明）。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\">仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道，因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 仅亮度和亮度/ alpha纹理也将按预期工作。</span><br><span class=\"line\"></span><br><span class=\"line\">### aoMap : Texture</span><br><span class=\"line\">该纹理的红色通道用作环境遮挡贴图。 默认值为null。  </span><br><span class=\"line\"> aoMap需要第二组UV，因此将忽略重复和偏移纹理属性。</span><br><span class=\"line\"> </span><br><span class=\"line\">### aoMapIntensity : Float</span><br><span class=\"line\">环境遮挡效应的强度。 默认值为1.零 不遮挡效果</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### color : Color</span><br><span class=\"line\">材质的颜色，默认设置为白色（0xffffff）</span><br><span class=\"line\"></span><br><span class=\"line\">### combine : Integer</span><br><span class=\"line\">如何将表面颜色的结果与环境贴图（如果有）结合起来  </span><br><span class=\"line\">选项为THREE.Multiply（默认值），THREE.MixOperation，THREE.AddOperation。 如果选择混合，则使用reflectivity在两种颜色之间进行混合</span><br><span class=\"line\"></span><br><span class=\"line\">### emissive : Color</span><br><span class=\"line\">材料的发光颜色，基本上是不受其他照明影响的纯色。 默认为黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">### emissiveMap : Texture</span><br><span class=\"line\">设置自发光（发光）贴图。 默认值为null。 发射性地图颜色由发射颜色和发射强度调制。 如果您有自发光贴图，请务必将发光颜色设置为黑色以外的其他颜色 </span><br><span class=\"line\"></span><br><span class=\"line\">### emissiveIntensity : Float</span><br><span class=\"line\">发射光的强度。 调节发光颜色。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### envMap : TextureCube</span><br><span class=\"line\">环境贴图。 默认值为null</span><br><span class=\"line\"></span><br><span class=\"line\">### isMeshLambertMaterial : Boolean</span><br><span class=\"line\">用于检查此类或派生类是否为网格Lambert材质。 默认为true。</span><br><span class=\"line\">不应该更改它，因为它在内部用于优化</span><br><span class=\"line\"></span><br><span class=\"line\">### lightMap : Texture</span><br><span class=\"line\">光照贴图。 默认值为null。 lightMap需要第二组UV，因此将忽略重复和偏移纹理属性</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### lightMapIntensity : Float</span><br><span class=\"line\">烤光的强度。 默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### .map : Texture</span><br><span class=\"line\">色彩贴图，默认为null</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### morphNormals : boolean</span><br><span class=\"line\">定义材质是否使用morphNormals。 设置为true可将morphNormal属性从Geometry传递到着色器。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### morphTargets : Boolean</span><br><span class=\"line\">定义材质是否使用morphTargets。 默认值为false</span><br><span class=\"line\"></span><br><span class=\"line\">### reflectivity : Float</span><br><span class=\"line\">环境贴图对几何表面的影响程度</span><br><span class=\"line\"></span><br><span class=\"line\">### refractionRatio : Float</span><br><span class=\"line\">空气的折射率（IOR）（约为1）除以材料的折射率。 它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 折射率不应超过1.默认值为0.98。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### skinning : Boolean</span><br><span class=\"line\">定义材质是否使用蒙皮。 默认值为false。</span><br><span class=\"line\"></span><br><span class=\"line\">### specularMap : Texture</span><br><span class=\"line\">材质使用的高光贴图。 默认值为null。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### wireframe : boolean</span><br><span class=\"line\">将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinecap : String</span><br><span class=\"line\">定义线端的外观。 可能的值是“butt”，“round”和“square”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineCap属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinejoin : String</span><br><span class=\"line\">定义线连接点的外观。 可能的值是“round”，“bevel”和“miter”。 默认为&apos;round&apos;。</span><br><span class=\"line\"></span><br><span class=\"line\">这对应于2D Canvas lineJoin属性，WebGL渲染器会忽略它</span><br><span class=\"line\"></span><br><span class=\"line\">### wireframeLinewidth : Float</span><br><span class=\"line\">控制线框厚度。 默认值为1。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># MeshNormalMaterial</span><br><span class=\"line\">## 概念</span><br><span class=\"line\">将法线矢量映射到RGB颜色的材质</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>MeshNormalMaterial( parameters : Object )<br><code>`</code><br>parameters -（可选）具有一个或多个属性的对象，用于定义材质的外观。 材料的任何属性（包括从Material继承的任何属性）都可以在此处传递。</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"fog-Boolean\"><a href=\"#fog-Boolean\" class=\"headerlink\" title=\"fog : Boolean\"></a>fog : Boolean</h3><p>材质是否受场景中fog影响。 默认值为false</p>\n<h3 id=\"isMeshNormalMaterial-Boolean\"><a href=\"#isMeshNormalMaterial-Boolean\" class=\"headerlink\" title=\"isMeshNormalMaterial : Boolean\"></a>isMeshNormalMaterial : Boolean</h3><p>用于检查此类或派生类是否为MeshNormalMaterial材质。 默认为true<br>不应该更改它，因为它在内部用于优化</p>\n<h3 id=\"lights-Boolean-2\"><a href=\"#lights-Boolean-2\" class=\"headerlink\" title=\"lights : Boolean\"></a>lights : Boolean</h3><p>材质是否受光照影响。 默认值为false</p>\n<h3 id=\"morphTargets-boolean\"><a href=\"#morphTargets-boolean\" class=\"headerlink\" title=\"morphTargets : boolean\"></a>morphTargets : boolean</h3><p>定义材质是否使用morphTargets, 默认值为false</p>\n<h3 id=\"wireframe-boolean\"><a href=\"#wireframe-boolean\" class=\"headerlink\" title=\"wireframe : boolean\"></a>wireframe : boolean</h3><p>将几何图形渲染为线框。 默认值为false（即呈现为平滑着色)</p>\n<h3 id=\"wireframeLinewidth-Float\"><a href=\"#wireframeLinewidth-Float\" class=\"headerlink\" title=\"wireframeLinewidth : Float\"></a>wireframeLinewidth : Float</h3><p>控制线框厚度。 默认值为1。</p>\n<p>由于在大多数平台上WebGL渲染器的OpenGL核心配置文件的限制，无论设置值如何，线宽始终为1 </p>\n"},{"title":"threejs 解读  camera","_content":"# AmbientLight\n## 概念\n此光照均匀地照亮场景中的所有对象  \n此灯不能用于投射阴影，因为它没有方向\n\n\n## 使用\n```\nAmbientLight( color : Integer, intensity : Float )\n```\n\ncolor — 光源颜色的RGB数值, 默认0xffffff\nintensity -- 光源强度的数值， 默认1\n\n## 属性\n### castShadow : Boolean\n这在构造函数中设置为undefined，因为环境光不能投射阴影。\n\n### isAmbientLight : Boolean\n\n用于检查此类或派生类是否为环境光. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n\n# DirectionalLight\n## 概念\n一种沿特定方向发射的光。 这种光的行为就好像它是无限远的，并且由它产生的光线都是平行的。 常见的用例是模拟日光; 太阳足够远，它的位置可以被认为是无限的，并且来自它的所有光线都是平行的。\n\n**关于位置，目标和旋转的注释**  \n方向灯的一个常见混淆点是设置旋转无效。 这是因为three.js的DirectionalLight与其他应用程序中通常称为“Target Direct Light”的东西相当。\n\n这意味着它的方向被计算为从光的位置指向目标的位置（而不是仅具有旋转分量的'自由直接光'）。\n\n这样做的原因是允许灯光投射阴影 - 阴影相机需要一个位置来计算阴影。\n\n\n## 使用\n```\nDirectionalLight( color : Integer, intensity : Float )\n```\ncolor  - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\n## 属性\n\n### castShadow : Boolean\n如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。\n\n### isDirectionalLight : Boolean\n\n用于检查此类或派生类是否为平行光. 默认为true.  \n不应该更改它，因为它在内部用于优化    \n\n### position : Vector3  \n这被默认设置为**Object3D.DefaultUp（0,1,0）**，以便光从上到下发光\n\n### shadow : DirectionalLightShadow\n用于计算此灯光的阴影**DirectionalLightShadow** \n\n### target : Object3D\nDirectionalLight从其位置指向target.position。 目标的默认位置是（0,0,0）。\n注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中\n\n## 方法\n### copy( source : DirectionalLight ) : DirectionalLight\n将source中所有属性的值复制到此DirectionalLight  \n\n\n# HemisphereLight\n## 概念\n直接位于场景上方的光源，颜色从天空颜色渐变到底色。\n\n此灯不能用于投射阴影\n\n## 使用\n```\nHemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )\n```\n\nskyColor - （可选）天空的十六进制颜色。 默认值为0xffffff。  \ngroundColor - （可选）地面的十六进制颜色。 默认值为0xffffff。  \nintensity - （可选）灯光强度/强度的数值。 默认值为1。  \n\n## 属性\n\n### castShadow : Boolean\n这在构造函数中设置为undefined，因为半球光不能投射阴影\n\n### color : Float\n灯光的天空颜色，在构造函数中传递。 默认值是（0xffffff）\n\n### groundColor : Float\n灯光的地面颜色，在构造函数中传递。 默认值是（0xffffff）\n\n\n### isHemisphereLight : Boolean\n\n用于检查此类或派生类是否为半球光. 默认为true.  \n不应该更改它，因为它在内部用于优化    \n\n### position : Vector3  \n这被默认设置为**Object3D.DefaultUp（0,1,0）**，以便光从上到下发光\n\n\n## 方法\n### copy ( source : HemisphereLight ) : HemisphereLight\n将source中 color, intensity and groundColor属性的值复制到此光照  \n\n# Light\n## 概念\n灯的抽象基类 - 所有其他灯类型都继承了此处描述的属性和方法\n\n## 使用\n```\nLight( color : Integer, intensity : float )\n```\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\n创造一个新的光。 请注意，这不是要直接调用（而是使用派生类之一）\n\n## 属性\n### color: Color\n光的颜色。 如果未在构造函数中传递，则默认为将新颜色设置为白色\n\n### intensity : Float\n光的强度或强度。\n在物理上正确的模式中，颜色*强度的乘积被解释为在坎德拉中测量的发光强度。\n默认值 - 1.0\n\n### isLight : Boolean\n\n用于检查此类或派生类是否为光照. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n## 方法\n### copy ( source : Light ) : Light  \n将source中 color, intensity 属性的值复制到此光照  \n\n###toJSON ( meta : String )\n返回JSON格式的光照数据\n\n# PointLight\n## 概念\n从所有方向的单个点发出的光。 一个常见的用例是复制裸灯泡发出的光。\n\n## 使用\n```\nPointLight( color : Integer, intensity : Float, distance : Number, decay : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\ndistance - 光的最大范围。 默认值为0（无限制）。\ndecay - 灯光沿着光线的距离变暗的量。 默认值为1. 对于物理上正确的照明，请将其设置为2\n\n## 属性\n### decay : Float\n光线沿光线距离变暗的量  \n在物理校正模式下，衰减= 2会模拟物理上逼真的光线衰减。\n默认值为1。\n\n### distance : Float\n默认模式 - 当距离为零时，灯不会衰减  \n 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  \n \n 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  \n 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的\n\n默认值为0.0\n\n### isPointLight : Boolean\n\n用于检查此类或派生类是否为点光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n### power : Float \n光的强度  \n在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    \n这与intensity成比例关系 ```power = intensity * 4π```  \n改变这属性也将改变intensity \n\n###shadow : LightShadow  \n\n用于计算此灯光阴影的LightShadow。\n\nlightShadow的相机被设置为PerspectiveCamera，fov为90, aspect为1，near 为0.5，far为500。\n\n\n## 方法\n### copy  ( source : PointLight ) : PointLight\n将source中所有属性的值复制到此光照  \n\n\n# RectAreaLight\nRectAreaLight是在一个矩形平面上均匀地发光。 这种灯型可用于模拟光源，如明亮的窗户或条形照明。\n\nps：\n\n不支持阴影  \n仅支持**MeshStandardMaterial**和**MeshPhysicalMaterial**  \n在场景中必须包含**RectAreaLightUniformsLib**\n\n## 使用\n```\nRectAreaLight( color : Integer, intensity : Float, width : Float, height : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）光的强度或亮度。 默认值为1。\nwidth - （可选）灯的宽度。 默认值为10。\nheight - （可选）灯光高度。 默认值为10。\n\n## 属性\n### isRectAreaLight : Boolean\n\n用于检查此类或派生类是否为矩形区光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n## 方法\n### copy  ( source : RectAreaLight ) : RectAreaLight\n将source中所有属性的值复制到此光照  \n\n\n# SpotLight\n## 概念 \n聚光源，这种光从一个方向上的单个点沿着一个锥体发出，该锥体的尺寸越大，距离得到的光越远\n\n## 使用\n```\nSpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\ndistance - 光的最大范围。 默认值为0（无限制）。\nangle - 从其上限为Math.PI / 2的方向的最大光散射角。\npennumbra - 由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为零。\ndecay - 灯光沿着光线的距离变暗的量\n\n## 属性\n### angle : Float\n聚光灯的最大范围，从光源方向看，以弧度为单位，。 应该不超过Math.PI / 2。 默认值为Math.PI / 3\n\n### castShadow : Boolean\n如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。\n\n### decay : Float\n光线沿光线距离变暗的量  \n在物理校正模式下，decay= 2会导致物理上逼真的光线衰减, \n默认值为1\n\n### distance : Float\n默认模式 - 当距离为零时，灯不会衰减  \n 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  \n \n 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  \n 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的\n\n默认值为0.0\n\n### isSpotLight : Boolean\n\n用于检查此类或派生类是否为聚光光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n### penumbra : Float\n由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为0.0\n\n### position : Vector3\n默认设置为Object3D.DefaultUp（0,1,0），以便光从上到下发光\n\n### power : Float\n光的强度  \n在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    \n这与intensity成比例关系 ```power = intensity * π```  \n改变这属性也将改变intensity \n\n### shadow : SpotLightShadow\n用于计算此灯光的阴影SpotLightShadow\n\n### target : Object3D\nSpotlight从其光源位置指向target.position。 目标的默认位置是（0,0,0）。\n注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中\n```\nscene.add( light.target ) \n```  \n这样，目标的matrixWorld每帧都会自动更新\n\n也可以将目标设置为场景中的另一个对象（具有position属性的任何对象），如下所示\n\n\tvar targetObject = new THREE.Object3D();\n\tscene.add(targetObject);\n\n\tlight.target = targetObject;\n\t\n聚光灯现在将跟踪目标对象\n\n\n## 方法\n### copy  ( source : SpotLight ) : SpotLight\n将source中所有属性的值复制到此光照  \n","source":"_posts/threejs 解读 light.md","raw":"title:      \"threejs 解读  camera\"\ntags:\n    - js threejs\n---\n# AmbientLight\n## 概念\n此光照均匀地照亮场景中的所有对象  \n此灯不能用于投射阴影，因为它没有方向\n\n\n## 使用\n```\nAmbientLight( color : Integer, intensity : Float )\n```\n\ncolor — 光源颜色的RGB数值, 默认0xffffff\nintensity -- 光源强度的数值， 默认1\n\n## 属性\n### castShadow : Boolean\n这在构造函数中设置为undefined，因为环境光不能投射阴影。\n\n### isAmbientLight : Boolean\n\n用于检查此类或派生类是否为环境光. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n\n# DirectionalLight\n## 概念\n一种沿特定方向发射的光。 这种光的行为就好像它是无限远的，并且由它产生的光线都是平行的。 常见的用例是模拟日光; 太阳足够远，它的位置可以被认为是无限的，并且来自它的所有光线都是平行的。\n\n**关于位置，目标和旋转的注释**  \n方向灯的一个常见混淆点是设置旋转无效。 这是因为three.js的DirectionalLight与其他应用程序中通常称为“Target Direct Light”的东西相当。\n\n这意味着它的方向被计算为从光的位置指向目标的位置（而不是仅具有旋转分量的'自由直接光'）。\n\n这样做的原因是允许灯光投射阴影 - 阴影相机需要一个位置来计算阴影。\n\n\n## 使用\n```\nDirectionalLight( color : Integer, intensity : Float )\n```\ncolor  - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\n## 属性\n\n### castShadow : Boolean\n如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。\n\n### isDirectionalLight : Boolean\n\n用于检查此类或派生类是否为平行光. 默认为true.  \n不应该更改它，因为它在内部用于优化    \n\n### position : Vector3  \n这被默认设置为**Object3D.DefaultUp（0,1,0）**，以便光从上到下发光\n\n### shadow : DirectionalLightShadow\n用于计算此灯光的阴影**DirectionalLightShadow** \n\n### target : Object3D\nDirectionalLight从其位置指向target.position。 目标的默认位置是（0,0,0）。\n注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中\n\n## 方法\n### copy( source : DirectionalLight ) : DirectionalLight\n将source中所有属性的值复制到此DirectionalLight  \n\n\n# HemisphereLight\n## 概念\n直接位于场景上方的光源，颜色从天空颜色渐变到底色。\n\n此灯不能用于投射阴影\n\n## 使用\n```\nHemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )\n```\n\nskyColor - （可选）天空的十六进制颜色。 默认值为0xffffff。  \ngroundColor - （可选）地面的十六进制颜色。 默认值为0xffffff。  \nintensity - （可选）灯光强度/强度的数值。 默认值为1。  \n\n## 属性\n\n### castShadow : Boolean\n这在构造函数中设置为undefined，因为半球光不能投射阴影\n\n### color : Float\n灯光的天空颜色，在构造函数中传递。 默认值是（0xffffff）\n\n### groundColor : Float\n灯光的地面颜色，在构造函数中传递。 默认值是（0xffffff）\n\n\n### isHemisphereLight : Boolean\n\n用于检查此类或派生类是否为半球光. 默认为true.  \n不应该更改它，因为它在内部用于优化    \n\n### position : Vector3  \n这被默认设置为**Object3D.DefaultUp（0,1,0）**，以便光从上到下发光\n\n\n## 方法\n### copy ( source : HemisphereLight ) : HemisphereLight\n将source中 color, intensity and groundColor属性的值复制到此光照  \n\n# Light\n## 概念\n灯的抽象基类 - 所有其他灯类型都继承了此处描述的属性和方法\n\n## 使用\n```\nLight( color : Integer, intensity : float )\n```\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\n创造一个新的光。 请注意，这不是要直接调用（而是使用派生类之一）\n\n## 属性\n### color: Color\n光的颜色。 如果未在构造函数中传递，则默认为将新颜色设置为白色\n\n### intensity : Float\n光的强度或强度。\n在物理上正确的模式中，颜色*强度的乘积被解释为在坎德拉中测量的发光强度。\n默认值 - 1.0\n\n### isLight : Boolean\n\n用于检查此类或派生类是否为光照. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n## 方法\n### copy ( source : Light ) : Light  \n将source中 color, intensity 属性的值复制到此光照  \n\n###toJSON ( meta : String )\n返回JSON格式的光照数据\n\n# PointLight\n## 概念\n从所有方向的单个点发出的光。 一个常见的用例是复制裸灯泡发出的光。\n\n## 使用\n```\nPointLight( color : Integer, intensity : Float, distance : Number, decay : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\n\ndistance - 光的最大范围。 默认值为0（无限制）。\ndecay - 灯光沿着光线的距离变暗的量。 默认值为1. 对于物理上正确的照明，请将其设置为2\n\n## 属性\n### decay : Float\n光线沿光线距离变暗的量  \n在物理校正模式下，衰减= 2会模拟物理上逼真的光线衰减。\n默认值为1。\n\n### distance : Float\n默认模式 - 当距离为零时，灯不会衰减  \n 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  \n \n 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  \n 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的\n\n默认值为0.0\n\n### isPointLight : Boolean\n\n用于检查此类或派生类是否为点光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n### power : Float \n光的强度  \n在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    \n这与intensity成比例关系 ```power = intensity * 4π```  \n改变这属性也将改变intensity \n\n###shadow : LightShadow  \n\n用于计算此灯光阴影的LightShadow。\n\nlightShadow的相机被设置为PerspectiveCamera，fov为90, aspect为1，near 为0.5，far为500。\n\n\n## 方法\n### copy  ( source : PointLight ) : PointLight\n将source中所有属性的值复制到此光照  \n\n\n# RectAreaLight\nRectAreaLight是在一个矩形平面上均匀地发光。 这种灯型可用于模拟光源，如明亮的窗户或条形照明。\n\nps：\n\n不支持阴影  \n仅支持**MeshStandardMaterial**和**MeshPhysicalMaterial**  \n在场景中必须包含**RectAreaLightUniformsLib**\n\n## 使用\n```\nRectAreaLight( color : Integer, intensity : Float, width : Float, height : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）光的强度或亮度。 默认值为1。\nwidth - （可选）灯的宽度。 默认值为10。\nheight - （可选）灯光高度。 默认值为10。\n\n## 属性\n### isRectAreaLight : Boolean\n\n用于检查此类或派生类是否为矩形区光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n## 方法\n### copy  ( source : RectAreaLight ) : RectAreaLight\n将source中所有属性的值复制到此光照  \n\n\n# SpotLight\n## 概念 \n聚光源，这种光从一个方向上的单个点沿着一个锥体发出，该锥体的尺寸越大，距离得到的光越远\n\n## 使用\n```\nSpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )\n```\n\ncolor - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。\nintensity - （可选）灯光强度/强度的数值。 默认值为1。\ndistance - 光的最大范围。 默认值为0（无限制）。\nangle - 从其上限为Math.PI / 2的方向的最大光散射角。\npennumbra - 由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为零。\ndecay - 灯光沿着光线的距离变暗的量\n\n## 属性\n### angle : Float\n聚光灯的最大范围，从光源方向看，以弧度为单位，。 应该不超过Math.PI / 2。 默认值为Math.PI / 3\n\n### castShadow : Boolean\n如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。\n\n### decay : Float\n光线沿光线距离变暗的量  \n在物理校正模式下，decay= 2会导致物理上逼真的光线衰减, \n默认值为1\n\n### distance : Float\n默认模式 - 当距离为零时，灯不会衰减  \n 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  \n \n 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  \n 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的\n\n默认值为0.0\n\n### isSpotLight : Boolean\n\n用于检查此类或派生类是否为聚光光源. 默认为true.  \n不应该更改它，因为它在内部用于优化  \n\n### penumbra : Float\n由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为0.0\n\n### position : Vector3\n默认设置为Object3D.DefaultUp（0,1,0），以便光从上到下发光\n\n### power : Float\n光的强度  \n在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    \n这与intensity成比例关系 ```power = intensity * π```  \n改变这属性也将改变intensity \n\n### shadow : SpotLightShadow\n用于计算此灯光的阴影SpotLightShadow\n\n### target : Object3D\nSpotlight从其光源位置指向target.position。 目标的默认位置是（0,0,0）。\n注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中\n```\nscene.add( light.target ) \n```  \n这样，目标的matrixWorld每帧都会自动更新\n\n也可以将目标设置为场景中的另一个对象（具有position属性的任何对象），如下所示\n\n\tvar targetObject = new THREE.Object3D();\n\tscene.add(targetObject);\n\n\tlight.target = targetObject;\n\t\n聚光灯现在将跟踪目标对象\n\n\n## 方法\n### copy  ( source : SpotLight ) : SpotLight\n将source中所有属性的值复制到此光照  \n","slug":"threejs 解读 light","published":1,"date":"2018-12-24T15:48:27.770Z","updated":"2018-12-24T15:48:27.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq2hxq7q0000ggjgr5ondkxg","content":"<h1 id=\"AmbientLight\"><a href=\"#AmbientLight\" class=\"headerlink\" title=\"AmbientLight\"></a>AmbientLight</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此光照均匀地照亮场景中的所有对象<br>此灯不能用于投射阴影，因为它没有方向</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AmbientLight( color : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>color — 光源颜色的RGB数值, 默认0xffffff<br>intensity – 光源强度的数值， 默认1</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean\"><a href=\"#castShadow-Boolean\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>这在构造函数中设置为undefined，因为环境光不能投射阴影。</p>\n<h3 id=\"isAmbientLight-Boolean\"><a href=\"#isAmbientLight-Boolean\" class=\"headerlink\" title=\"isAmbientLight : Boolean\"></a>isAmbientLight : Boolean</h3><p>用于检查此类或派生类是否为环境光. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h1 id=\"DirectionalLight\"><a href=\"#DirectionalLight\" class=\"headerlink\" title=\"DirectionalLight\"></a>DirectionalLight</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>一种沿特定方向发射的光。 这种光的行为就好像它是无限远的，并且由它产生的光线都是平行的。 常见的用例是模拟日光; 太阳足够远，它的位置可以被认为是无限的，并且来自它的所有光线都是平行的。</p>\n<p><strong>关于位置，目标和旋转的注释</strong><br>方向灯的一个常见混淆点是设置旋转无效。 这是因为three.js的DirectionalLight与其他应用程序中通常称为“Target Direct Light”的东西相当。</p>\n<p>这意味着它的方向被计算为从光的位置指向目标的位置（而不是仅具有旋转分量的’自由直接光’）。</p>\n<p>这样做的原因是允许灯光投射阴影 - 阴影相机需要一个位置来计算阴影。</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DirectionalLight( color : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>color  - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean-1\"><a href=\"#castShadow-Boolean-1\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。</p>\n<h3 id=\"isDirectionalLight-Boolean\"><a href=\"#isDirectionalLight-Boolean\" class=\"headerlink\" title=\"isDirectionalLight : Boolean\"></a>isDirectionalLight : Boolean</h3><p>用于检查此类或派生类是否为平行光. 默认为true.<br>不应该更改它，因为它在内部用于优化    </p>\n<h3 id=\"position-Vector3\"><a href=\"#position-Vector3\" class=\"headerlink\" title=\"position : Vector3\"></a>position : Vector3</h3><p>这被默认设置为<strong>Object3D.DefaultUp（0,1,0）</strong>，以便光从上到下发光</p>\n<h3 id=\"shadow-DirectionalLightShadow\"><a href=\"#shadow-DirectionalLightShadow\" class=\"headerlink\" title=\"shadow : DirectionalLightShadow\"></a>shadow : DirectionalLightShadow</h3><p>用于计算此灯光的阴影<strong>DirectionalLightShadow</strong> </p>\n<h3 id=\"target-Object3D\"><a href=\"#target-Object3D\" class=\"headerlink\" title=\"target : Object3D\"></a>target : Object3D</h3><p>DirectionalLight从其位置指向target.position。 目标的默认位置是（0,0,0）。<br>注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-DirectionalLight-DirectionalLight\"><a href=\"#copy-source-DirectionalLight-DirectionalLight\" class=\"headerlink\" title=\"copy( source : DirectionalLight ) : DirectionalLight\"></a>copy( source : DirectionalLight ) : DirectionalLight</h3><p>将source中所有属性的值复制到此DirectionalLight  </p>\n<h1 id=\"HemisphereLight\"><a href=\"#HemisphereLight\" class=\"headerlink\" title=\"HemisphereLight\"></a>HemisphereLight</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>直接位于场景上方的光源，颜色从天空颜色渐变到底色。</p>\n<p>此灯不能用于投射阴影</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>skyColor - （可选）天空的十六进制颜色。 默认值为0xffffff。<br>groundColor - （可选）地面的十六进制颜色。 默认值为0xffffff。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。  </p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean-2\"><a href=\"#castShadow-Boolean-2\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>这在构造函数中设置为undefined，因为半球光不能投射阴影</p>\n<h3 id=\"color-Float\"><a href=\"#color-Float\" class=\"headerlink\" title=\"color : Float\"></a>color : Float</h3><p>灯光的天空颜色，在构造函数中传递。 默认值是（0xffffff）</p>\n<h3 id=\"groundColor-Float\"><a href=\"#groundColor-Float\" class=\"headerlink\" title=\"groundColor : Float\"></a>groundColor : Float</h3><p>灯光的地面颜色，在构造函数中传递。 默认值是（0xffffff）</p>\n<h3 id=\"isHemisphereLight-Boolean\"><a href=\"#isHemisphereLight-Boolean\" class=\"headerlink\" title=\"isHemisphereLight : Boolean\"></a>isHemisphereLight : Boolean</h3><p>用于检查此类或派生类是否为半球光. 默认为true.<br>不应该更改它，因为它在内部用于优化    </p>\n<h3 id=\"position-Vector3-1\"><a href=\"#position-Vector3-1\" class=\"headerlink\" title=\"position : Vector3\"></a>position : Vector3</h3><p>这被默认设置为<strong>Object3D.DefaultUp（0,1,0）</strong>，以便光从上到下发光</p>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-HemisphereLight-HemisphereLight\"><a href=\"#copy-source-HemisphereLight-HemisphereLight\" class=\"headerlink\" title=\"copy ( source : HemisphereLight ) : HemisphereLight\"></a>copy ( source : HemisphereLight ) : HemisphereLight</h3><p>将source中 color, intensity and groundColor属性的值复制到此光照  </p>\n<h1 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h1><h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>灯的抽象基类 - 所有其他灯类型都继承了此处描述的属性和方法</p>\n<h2 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Light( color : Integer, intensity : float )</span><br></pre></td></tr></table></figure>\n<p>color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<p>创造一个新的光。 请注意，这不是要直接调用（而是使用派生类之一）</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color\"><a href=\"#color-Color\" class=\"headerlink\" title=\"color: Color\"></a>color: Color</h3><p>光的颜色。 如果未在构造函数中传递，则默认为将新颜色设置为白色</p>\n<h3 id=\"intensity-Float\"><a href=\"#intensity-Float\" class=\"headerlink\" title=\"intensity : Float\"></a>intensity : Float</h3><p>光的强度或强度。<br>在物理上正确的模式中，颜色*强度的乘积被解释为在坎德拉中测量的发光强度。<br>默认值 - 1.0</p>\n<h3 id=\"isLight-Boolean\"><a href=\"#isLight-Boolean\" class=\"headerlink\" title=\"isLight : Boolean\"></a>isLight : Boolean</h3><p>用于检查此类或派生类是否为光照. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-Light-Light\"><a href=\"#copy-source-Light-Light\" class=\"headerlink\" title=\"copy ( source : Light ) : Light\"></a>copy ( source : Light ) : Light</h3><p>将source中 color, intensity 属性的值复制到此光照  </p>\n<p>###toJSON ( meta : String )<br>返回JSON格式的光照数据</p>\n<h1 id=\"PointLight\"><a href=\"#PointLight\" class=\"headerlink\" title=\"PointLight\"></a>PointLight</h1><h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从所有方向的单个点发出的光。 一个常见的用例是复制裸灯泡发出的光。</p>\n<h2 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</span><br></pre></td></tr></table></figure>\n<p>color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<p>distance - 光的最大范围。 默认值为0（无限制）。<br>decay - 灯光沿着光线的距离变暗的量。 默认值为1. 对于物理上正确的照明，请将其设置为2</p>\n<h2 id=\"属性-4\"><a href=\"#属性-4\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"decay-Float\"><a href=\"#decay-Float\" class=\"headerlink\" title=\"decay : Float\"></a>decay : Float</h3><p>光线沿光线距离变暗的量<br>在物理校正模式下，衰减= 2会模拟物理上逼真的光线衰减。<br>默认值为1。</p>\n<h3 id=\"distance-Float\"><a href=\"#distance-Float\" class=\"headerlink\" title=\"distance : Float\"></a>distance : Float</h3><p>默认模式 - 当距离为零时，灯不会衰减<br> 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  </p>\n<p> 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离<br> 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的</p>\n<p>默认值为0.0</p>\n<h3 id=\"isPointLight-Boolean\"><a href=\"#isPointLight-Boolean\" class=\"headerlink\" title=\"isPointLight : Boolean\"></a>isPointLight : Boolean</h3><p>用于检查此类或派生类是否为点光源. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h3 id=\"power-Float\"><a href=\"#power-Float\" class=\"headerlink\" title=\"power : Float\"></a>power : Float</h3><p>光的强度<br>在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI<br>这与intensity成比例关系 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">改变这属性也将改变intensity </span><br><span class=\"line\"></span><br><span class=\"line\">###shadow : LightShadow  </span><br><span class=\"line\"></span><br><span class=\"line\">用于计算此灯光阴影的LightShadow。</span><br><span class=\"line\"></span><br><span class=\"line\">lightShadow的相机被设置为PerspectiveCamera，fov为90, aspect为1，near 为0.5，far为500。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### copy  ( source : PointLight ) : PointLight</span><br><span class=\"line\">将source中所有属性的值复制到此光照  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># RectAreaLight</span><br><span class=\"line\">RectAreaLight是在一个矩形平面上均匀地发光。 这种灯型可用于模拟光源，如明亮的窗户或条形照明。</span><br><span class=\"line\"></span><br><span class=\"line\">ps：</span><br><span class=\"line\"></span><br><span class=\"line\">不支持阴影  </span><br><span class=\"line\">仅支持**MeshStandardMaterial**和**MeshPhysicalMaterial**  </span><br><span class=\"line\">在场景中必须包含**RectAreaLightUniformsLib**</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>RectAreaLight( color : Integer, intensity : Float, width : Float, height : Float )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。</span><br><span class=\"line\">intensity - （可选）光的强度或亮度。 默认值为1。</span><br><span class=\"line\">width - （可选）灯的宽度。 默认值为10。</span><br><span class=\"line\">height - （可选）灯光高度。 默认值为10。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### isRectAreaLight : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为矩形区光源. 默认为true.  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### copy  ( source : RectAreaLight ) : RectAreaLight</span><br><span class=\"line\">将source中所有属性的值复制到此光照  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># SpotLight</span><br><span class=\"line\">## 概念 </span><br><span class=\"line\">聚光源，这种光从一个方向上的单个点沿着一个锥体发出，该锥体的尺寸越大，距离得到的光越远</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>SpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。</span><br><span class=\"line\">intensity - （可选）灯光强度/强度的数值。 默认值为1。</span><br><span class=\"line\">distance - 光的最大范围。 默认值为0（无限制）。</span><br><span class=\"line\">angle - 从其上限为Math.PI / 2的方向的最大光散射角。</span><br><span class=\"line\">pennumbra - 由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为零。</span><br><span class=\"line\">decay - 灯光沿着光线的距离变暗的量</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### angle : Float</span><br><span class=\"line\">聚光灯的最大范围，从光源方向看，以弧度为单位，。 应该不超过Math.PI / 2。 默认值为Math.PI / 3</span><br><span class=\"line\"></span><br><span class=\"line\">### castShadow : Boolean</span><br><span class=\"line\">如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。</span><br><span class=\"line\"></span><br><span class=\"line\">### decay : Float</span><br><span class=\"line\">光线沿光线距离变暗的量  </span><br><span class=\"line\">在物理校正模式下，decay= 2会导致物理上逼真的光线衰减, </span><br><span class=\"line\">默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### distance : Float</span><br><span class=\"line\">默认模式 - 当距离为零时，灯不会衰减  </span><br><span class=\"line\"> 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  </span><br><span class=\"line\"> </span><br><span class=\"line\"> 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  </span><br><span class=\"line\"> 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的</span><br><span class=\"line\"></span><br><span class=\"line\">默认值为0.0</span><br><span class=\"line\"></span><br><span class=\"line\">### isSpotLight : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为聚光光源. 默认为true.  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">### penumbra : Float</span><br><span class=\"line\">由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为0.0</span><br><span class=\"line\"></span><br><span class=\"line\">### position : Vector3</span><br><span class=\"line\">默认设置为Object3D.DefaultUp（0,1,0），以便光从上到下发光</span><br><span class=\"line\"></span><br><span class=\"line\">### power : Float</span><br><span class=\"line\">光的强度  </span><br><span class=\"line\">在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    </span><br><span class=\"line\">这与intensity成比例关系 ```power = intensity * π```  </span><br><span class=\"line\">改变这属性也将改变intensity </span><br><span class=\"line\"></span><br><span class=\"line\">### shadow : SpotLightShadow</span><br><span class=\"line\">用于计算此灯光的阴影SpotLightShadow</span><br><span class=\"line\"></span><br><span class=\"line\">### target : Object3D</span><br><span class=\"line\">Spotlight从其光源位置指向target.position。 目标的默认位置是（0,0,0）。</span><br><span class=\"line\">注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中</span><br></pre></td></tr></table></figure></p>\n<p>scene.add( light.target )<br><code>`</code><br>这样，目标的matrixWorld每帧都会自动更新</p>\n<p>也可以将目标设置为场景中的另一个对象（具有position属性的任何对象），如下所示</p>\n<pre><code>var targetObject = new THREE.Object3D();\nscene.add(targetObject);\n\nlight.target = targetObject;\n</code></pre><p>聚光灯现在将跟踪目标对象</p>\n<h2 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-SpotLight-SpotLight\"><a href=\"#copy-source-SpotLight-SpotLight\" class=\"headerlink\" title=\"copy  ( source : SpotLight ) : SpotLight\"></a>copy  ( source : SpotLight ) : SpotLight</h3><p>将source中所有属性的值复制到此光照  </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AmbientLight\"><a href=\"#AmbientLight\" class=\"headerlink\" title=\"AmbientLight\"></a>AmbientLight</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>此光照均匀地照亮场景中的所有对象<br>此灯不能用于投射阴影，因为它没有方向</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AmbientLight( color : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>color — 光源颜色的RGB数值, 默认0xffffff<br>intensity – 光源强度的数值， 默认1</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean\"><a href=\"#castShadow-Boolean\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>这在构造函数中设置为undefined，因为环境光不能投射阴影。</p>\n<h3 id=\"isAmbientLight-Boolean\"><a href=\"#isAmbientLight-Boolean\" class=\"headerlink\" title=\"isAmbientLight : Boolean\"></a>isAmbientLight : Boolean</h3><p>用于检查此类或派生类是否为环境光. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h1 id=\"DirectionalLight\"><a href=\"#DirectionalLight\" class=\"headerlink\" title=\"DirectionalLight\"></a>DirectionalLight</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>一种沿特定方向发射的光。 这种光的行为就好像它是无限远的，并且由它产生的光线都是平行的。 常见的用例是模拟日光; 太阳足够远，它的位置可以被认为是无限的，并且来自它的所有光线都是平行的。</p>\n<p><strong>关于位置，目标和旋转的注释</strong><br>方向灯的一个常见混淆点是设置旋转无效。 这是因为three.js的DirectionalLight与其他应用程序中通常称为“Target Direct Light”的东西相当。</p>\n<p>这意味着它的方向被计算为从光的位置指向目标的位置（而不是仅具有旋转分量的’自由直接光’）。</p>\n<p>这样做的原因是允许灯光投射阴影 - 阴影相机需要一个位置来计算阴影。</p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DirectionalLight( color : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>color  - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean-1\"><a href=\"#castShadow-Boolean-1\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。</p>\n<h3 id=\"isDirectionalLight-Boolean\"><a href=\"#isDirectionalLight-Boolean\" class=\"headerlink\" title=\"isDirectionalLight : Boolean\"></a>isDirectionalLight : Boolean</h3><p>用于检查此类或派生类是否为平行光. 默认为true.<br>不应该更改它，因为它在内部用于优化    </p>\n<h3 id=\"position-Vector3\"><a href=\"#position-Vector3\" class=\"headerlink\" title=\"position : Vector3\"></a>position : Vector3</h3><p>这被默认设置为<strong>Object3D.DefaultUp（0,1,0）</strong>，以便光从上到下发光</p>\n<h3 id=\"shadow-DirectionalLightShadow\"><a href=\"#shadow-DirectionalLightShadow\" class=\"headerlink\" title=\"shadow : DirectionalLightShadow\"></a>shadow : DirectionalLightShadow</h3><p>用于计算此灯光的阴影<strong>DirectionalLightShadow</strong> </p>\n<h3 id=\"target-Object3D\"><a href=\"#target-Object3D\" class=\"headerlink\" title=\"target : Object3D\"></a>target : Object3D</h3><p>DirectionalLight从其位置指向target.position。 目标的默认位置是（0,0,0）。<br>注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-DirectionalLight-DirectionalLight\"><a href=\"#copy-source-DirectionalLight-DirectionalLight\" class=\"headerlink\" title=\"copy( source : DirectionalLight ) : DirectionalLight\"></a>copy( source : DirectionalLight ) : DirectionalLight</h3><p>将source中所有属性的值复制到此DirectionalLight  </p>\n<h1 id=\"HemisphereLight\"><a href=\"#HemisphereLight\" class=\"headerlink\" title=\"HemisphereLight\"></a>HemisphereLight</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>直接位于场景上方的光源，颜色从天空颜色渐变到底色。</p>\n<p>此灯不能用于投射阴影</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )</span><br></pre></td></tr></table></figure>\n<p>skyColor - （可选）天空的十六进制颜色。 默认值为0xffffff。<br>groundColor - （可选）地面的十六进制颜色。 默认值为0xffffff。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。  </p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"castShadow-Boolean-2\"><a href=\"#castShadow-Boolean-2\" class=\"headerlink\" title=\"castShadow : Boolean\"></a>castShadow : Boolean</h3><p>这在构造函数中设置为undefined，因为半球光不能投射阴影</p>\n<h3 id=\"color-Float\"><a href=\"#color-Float\" class=\"headerlink\" title=\"color : Float\"></a>color : Float</h3><p>灯光的天空颜色，在构造函数中传递。 默认值是（0xffffff）</p>\n<h3 id=\"groundColor-Float\"><a href=\"#groundColor-Float\" class=\"headerlink\" title=\"groundColor : Float\"></a>groundColor : Float</h3><p>灯光的地面颜色，在构造函数中传递。 默认值是（0xffffff）</p>\n<h3 id=\"isHemisphereLight-Boolean\"><a href=\"#isHemisphereLight-Boolean\" class=\"headerlink\" title=\"isHemisphereLight : Boolean\"></a>isHemisphereLight : Boolean</h3><p>用于检查此类或派生类是否为半球光. 默认为true.<br>不应该更改它，因为它在内部用于优化    </p>\n<h3 id=\"position-Vector3-1\"><a href=\"#position-Vector3-1\" class=\"headerlink\" title=\"position : Vector3\"></a>position : Vector3</h3><p>这被默认设置为<strong>Object3D.DefaultUp（0,1,0）</strong>，以便光从上到下发光</p>\n<h2 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-HemisphereLight-HemisphereLight\"><a href=\"#copy-source-HemisphereLight-HemisphereLight\" class=\"headerlink\" title=\"copy ( source : HemisphereLight ) : HemisphereLight\"></a>copy ( source : HemisphereLight ) : HemisphereLight</h3><p>将source中 color, intensity and groundColor属性的值复制到此光照  </p>\n<h1 id=\"Light\"><a href=\"#Light\" class=\"headerlink\" title=\"Light\"></a>Light</h1><h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>灯的抽象基类 - 所有其他灯类型都继承了此处描述的属性和方法</p>\n<h2 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Light( color : Integer, intensity : float )</span><br></pre></td></tr></table></figure>\n<p>color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<p>创造一个新的光。 请注意，这不是要直接调用（而是使用派生类之一）</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"color-Color\"><a href=\"#color-Color\" class=\"headerlink\" title=\"color: Color\"></a>color: Color</h3><p>光的颜色。 如果未在构造函数中传递，则默认为将新颜色设置为白色</p>\n<h3 id=\"intensity-Float\"><a href=\"#intensity-Float\" class=\"headerlink\" title=\"intensity : Float\"></a>intensity : Float</h3><p>光的强度或强度。<br>在物理上正确的模式中，颜色*强度的乘积被解释为在坎德拉中测量的发光强度。<br>默认值 - 1.0</p>\n<h3 id=\"isLight-Boolean\"><a href=\"#isLight-Boolean\" class=\"headerlink\" title=\"isLight : Boolean\"></a>isLight : Boolean</h3><p>用于检查此类或派生类是否为光照. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h2 id=\"方法-2\"><a href=\"#方法-2\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-Light-Light\"><a href=\"#copy-source-Light-Light\" class=\"headerlink\" title=\"copy ( source : Light ) : Light\"></a>copy ( source : Light ) : Light</h3><p>将source中 color, intensity 属性的值复制到此光照  </p>\n<p>###toJSON ( meta : String )<br>返回JSON格式的光照数据</p>\n<h1 id=\"PointLight\"><a href=\"#PointLight\" class=\"headerlink\" title=\"PointLight\"></a>PointLight</h1><h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从所有方向的单个点发出的光。 一个常见的用例是复制裸灯泡发出的光。</p>\n<h2 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PointLight( color : Integer, intensity : Float, distance : Number, decay : Float )</span><br></pre></td></tr></table></figure>\n<p>color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。<br>intensity - （可选）灯光强度/强度的数值。 默认值为1。</p>\n<p>distance - 光的最大范围。 默认值为0（无限制）。<br>decay - 灯光沿着光线的距离变暗的量。 默认值为1. 对于物理上正确的照明，请将其设置为2</p>\n<h2 id=\"属性-4\"><a href=\"#属性-4\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"decay-Float\"><a href=\"#decay-Float\" class=\"headerlink\" title=\"decay : Float\"></a>decay : Float</h3><p>光线沿光线距离变暗的量<br>在物理校正模式下，衰减= 2会模拟物理上逼真的光线衰减。<br>默认值为1。</p>\n<h3 id=\"distance-Float\"><a href=\"#distance-Float\" class=\"headerlink\" title=\"distance : Float\"></a>distance : Float</h3><p>默认模式 - 当距离为零时，灯不会衰减<br> 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  </p>\n<p> 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离<br> 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的</p>\n<p>默认值为0.0</p>\n<h3 id=\"isPointLight-Boolean\"><a href=\"#isPointLight-Boolean\" class=\"headerlink\" title=\"isPointLight : Boolean\"></a>isPointLight : Boolean</h3><p>用于检查此类或派生类是否为点光源. 默认为true.<br>不应该更改它，因为它在内部用于优化  </p>\n<h3 id=\"power-Float\"><a href=\"#power-Float\" class=\"headerlink\" title=\"power : Float\"></a>power : Float</h3><p>光的强度<br>在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI<br>这与intensity成比例关系 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">改变这属性也将改变intensity </span><br><span class=\"line\"></span><br><span class=\"line\">###shadow : LightShadow  </span><br><span class=\"line\"></span><br><span class=\"line\">用于计算此灯光阴影的LightShadow。</span><br><span class=\"line\"></span><br><span class=\"line\">lightShadow的相机被设置为PerspectiveCamera，fov为90, aspect为1，near 为0.5，far为500。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### copy  ( source : PointLight ) : PointLight</span><br><span class=\"line\">将source中所有属性的值复制到此光照  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># RectAreaLight</span><br><span class=\"line\">RectAreaLight是在一个矩形平面上均匀地发光。 这种灯型可用于模拟光源，如明亮的窗户或条形照明。</span><br><span class=\"line\"></span><br><span class=\"line\">ps：</span><br><span class=\"line\"></span><br><span class=\"line\">不支持阴影  </span><br><span class=\"line\">仅支持**MeshStandardMaterial**和**MeshPhysicalMaterial**  </span><br><span class=\"line\">在场景中必须包含**RectAreaLightUniformsLib**</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>RectAreaLight( color : Integer, intensity : Float, width : Float, height : Float )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。</span><br><span class=\"line\">intensity - （可选）光的强度或亮度。 默认值为1。</span><br><span class=\"line\">width - （可选）灯的宽度。 默认值为10。</span><br><span class=\"line\">height - （可选）灯光高度。 默认值为10。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### isRectAreaLight : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为矩形区光源. 默认为true.  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">## 方法</span><br><span class=\"line\">### copy  ( source : RectAreaLight ) : RectAreaLight</span><br><span class=\"line\">将source中所有属性的值复制到此光照  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># SpotLight</span><br><span class=\"line\">## 概念 </span><br><span class=\"line\">聚光源，这种光从一个方向上的单个点沿着一个锥体发出，该锥体的尺寸越大，距离得到的光越远</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用</span><br></pre></td></tr></table></figure></p>\n<p>SpotLight( color : Integer, intensity : Float, distance : Float, angle : Radians, penumbra : Float, decay : Float )<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">color - （可选）十六进制颜色的光。 默认值为0xffffff（白色）。</span><br><span class=\"line\">intensity - （可选）灯光强度/强度的数值。 默认值为1。</span><br><span class=\"line\">distance - 光的最大范围。 默认值为0（无限制）。</span><br><span class=\"line\">angle - 从其上限为Math.PI / 2的方向的最大光散射角。</span><br><span class=\"line\">pennumbra - 由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为零。</span><br><span class=\"line\">decay - 灯光沿着光线的距离变暗的量</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性</span><br><span class=\"line\">### angle : Float</span><br><span class=\"line\">聚光灯的最大范围，从光源方向看，以弧度为单位，。 应该不超过Math.PI / 2。 默认值为Math.PI / 3</span><br><span class=\"line\"></span><br><span class=\"line\">### castShadow : Boolean</span><br><span class=\"line\">如果设置为true，则会投射动态阴影。 警告：不停的调整阴影以使其看起来正常，这很消耗性能。</span><br><span class=\"line\"></span><br><span class=\"line\">### decay : Float</span><br><span class=\"line\">光线沿光线距离变暗的量  </span><br><span class=\"line\">在物理校正模式下，decay= 2会导致物理上逼真的光线衰减, </span><br><span class=\"line\">默认值为1</span><br><span class=\"line\"></span><br><span class=\"line\">### distance : Float</span><br><span class=\"line\">默认模式 - 当距离为零时，灯不会衰减  </span><br><span class=\"line\"> 当距离不为零时，光线将从光线位置处的最大强度线性衰减到距离光线此距离处的零点  </span><br><span class=\"line\"> </span><br><span class=\"line\"> 物理校正模式 - 当距离为零时，光将根据反平方定律衰减到无限远距离  </span><br><span class=\"line\"> 当距离不为零时，光将根据反平方定律衰减，直到接近距离截止，然后它将快速平滑地衰减到0.当然，截止在物理上是不正确的</span><br><span class=\"line\"></span><br><span class=\"line\">默认值为0.0</span><br><span class=\"line\"></span><br><span class=\"line\">### isSpotLight : Boolean</span><br><span class=\"line\"></span><br><span class=\"line\">用于检查此类或派生类是否为聚光光源. 默认为true.  </span><br><span class=\"line\">不应该更改它，因为它在内部用于优化  </span><br><span class=\"line\"></span><br><span class=\"line\">### penumbra : Float</span><br><span class=\"line\">由于半影而衰减的聚光锥的百分比。 取值介于0和1之间。默认值为0.0</span><br><span class=\"line\"></span><br><span class=\"line\">### position : Vector3</span><br><span class=\"line\">默认设置为Object3D.DefaultUp（0,1,0），以便光从上到下发光</span><br><span class=\"line\"></span><br><span class=\"line\">### power : Float</span><br><span class=\"line\">光的强度  </span><br><span class=\"line\">在物理校正模式下，光的发光功率以流明为单位测量。 默认值为4Math.PI    </span><br><span class=\"line\">这与intensity成比例关系 ```power = intensity * π```  </span><br><span class=\"line\">改变这属性也将改变intensity </span><br><span class=\"line\"></span><br><span class=\"line\">### shadow : SpotLightShadow</span><br><span class=\"line\">用于计算此灯光的阴影SpotLightShadow</span><br><span class=\"line\"></span><br><span class=\"line\">### target : Object3D</span><br><span class=\"line\">Spotlight从其光源位置指向target.position。 目标的默认位置是（0,0,0）。</span><br><span class=\"line\">注意：要将目标的位置更改为默认值以外的任何位置，必须将其添加到场景中</span><br></pre></td></tr></table></figure></p>\n<p>scene.add( light.target )<br><code>`</code><br>这样，目标的matrixWorld每帧都会自动更新</p>\n<p>也可以将目标设置为场景中的另一个对象（具有position属性的任何对象），如下所示</p>\n<pre><code>var targetObject = new THREE.Object3D();\nscene.add(targetObject);\n\nlight.target = targetObject;\n</code></pre><p>聚光灯现在将跟踪目标对象</p>\n<h2 id=\"方法-3\"><a href=\"#方法-3\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"copy-source-SpotLight-SpotLight\"><a href=\"#copy-source-SpotLight-SpotLight\" class=\"headerlink\" title=\"copy  ( source : SpotLight ) : SpotLight\"></a>copy  ( source : SpotLight ) : SpotLight</h3><p>将source中所有属性的值复制到此光照  </p>\n"},{"title":"threejs 解读  geometry","_content":"\n# BoxGeometry\n\n## 概念\n盒子几何模型，长、宽、高可不等\n\n## 使用\n```\nBoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n```\nwidth - x轴上的宽度，默认为1  \nheight - y轴上的高度，默认为1  \ndepth - z轴上的深度，默认为1  \nwidthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1  \nheightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1  \ndepthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n# BoxBufferGeometry\n##概念\n BoxGeometry 部分的 BufferGeometry \n \n## 使用\n```\nBoxBufferGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n```\n\nwidth - x轴上的宽度，默认为1  \nheight - y轴上的高度，默认为1  \ndepth - z轴上的深度，默认为1  \nwidthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1  \nheightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1  \ndepthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  \n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n\n#CircleGeometry\n##概念\nCircleGeometry是一个简单的欧氏几何形。它是众多三角形面围绕一个中心点并延伸到给定的半径范围而组成。它是用一个开始角度和一个给定的中心角度逆时针建立。它可以用来创建规则的多边形模型，其中分割面的数量决定的面的数量。\n\n\n##使用\n```\nCircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n```\nradius — 圆的半径, 默认为1.\nsegments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.\nthetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).\nthetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n\n\n#CircleBufferGeometry\n##概念\n CircleGeometry 部分的 BufferGeometry \n\n##使用\n```\nCircleBufferGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n```\nradius — 圆的半径, 默认为1.\nsegments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.\nthetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).\nthetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# ConeGeometry\n## 概念\n用于生成锥形几何的类\n\n##使用\n```\nConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\nadius — 锥底半径. 默认值为20  \nheight — 锥体高度. 默认值为100  \nradiusSegments — 围绕圆锥周长的分割面数量. 默认值为8  \nheightSegments — 沿圆锥高度的分割面数量. 默认值为1  \nopenEnded — 指示锥底是否打开, 默认值为false\nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ConeBufferGeometry\n## 概念\nConeGeometry 部分的 BufferGeometry \n\n##使用\n```\nConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\nadius — 锥底半径. 默认值为20  \nheight — 锥体高度. 默认值为100  \nradiusSegments — 围绕圆锥周长的分割面数量. 默认值为8  \nheightSegments — 沿圆锥高度的分割面数量. 默认值为1  \nopenEnded — 指示锥底是否打开, 默认值为false\nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# CylinderGeometry\n## 概念\n用于生成圆柱几何的类\n\n## 使用\n```\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\n\nradiusTop — 圆柱体顶端半径. 默认值为20.  \nradiusBottom — 圆柱体底端半径. 默认值为20.  \nheight — 圆柱体高度. 默认值为100.  \nradiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.  \nheightSegments — 沿圆柱体高度的分割面数量. 默认值为1.  \nopenEnded — 指示圆柱体两端是否打开. 默认值为false  \nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# CylinderBufferGeometry\n## 概念\nCylinderGeometry 部分的 BufferGeometry \n\n## 使用\n```\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\n\nradiusTop — 圆柱体顶端半径. 默认值为20.  \nradiusBottom — 圆柱体底端半径. 默认值为20.  \nheight — 圆柱体高度. 默认值为100.  \nradiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.  \nheightSegments — 沿圆柱体高度的分割面数量. 默认值为1.  \nopenEnded — 指示圆柱体两端是否打开. 默认值为false  \nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# DodecahedronGeometry\n\n## 概念\n用于生成十二面体几何的类\n\n## 使用\n```\nDodecahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 十二面体的半径. 默认值为1.   \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n\n\n# DodecahedBufferronGeometry\n\n## 概念\nDodecahedonGeometry 部分的 BufferGeometry \n\n## 使用\n```\nDodecahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 十二面体的半径. 默认值为1.   \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeGeometry\n\n## 概念\n这可以用作辅助对象来查看Geometry对象的边缘\n\n## 使用\n```\nEdgesGeometry( geometry : Geometry, thresholdAngle : Integer )\n```\ngeometry - 任何几何对象   \nthresholdAngle - 仅当相邻面的面法线之间的角度（以度为单位）超过此值时，才会渲染边。 默认为1度\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeGeometry\n\n## 概念\n从路径形状创建拉伸几何体\n\n## 使用\n```\nExtrudeGeometry(shapes : Array, options : Object)\n```\n\nshapes — 形状或形状数组  \noptions — 包括下面这些参数的对象.  \n\n* curveSegments — int. 曲线上点的个数  \n* steps — int. 用于细分拉伸的样条段数量\n* depth — int. 拉伸形状的深度\n* bevelEnabled — bool. 打开斜面\n* bevelThickness — float. 在原来的形状里面弄多深的斜面\n* bevelSize — float. 斜面离形状轮廓的距离\n* bevelSegments — int. 斜面层的数量\n* extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状\n* UVGenerator — Object. 提供UV生成器各功能的对象\n\n这个对象将一个2D图形拉伸为一个3D几何体.  \n在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeBufferGeometry\n\n## 概念\n从路径形状创建拉伸几何体\n\n## 使用\n```\nExtrudeBufferGeometry(shapes : Array, options : Object)\n```\n\nshapes — 形状或形状数组  \noptions — 包括下面这些参数的对象.  \n\n* curveSegments — int. 曲线上点的个数  \n* steps — int. 用于细分拉伸的样条段数量\n* depth — int. 拉伸形状的深度\n* bevelEnabled — bool. 打开斜面\n* bevelThickness — float. 在原来的形状里面弄多深的斜面\n* bevelSize — float. 斜面离形状轮廓的距离\n* bevelSegments — int. 斜面层的数量\n* extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状\n* UVGenerator — Object. 提供UV生成器各功能的对象\n\n这个对象将一个2D图形拉伸为一个3D几何体.  \n在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# IcosahedronGeometry\n\n## 概念\n用来创建二十面体几何模型的类\n\n## 使用\n```\nIcosahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# IcosahedronBufferGeometry\n\n## 概念\n用来创建二十面体几何模型的类\n\n## 使用\n```\nIcosahedronBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# LatheGeometry\n## 概念\n创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。\n\n## 使用\n\n```\nLatheGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)\n```\n\npoints — Vector2s数组. X轴上每个点都必须大于0.  \nsegments — 生成圆周段的数目. 默认值为12.  \nphiStart — 起始角度的弧度值. 默认值为0.  \nphiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# LatheBufferGeometry\n## 概念\n创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。\n\n## 使用\n\n```\nLatheBufferGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)\n```\n\npoints — Vector2s数组. X轴上每个点都必须大于0.  \nsegments — 生成圆周段的数目. 默认值为12.  \nphiStart — 起始角度的弧度值. 默认值为0.  \nphiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n\n# OctahedBufferGeometry\n\n## 概念\n用来创建八面体几何模型的类\n\n## 使用\n```\nOctahedGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# OctahedronBufferGeometry\n\n## 概念\n用来创建八面体几何模型的类\n\n## 使用\n```\nOctahedBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ParametricGeometry\n\n## 概念\n生成代表参数化曲面的几何模型\n\n## 使用\n```\nParametricGeometry(func : Function, slices : Integer, stacks : Integer)\n```\n\nfunc — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3  \nslices — 用于参数化函数的切片数量   \nstacks — 用于参数化函数的堆栈数量  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ParametricBufferGeometry\n\n## 概念\n生成代表参数化曲面的几何模型\n\n## 使用\n```\nParametricBufferGeometry(func : Function, slices : Integer, stacks : Integer)\n```\n\nfunc — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3  \nslices — 用于参数化函数的切片数量   \nstacks — 用于参数化函数的堆栈数量  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# PlaneGeometry\n## 概念\n用来生成平面几何模型的类\n\n\n## 使用\n```\nPlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)\n```\n\nwidth — 沿X轴宽度, 默认为1.  \nheight — 沿Y轴高度，默认为1.  \nwidthSegments — 可选参数，x方向的分段数，缺省为1  \nheightSegments — 可选参数，y方向的分段数，缺省为1 \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PlaneBufferGeometry\n## 概念\n用来生成平面几何模型的类\n\n\n## 使用\n```\nPlaneBufferGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)\n```\n\nwidth — 沿X轴宽度, 默认为1.  \nheight — 沿Y轴高度，默认为1.  \nwidthSegments — 可选参数，x方向的分段数，缺省为1  \nheightSegments — 可选参数，y方向的分段数，缺省为1 \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PolyhedronGeometry\n## 概念\n多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面\n\n## 使用\n```\nPolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)\n```\n\nvertices — Array 以 [1,1,1, -1,-1,-1, ... ] 这种形式出现的点的数组    \nfaces — Array 以 [0,1,2, 2,3,0, ... ] 这种形式出现的构成各个面的指数数组   \nradius — Float - 最终形状的半径    \ndetail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PolyhedronBufferGeometry\n## 概念\n多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面\n\n## 使用\n```\nPolyhedronBufferGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)\n```\n\nvertices — Array 以 [1,1,1, -1,-1,-1, ... ] 这种形式出现的点的数组    \nfaces — Array 以 [0,1,2, 2,3,0, ... ] 这种形式出现的构成各个面的指数数组   \nradius — Float - 最终形状的半径    \ndetail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# RingGeometry \n## 概念\n用于生成二维环几何的类\n\n## 使用\n```\nRingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)\n```\n\ninnerRadius — 默认值为0.5.\nouterRadius — 默认值为1. \nthetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8. \nphiSegments — 最小值为1. 默认值为8.\nthetaStart — 开始角度. 默认值为0. \nthetaLength — 圆心角. 默认值为Math.PI * 2.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# RingBufferGeometry \n## 概念\n用于生成二维环几何的类\n\n## 使用\n```\nRingBufferGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)\n```\n\ninnerRadius — 默认值为0.5.\nouterRadius — 默认值为1. \nthetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8. \nphiSegments — 最小值为1. 默认值为8.\nthetaStart — 开始角度. 默认值为0. \nthetaLength — 圆心角. 默认值为Math.PI * 2.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ShapeGeometry \n## 概念\n从一个或多个路径形状创建单面多边形几何\n\n## 使用\n```\nShapeGeometry(shapes : Array, curveSegments : Integer)\n```\nshape - 形状数组或单个形状  \ncurveSegments - 整数 - 每个形状的段数。 默认值为12   \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ShapeBufferGeometry \n## 概念\n从一个或多个路径形状创建单面多边形几何\n\n## 使用\n```\nShapeBufferGeometry(shapes : Array, curveSegments : Integer)\n```\nshape - 形状数组或单个形状  \ncurveSegments - 整数 - 每个形状的段数。 默认值为12   \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# SphereGeometry \n## 概念\n用于生成球体几何的类\n\n## 使用\n```\nSphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)\n```\n\nradius — 球体半径. 默认值为50  \nwidthSegments — 水平分割面的数量. 最小值为3, 默认值为8  \nheightSegments — 垂直分割面的数量. 最小值为2, 默认值为6  \nphiStart — 指定水平起始角度. 默认值为0  \nphiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2  \nthetaStart — 指定垂直起始角度. 默认值为0  \nthetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  \n\n几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于'sphere slices'）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# SphereBufferGeometry \n## 概念\n用于生成球体几何的类\n\n## 使用\n```\nSphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)\n```\n\nradius — 球体半径. 默认值为50  \nwidthSegments — 水平分割面的数量. 最小值为3, 默认值为8  \nheightSegments — 垂直分割面的数量. 最小值为2, 默认值为6  \nphiStart — 指定水平起始角度. 默认值为0  \nphiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2  \nthetaStart — 指定垂直起始角度. 默认值为0  \nthetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  \n\n几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于'sphere slices'）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TetrahedronGeometry\n## 概念\n用于生成四面体几何的类\n\n## 使用\n```\nTetrahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 四面体半径. 默认值为1.    \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# TetrahedronBufferGeometry\n## 概念\n用于生成四面体几何的类\n\n## 使用\n```\nTetrahedronBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 四面体半径. 默认值为1.    \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TextGeometry\n## 概念\n用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的\n\n## 使用\n```\nTextGeometry(text : String, parameters : Object)\n```\ntext — 要显示的文字   \nparameters — 包含下面这些参数的对象  \n\n* font — THREE.Font. 字体实例.\n* size — Float. 文字大小， 默认为100.\n* height — Float. 文字厚度. 默认值为50.   \n* curveSegments — Integer. 曲线上点的数量. 默认值为12.\n* bevelEnabled — Boolean. 是否打开斜面. 默认值为False.\n* bevelThickness — Float. 文本斜面的深度. 默认值为10.\n* bevelSize — Float. 斜面离轮廓的距离. 默认值为8.\n* bevelSegments - Integer. 斜角段数. 默认值为3.\n* \n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TextBufferGeometry\n## 概念\n用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的\n\n## 使用\n```\nTextBufferGeometry(text : String, parameters : Object)\n```\ntext — 要显示的文字   \nparameters — 包含下面这些参数的对象  \n\n* font — THREE.Font. 字体实例.\n* size — Float. 文字大小， 默认为100.\n* height — Float. 文字厚度. 默认值为50.   \n* curveSegments — Integer. 曲线上点的数量. 默认值为12.\n* bevelEnabled — Boolean. 是否打开斜面. 默认值为False.\n* bevelThickness — Float. 文本斜面的深度. 默认值为10.\n* bevelSize — Float. 斜面离轮廓的距离. 默认值为8.\n* bevelSegments - Integer. 斜角段数. 默认值为3.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusGeometry\n## 概念\n用于生成圆环几何的类\n\n## 使用\n```\nTorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)\n```\n\nradius — 半径, 默认值为1.   \ntube — 管道直径. 默认值为 0.4.   \nradialSegments — 默认值为8   \ntubularSegments — 默认值为6.     \narc — 圆心角. 默认值为Math.PI * 2.  \n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusBufferGeometry\n## 概念\n用于生成圆环几何的类\n\n## 使用\n```\nTorusBufferGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)\n```\n\nradius — 半径, 默认值为1.   \ntube — 管道直径. 默认值为 0.4.   \nradialSegments — 默认值为8   \ntubularSegments — 默认值为6.     \narc — 圆心角. 默认值为Math.PI * 2.  \n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusKnotGeometry\n## 概念\n\n创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。\n\n## 使用\n```\nTorusKnotGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)\n```\nradius — 半径, 默认值为1.  \ntube — 管道直径. 默认值为 0.4.\ntubularSegments — 默认值为64.  \nradialSegments — 默认值为8.  \np — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.  \nq — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusKnotBufferGeometry\n## 概念\n\n创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。\n\n## 使用\n```\nTorusKnotBufferGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)\n```\nradius — 半径, 默认值为1.  \ntube — 管道直径. 默认值为 0.4.\ntubularSegments — 默认值为64.  \nradialSegments — 默认值为8.  \np — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.  \nq — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3. \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TubeGeometry \n## 概念\n创建一个沿3d曲线挤出的管子\n\n## 使用\n```\nTubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)\n```\n\npath — Curve - 从 Curve 基本类继承而来的路径  \nsegments — Integer - 组成管道的分割面数量, 默认值为64  \nradius — Float - 管道半径, 默认值为1  \nradiusSegments — Integer - 组成截面的分割面数量, 默认值为8   \nclosed — Boolean 管道是开放的还是闭合的, 默认值为false   \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TubeBufferGeometry \n## 概念\n创建一个沿3d曲线挤出的管子\n\n## 使用\n```\nTubeBufferGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)\n```\n\npath — Curve - 从 Curve 基本类继承而来的路径  \nsegments — Integer - 组成管道的分割面数量, 默认值为64  \nradius — Float - 管道半径, 默认值为1  \nradiusSegments — Integer - 组成截面的分割面数量, 默认值为8   \nclosed — Boolean 管道是开放的还是闭合的, 默认值为false   \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# WireframeGeometry\n## 概念\n这可以用作辅助对象，从线框角度观察Geometry对象\n\n## 使用\n```\nWireframeGeometry( geometry : Geometry )\n```\ngeometry — 任何几何对象\n\n","source":"_posts/threejs 解读 geometry.md","raw":"title:      \"threejs 解读  geometry\"\ntags:\n    - js threejs\n---\n\n# BoxGeometry\n\n## 概念\n盒子几何模型，长、宽、高可不等\n\n## 使用\n```\nBoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n```\nwidth - x轴上的宽度，默认为1  \nheight - y轴上的高度，默认为1  \ndepth - z轴上的深度，默认为1  \nwidthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1  \nheightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1  \ndepthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n# BoxBufferGeometry\n##概念\n BoxGeometry 部分的 BufferGeometry \n \n## 使用\n```\nBoxBufferGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n```\n\nwidth - x轴上的宽度，默认为1  \nheight - y轴上的高度，默认为1  \ndepth - z轴上的深度，默认为1  \nwidthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1  \nheightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1  \ndepthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  \n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n\n#CircleGeometry\n##概念\nCircleGeometry是一个简单的欧氏几何形。它是众多三角形面围绕一个中心点并延伸到给定的半径范围而组成。它是用一个开始角度和一个给定的中心角度逆时针建立。它可以用来创建规则的多边形模型，其中分割面的数量决定的面的数量。\n\n\n##使用\n```\nCircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n```\nradius — 圆的半径, 默认为1.\nsegments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.\nthetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).\nthetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何\n\n\n\n#CircleBufferGeometry\n##概念\n CircleGeometry 部分的 BufferGeometry \n\n##使用\n```\nCircleBufferGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n```\nradius — 圆的半径, 默认为1.\nsegments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.\nthetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).\nthetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# ConeGeometry\n## 概念\n用于生成锥形几何的类\n\n##使用\n```\nConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\nadius — 锥底半径. 默认值为20  \nheight — 锥体高度. 默认值为100  \nradiusSegments — 围绕圆锥周长的分割面数量. 默认值为8  \nheightSegments — 沿圆锥高度的分割面数量. 默认值为1  \nopenEnded — 指示锥底是否打开, 默认值为false\nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ConeBufferGeometry\n## 概念\nConeGeometry 部分的 BufferGeometry \n\n##使用\n```\nConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\nadius — 锥底半径. 默认值为20  \nheight — 锥体高度. 默认值为100  \nradiusSegments — 围绕圆锥周长的分割面数量. 默认值为8  \nheightSegments — 沿圆锥高度的分割面数量. 默认值为1  \nopenEnded — 指示锥底是否打开, 默认值为false\nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# CylinderGeometry\n## 概念\n用于生成圆柱几何的类\n\n## 使用\n```\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\n\nradiusTop — 圆柱体顶端半径. 默认值为20.  \nradiusBottom — 圆柱体底端半径. 默认值为20.  \nheight — 圆柱体高度. 默认值为100.  \nradiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.  \nheightSegments — 沿圆柱体高度的分割面数量. 默认值为1.  \nopenEnded — 指示圆柱体两端是否打开. 默认值为false  \nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# CylinderBufferGeometry\n## 概念\nCylinderGeometry 部分的 BufferGeometry \n\n## 使用\n```\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n```\n\nradiusTop — 圆柱体顶端半径. 默认值为20.  \nradiusBottom — 圆柱体底端半径. 默认值为20.  \nheight — 圆柱体高度. 默认值为100.  \nradiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.  \nheightSegments — 沿圆柱体高度的分割面数量. 默认值为1.  \nopenEnded — 指示圆柱体两端是否打开. 默认值为false  \nthetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).  \nthetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# DodecahedronGeometry\n\n## 概念\n用于生成十二面体几何的类\n\n## 使用\n```\nDodecahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 十二面体的半径. 默认值为1.   \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n\n\n# DodecahedBufferronGeometry\n\n## 概念\nDodecahedonGeometry 部分的 BufferGeometry \n\n## 使用\n```\nDodecahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 十二面体的半径. 默认值为1.   \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeGeometry\n\n## 概念\n这可以用作辅助对象来查看Geometry对象的边缘\n\n## 使用\n```\nEdgesGeometry( geometry : Geometry, thresholdAngle : Integer )\n```\ngeometry - 任何几何对象   \nthresholdAngle - 仅当相邻面的面法线之间的角度（以度为单位）超过此值时，才会渲染边。 默认为1度\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeGeometry\n\n## 概念\n从路径形状创建拉伸几何体\n\n## 使用\n```\nExtrudeGeometry(shapes : Array, options : Object)\n```\n\nshapes — 形状或形状数组  \noptions — 包括下面这些参数的对象.  \n\n* curveSegments — int. 曲线上点的个数  \n* steps — int. 用于细分拉伸的样条段数量\n* depth — int. 拉伸形状的深度\n* bevelEnabled — bool. 打开斜面\n* bevelThickness — float. 在原来的形状里面弄多深的斜面\n* bevelSize — float. 斜面离形状轮廓的距离\n* bevelSegments — int. 斜面层的数量\n* extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状\n* UVGenerator — Object. 提供UV生成器各功能的对象\n\n这个对象将一个2D图形拉伸为一个3D几何体.  \n在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ExtrudeBufferGeometry\n\n## 概念\n从路径形状创建拉伸几何体\n\n## 使用\n```\nExtrudeBufferGeometry(shapes : Array, options : Object)\n```\n\nshapes — 形状或形状数组  \noptions — 包括下面这些参数的对象.  \n\n* curveSegments — int. 曲线上点的个数  \n* steps — int. 用于细分拉伸的样条段数量\n* depth — int. 拉伸形状的深度\n* bevelEnabled — bool. 打开斜面\n* bevelThickness — float. 在原来的形状里面弄多深的斜面\n* bevelSize — float. 斜面离形状轮廓的距离\n* bevelSegments — int. 斜面层的数量\n* extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状\n* UVGenerator — Object. 提供UV生成器各功能的对象\n\n这个对象将一个2D图形拉伸为一个3D几何体.  \n在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# IcosahedronGeometry\n\n## 概念\n用来创建二十面体几何模型的类\n\n## 使用\n```\nIcosahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# IcosahedronBufferGeometry\n\n## 概念\n用来创建二十面体几何模型的类\n\n## 使用\n```\nIcosahedronBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# LatheGeometry\n## 概念\n创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。\n\n## 使用\n\n```\nLatheGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)\n```\n\npoints — Vector2s数组. X轴上每个点都必须大于0.  \nsegments — 生成圆周段的数目. 默认值为12.  \nphiStart — 起始角度的弧度值. 默认值为0.  \nphiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# LatheBufferGeometry\n## 概念\n创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。\n\n## 使用\n\n```\nLatheBufferGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)\n```\n\npoints — Vector2s数组. X轴上每个点都必须大于0.  \nsegments — 生成圆周段的数目. 默认值为12.  \nphiStart — 起始角度的弧度值. 默认值为0.  \nphiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.\n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n\n# OctahedBufferGeometry\n\n## 概念\n用来创建八面体几何模型的类\n\n## 使用\n```\nOctahedGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# OctahedronBufferGeometry\n\n## 概念\n用来创建八面体几何模型的类\n\n## 使用\n```\nOctahedBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 默认值为1. \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ParametricGeometry\n\n## 概念\n生成代表参数化曲面的几何模型\n\n## 使用\n```\nParametricGeometry(func : Function, slices : Integer, stacks : Integer)\n```\n\nfunc — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3  \nslices — 用于参数化函数的切片数量   \nstacks — 用于参数化函数的堆栈数量  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ParametricBufferGeometry\n\n## 概念\n生成代表参数化曲面的几何模型\n\n## 使用\n```\nParametricBufferGeometry(func : Function, slices : Integer, stacks : Integer)\n```\n\nfunc — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3  \nslices — 用于参数化函数的切片数量   \nstacks — 用于参数化函数的堆栈数量  \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# PlaneGeometry\n## 概念\n用来生成平面几何模型的类\n\n\n## 使用\n```\nPlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)\n```\n\nwidth — 沿X轴宽度, 默认为1.  \nheight — 沿Y轴高度，默认为1.  \nwidthSegments — 可选参数，x方向的分段数，缺省为1  \nheightSegments — 可选参数，y方向的分段数，缺省为1 \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PlaneBufferGeometry\n## 概念\n用来生成平面几何模型的类\n\n\n## 使用\n```\nPlaneBufferGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)\n```\n\nwidth — 沿X轴宽度, 默认为1.  \nheight — 沿Y轴高度，默认为1.  \nwidthSegments — 可选参数，x方向的分段数，缺省为1  \nheightSegments — 可选参数，y方向的分段数，缺省为1 \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PolyhedronGeometry\n## 概念\n多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面\n\n## 使用\n```\nPolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)\n```\n\nvertices — Array 以 [1,1,1, -1,-1,-1, ... ] 这种形式出现的点的数组    \nfaces — Array 以 [0,1,2, 2,3,0, ... ] 这种形式出现的构成各个面的指数数组   \nradius — Float - 最终形状的半径    \ndetail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# PolyhedronBufferGeometry\n## 概念\n多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面\n\n## 使用\n```\nPolyhedronBufferGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)\n```\n\nvertices — Array 以 [1,1,1, -1,-1,-1, ... ] 这种形式出现的点的数组    \nfaces — Array 以 [0,1,2, 2,3,0, ... ] 这种形式出现的构成各个面的指数数组   \nradius — Float - 最终形状的半径    \ndetail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# RingGeometry \n## 概念\n用于生成二维环几何的类\n\n## 使用\n```\nRingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)\n```\n\ninnerRadius — 默认值为0.5.\nouterRadius — 默认值为1. \nthetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8. \nphiSegments — 最小值为1. 默认值为8.\nthetaStart — 开始角度. 默认值为0. \nthetaLength — 圆心角. 默认值为Math.PI * 2.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# RingBufferGeometry \n## 概念\n用于生成二维环几何的类\n\n## 使用\n```\nRingBufferGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)\n```\n\ninnerRadius — 默认值为0.5.\nouterRadius — 默认值为1. \nthetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8. \nphiSegments — 最小值为1. 默认值为8.\nthetaStart — 开始角度. 默认值为0. \nthetaLength — 圆心角. 默认值为Math.PI * 2.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ShapeGeometry \n## 概念\n从一个或多个路径形状创建单面多边形几何\n\n## 使用\n```\nShapeGeometry(shapes : Array, curveSegments : Integer)\n```\nshape - 形状数组或单个形状  \ncurveSegments - 整数 - 每个形状的段数。 默认值为12   \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# ShapeBufferGeometry \n## 概念\n从一个或多个路径形状创建单面多边形几何\n\n## 使用\n```\nShapeBufferGeometry(shapes : Array, curveSegments : Integer)\n```\nshape - 形状数组或单个形状  \ncurveSegments - 整数 - 每个形状的段数。 默认值为12   \n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# SphereGeometry \n## 概念\n用于生成球体几何的类\n\n## 使用\n```\nSphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)\n```\n\nradius — 球体半径. 默认值为50  \nwidthSegments — 水平分割面的数量. 最小值为3, 默认值为8  \nheightSegments — 垂直分割面的数量. 最小值为2, 默认值为6  \nphiStart — 指定水平起始角度. 默认值为0  \nphiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2  \nthetaStart — 指定垂直起始角度. 默认值为0  \nthetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  \n\n几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于'sphere slices'）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# SphereBufferGeometry \n## 概念\n用于生成球体几何的类\n\n## 使用\n```\nSphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)\n```\n\nradius — 球体半径. 默认值为50  \nwidthSegments — 水平分割面的数量. 最小值为3, 默认值为8  \nheightSegments — 垂直分割面的数量. 最小值为2, 默认值为6  \nphiStart — 指定水平起始角度. 默认值为0  \nphiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2  \nthetaStart — 指定垂直起始角度. 默认值为0  \nthetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  \n\n几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于'sphere slices'）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TetrahedronGeometry\n## 概念\n用于生成四面体几何的类\n\n## 使用\n```\nTetrahedronGeometry(radius : Float, detail : Integer)\n```\n\nradius — 四面体半径. 默认值为1.    \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# TetrahedronBufferGeometry\n## 概念\n用于生成四面体几何的类\n\n## 使用\n```\nTetrahedronBufferGeometry(radius : Float, detail : Integer)\n```\n\nradius — 四面体半径. 默认值为1.    \ndetail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TextGeometry\n## 概念\n用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的\n\n## 使用\n```\nTextGeometry(text : String, parameters : Object)\n```\ntext — 要显示的文字   \nparameters — 包含下面这些参数的对象  \n\n* font — THREE.Font. 字体实例.\n* size — Float. 文字大小， 默认为100.\n* height — Float. 文字厚度. 默认值为50.   \n* curveSegments — Integer. 曲线上点的数量. 默认值为12.\n* bevelEnabled — Boolean. 是否打开斜面. 默认值为False.\n* bevelThickness — Float. 文本斜面的深度. 默认值为10.\n* bevelSize — Float. 斜面离轮廓的距离. 默认值为8.\n* bevelSegments - Integer. 斜角段数. 默认值为3.\n* \n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TextBufferGeometry\n## 概念\n用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的\n\n## 使用\n```\nTextBufferGeometry(text : String, parameters : Object)\n```\ntext — 要显示的文字   \nparameters — 包含下面这些参数的对象  \n\n* font — THREE.Font. 字体实例.\n* size — Float. 文字大小， 默认为100.\n* height — Float. 文字厚度. 默认值为50.   \n* curveSegments — Integer. 曲线上点的数量. 默认值为12.\n* bevelEnabled — Boolean. 是否打开斜面. 默认值为False.\n* bevelThickness — Float. 文本斜面的深度. 默认值为10.\n* bevelSize — Float. 斜面离轮廓的距离. 默认值为8.\n* bevelSegments - Integer. 斜角段数. 默认值为3.\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusGeometry\n## 概念\n用于生成圆环几何的类\n\n## 使用\n```\nTorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)\n```\n\nradius — 半径, 默认值为1.   \ntube — 管道直径. 默认值为 0.4.   \nradialSegments — 默认值为8   \ntubularSegments — 默认值为6.     \narc — 圆心角. 默认值为Math.PI * 2.  \n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusBufferGeometry\n## 概念\n用于生成圆环几何的类\n\n## 使用\n```\nTorusBufferGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)\n```\n\nradius — 半径, 默认值为1.   \ntube — 管道直径. 默认值为 0.4.   \nradialSegments — 默认值为8   \ntubularSegments — 默认值为6.     \narc — 圆心角. 默认值为Math.PI * 2.  \n\n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusKnotGeometry\n## 概念\n\n创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。\n\n## 使用\n```\nTorusKnotGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)\n```\nradius — 半径, 默认值为1.  \ntube — 管道直径. 默认值为 0.4.\ntubularSegments — 默认值为64.  \nradialSegments — 默认值为8.  \np — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.  \nq — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3.  \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TorusKnotBufferGeometry\n## 概念\n\n创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。\n\n## 使用\n```\nTorusKnotBufferGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)\n```\nradius — 半径, 默认值为1.  \ntube — 管道直径. 默认值为 0.4.\ntubularSegments — 默认值为64.  \nradialSegments — 默认值为8.  \np — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.  \nq — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3. \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TubeGeometry \n## 概念\n创建一个沿3d曲线挤出的管子\n\n## 使用\n```\nTubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)\n```\n\npath — Curve - 从 Curve 基本类继承而来的路径  \nsegments — Integer - 组成管道的分割面数量, 默认值为64  \nradius — Float - 管道半径, 默认值为1  \nradiusSegments — Integer - 组成截面的分割面数量, 默认值为8   \nclosed — Boolean 管道是开放的还是闭合的, 默认值为false   \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n\n# TubeBufferGeometry \n## 概念\n创建一个沿3d曲线挤出的管子\n\n## 使用\n```\nTubeBufferGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)\n```\n\npath — Curve - 从 Curve 基本类继承而来的路径  \nsegments — Integer - 组成管道的分割面数量, 默认值为64  \nradius — Float - 管道半径, 默认值为1  \nradiusSegments — Integer - 组成截面的分割面数量, 默认值为8   \nclosed — Boolean 管道是开放的还是闭合的, 默认值为false   \n\n\n## 属性\n### parameters : Object\n\n具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  \n\n# WireframeGeometry\n## 概念\n这可以用作辅助对象，从线框角度观察Geometry对象\n\n## 使用\n```\nWireframeGeometry( geometry : Geometry )\n```\ngeometry — 任何几何对象\n\n","slug":"threejs 解读 geometry","published":1,"date":"2018-12-27T14:49:31.774Z","updated":"2018-12-27T14:49:31.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6q5hu500000tjgat2n555k","content":"<h1 id=\"BoxGeometry\"><a href=\"#BoxGeometry\" class=\"headerlink\" title=\"BoxGeometry\"></a>BoxGeometry</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>盒子几何模型，长、宽、高可不等</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width - x轴上的宽度，默认为1<br>height - y轴上的高度，默认为1<br>depth - z轴上的深度，默认为1<br>widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1<br>heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1<br>depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  </p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object\"><a href=\"#parameters-Object\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<h1 id=\"BoxBufferGeometry\"><a href=\"#BoxBufferGeometry\" class=\"headerlink\" title=\"BoxBufferGeometry\"></a>BoxBufferGeometry</h1><p>##概念<br> BoxGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxBufferGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width - x轴上的宽度，默认为1<br>height - y轴上的高度，默认为1<br>depth - z轴上的深度，默认为1<br>widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1<br>heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1<br>depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  </p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-1\"><a href=\"#parameters-Object-1\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<p>#CircleGeometry</p>\n<p>##概念<br>CircleGeometry是一个简单的欧氏几何形。它是众多三角形面围绕一个中心点并延伸到给定的半径范围而组成。它是用一个开始角度和一个给定的中心角度逆时针建立。它可以用来创建规则的多边形模型，其中分割面的数量决定的面的数量。</p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>radius — 圆的半径, 默认为1.<br>segments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.<br>thetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-2\"><a href=\"#parameters-Object-2\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<p>#CircleBufferGeometry</p>\n<p>##概念<br> CircleGeometry 部分的 BufferGeometry </p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CircleBufferGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>radius — 圆的半径, 默认为1.<br>segments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.<br>thetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-3\"><a href=\"#parameters-Object-3\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ConeGeometry\"><a href=\"#ConeGeometry\" class=\"headerlink\" title=\"ConeGeometry\"></a>ConeGeometry</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成锥形几何的类</p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>adius — 锥底半径. 默认值为20<br>height — 锥体高度. 默认值为100<br>radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8<br>heightSegments — 沿圆锥高度的分割面数量. 默认值为1<br>openEnded — 指示锥底是否打开, 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.</p>\n<h2 id=\"属性-4\"><a href=\"#属性-4\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-4\"><a href=\"#parameters-Object-4\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ConeBufferGeometry\"><a href=\"#ConeBufferGeometry\" class=\"headerlink\" title=\"ConeBufferGeometry\"></a>ConeBufferGeometry</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>ConeGeometry 部分的 BufferGeometry </p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>adius — 锥底半径. 默认值为20<br>height — 锥体高度. 默认值为100<br>radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8<br>heightSegments — 沿圆锥高度的分割面数量. 默认值为1<br>openEnded — 指示锥底是否打开, 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.</p>\n<h2 id=\"属性-5\"><a href=\"#属性-5\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-5\"><a href=\"#parameters-Object-5\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"CylinderGeometry\"><a href=\"#CylinderGeometry\" class=\"headerlink\" title=\"CylinderGeometry\"></a>CylinderGeometry</h1><h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆柱几何的类</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radiusTop — 圆柱体顶端半径. 默认值为20.<br>radiusBottom — 圆柱体底端半径. 默认值为20.<br>height — 圆柱体高度. 默认值为100.<br>radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.<br>heightSegments — 沿圆柱体高度的分割面数量. 默认值为1.<br>openEnded — 指示圆柱体两端是否打开. 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi</p>\n<h2 id=\"属性-6\"><a href=\"#属性-6\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-6\"><a href=\"#parameters-Object-6\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"CylinderBufferGeometry\"><a href=\"#CylinderBufferGeometry\" class=\"headerlink\" title=\"CylinderBufferGeometry\"></a>CylinderBufferGeometry</h1><h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>CylinderGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radiusTop — 圆柱体顶端半径. 默认值为20.<br>radiusBottom — 圆柱体底端半径. 默认值为20.<br>height — 圆柱体高度. 默认值为100.<br>radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.<br>heightSegments — 沿圆柱体高度的分割面数量. 默认值为1.<br>openEnded — 指示圆柱体两端是否打开. 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi</p>\n<h2 id=\"属性-7\"><a href=\"#属性-7\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-7\"><a href=\"#parameters-Object-7\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"DodecahedronGeometry\"><a href=\"#DodecahedronGeometry\" class=\"headerlink\" title=\"DodecahedronGeometry\"></a>DodecahedronGeometry</h1><h2 id=\"概念-5\"><a href=\"#概念-5\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成十二面体几何的类</p>\n<h2 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DodecahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 十二面体的半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  </p>\n<h2 id=\"属性-8\"><a href=\"#属性-8\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-8\"><a href=\"#parameters-Object-8\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"DodecahedBufferronGeometry\"><a href=\"#DodecahedBufferronGeometry\" class=\"headerlink\" title=\"DodecahedBufferronGeometry\"></a>DodecahedBufferronGeometry</h1><h2 id=\"概念-6\"><a href=\"#概念-6\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>DodecahedonGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-5\"><a href=\"#使用-5\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DodecahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 十二面体的半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  </p>\n<h2 id=\"属性-9\"><a href=\"#属性-9\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-9\"><a href=\"#parameters-Object-9\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeGeometry\"><a href=\"#ExtrudeGeometry\" class=\"headerlink\" title=\"ExtrudeGeometry\"></a>ExtrudeGeometry</h1><h2 id=\"概念-7\"><a href=\"#概念-7\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>这可以用作辅助对象来查看Geometry对象的边缘</p>\n<h2 id=\"使用-6\"><a href=\"#使用-6\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EdgesGeometry( geometry : Geometry, thresholdAngle : Integer )</span><br></pre></td></tr></table></figure>\n<p>geometry - 任何几何对象<br>thresholdAngle - 仅当相邻面的面法线之间的角度（以度为单位）超过此值时，才会渲染边。 默认为1度</p>\n<h2 id=\"属性-10\"><a href=\"#属性-10\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-10\"><a href=\"#parameters-Object-10\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeGeometry-1\"><a href=\"#ExtrudeGeometry-1\" class=\"headerlink\" title=\"ExtrudeGeometry\"></a>ExtrudeGeometry</h1><h2 id=\"概念-8\"><a href=\"#概念-8\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从路径形状创建拉伸几何体</p>\n<h2 id=\"使用-7\"><a href=\"#使用-7\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtrudeGeometry(shapes : Array, options : Object)</span><br></pre></td></tr></table></figure>\n<p>shapes — 形状或形状数组<br>options — 包括下面这些参数的对象.  </p>\n<ul>\n<li>curveSegments — int. 曲线上点的个数  </li>\n<li>steps — int. 用于细分拉伸的样条段数量</li>\n<li>depth — int. 拉伸形状的深度</li>\n<li>bevelEnabled — bool. 打开斜面</li>\n<li>bevelThickness — float. 在原来的形状里面弄多深的斜面</li>\n<li>bevelSize — float. 斜面离形状轮廓的距离</li>\n<li>bevelSegments — int. 斜面层的数量</li>\n<li>extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状</li>\n<li>UVGenerator — Object. 提供UV生成器各功能的对象</li>\n</ul>\n<p>这个对象将一个2D图形拉伸为一个3D几何体.<br>在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面</p>\n<h2 id=\"属性-11\"><a href=\"#属性-11\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-11\"><a href=\"#parameters-Object-11\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeBufferGeometry\"><a href=\"#ExtrudeBufferGeometry\" class=\"headerlink\" title=\"ExtrudeBufferGeometry\"></a>ExtrudeBufferGeometry</h1><h2 id=\"概念-9\"><a href=\"#概念-9\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从路径形状创建拉伸几何体</p>\n<h2 id=\"使用-8\"><a href=\"#使用-8\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtrudeBufferGeometry(shapes : Array, options : Object)</span><br></pre></td></tr></table></figure>\n<p>shapes — 形状或形状数组<br>options — 包括下面这些参数的对象.  </p>\n<ul>\n<li>curveSegments — int. 曲线上点的个数  </li>\n<li>steps — int. 用于细分拉伸的样条段数量</li>\n<li>depth — int. 拉伸形状的深度</li>\n<li>bevelEnabled — bool. 打开斜面</li>\n<li>bevelThickness — float. 在原来的形状里面弄多深的斜面</li>\n<li>bevelSize — float. 斜面离形状轮廓的距离</li>\n<li>bevelSegments — int. 斜面层的数量</li>\n<li>extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状</li>\n<li>UVGenerator — Object. 提供UV生成器各功能的对象</li>\n</ul>\n<p>这个对象将一个2D图形拉伸为一个3D几何体.<br>在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面</p>\n<h2 id=\"属性-12\"><a href=\"#属性-12\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-12\"><a href=\"#parameters-Object-12\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"IcosahedronGeometry\"><a href=\"#IcosahedronGeometry\" class=\"headerlink\" title=\"IcosahedronGeometry\"></a>IcosahedronGeometry</h1><h2 id=\"概念-10\"><a href=\"#概念-10\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建二十面体几何模型的类</p>\n<h2 id=\"使用-9\"><a href=\"#使用-9\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IcosahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.</p>\n<h2 id=\"属性-13\"><a href=\"#属性-13\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-13\"><a href=\"#parameters-Object-13\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"IcosahedronBufferGeometry\"><a href=\"#IcosahedronBufferGeometry\" class=\"headerlink\" title=\"IcosahedronBufferGeometry\"></a>IcosahedronBufferGeometry</h1><h2 id=\"概念-11\"><a href=\"#概念-11\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建二十面体几何模型的类</p>\n<h2 id=\"使用-10\"><a href=\"#使用-10\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IcosahedronBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.</p>\n<h2 id=\"属性-14\"><a href=\"#属性-14\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-14\"><a href=\"#parameters-Object-14\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"LatheGeometry\"><a href=\"#LatheGeometry\" class=\"headerlink\" title=\"LatheGeometry\"></a>LatheGeometry</h1><h2 id=\"概念-12\"><a href=\"#概念-12\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。</p>\n<h2 id=\"使用-11\"><a href=\"#使用-11\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LatheGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)</span><br></pre></td></tr></table></figure>\n<p>points — Vector2s数组. X轴上每个点都必须大于0.<br>segments — 生成圆周段的数目. 默认值为12.<br>phiStart — 起始角度的弧度值. 默认值为0.<br>phiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.</p>\n<h2 id=\"属性-15\"><a href=\"#属性-15\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-15\"><a href=\"#parameters-Object-15\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"LatheBufferGeometry\"><a href=\"#LatheBufferGeometry\" class=\"headerlink\" title=\"LatheBufferGeometry\"></a>LatheBufferGeometry</h1><h2 id=\"概念-13\"><a href=\"#概念-13\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。</p>\n<h2 id=\"使用-12\"><a href=\"#使用-12\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LatheBufferGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)</span><br></pre></td></tr></table></figure>\n<p>points — Vector2s数组. X轴上每个点都必须大于0.<br>segments — 生成圆周段的数目. 默认值为12.<br>phiStart — 起始角度的弧度值. 默认值为0.<br>phiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.</p>\n<h2 id=\"属性-16\"><a href=\"#属性-16\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-16\"><a href=\"#parameters-Object-16\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"OctahedBufferGeometry\"><a href=\"#OctahedBufferGeometry\" class=\"headerlink\" title=\"OctahedBufferGeometry\"></a>OctahedBufferGeometry</h1><h2 id=\"概念-14\"><a href=\"#概念-14\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建八面体几何模型的类</p>\n<h2 id=\"使用-13\"><a href=\"#使用-13\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OctahedGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.</p>\n<h2 id=\"属性-17\"><a href=\"#属性-17\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-17\"><a href=\"#parameters-Object-17\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"OctahedronBufferGeometry\"><a href=\"#OctahedronBufferGeometry\" class=\"headerlink\" title=\"OctahedronBufferGeometry\"></a>OctahedronBufferGeometry</h1><h2 id=\"概念-15\"><a href=\"#概念-15\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建八面体几何模型的类</p>\n<h2 id=\"使用-14\"><a href=\"#使用-14\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OctahedBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.</p>\n<h2 id=\"属性-18\"><a href=\"#属性-18\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-18\"><a href=\"#parameters-Object-18\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ParametricGeometry\"><a href=\"#ParametricGeometry\" class=\"headerlink\" title=\"ParametricGeometry\"></a>ParametricGeometry</h1><h2 id=\"概念-16\"><a href=\"#概念-16\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>生成代表参数化曲面的几何模型</p>\n<h2 id=\"使用-15\"><a href=\"#使用-15\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParametricGeometry(func : Function, slices : Integer, stacks : Integer)</span><br></pre></td></tr></table></figure>\n<p>func — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3<br>slices — 用于参数化函数的切片数量<br>stacks — 用于参数化函数的堆栈数量  </p>\n<h2 id=\"属性-19\"><a href=\"#属性-19\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-19\"><a href=\"#parameters-Object-19\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ParametricBufferGeometry\"><a href=\"#ParametricBufferGeometry\" class=\"headerlink\" title=\"ParametricBufferGeometry\"></a>ParametricBufferGeometry</h1><h2 id=\"概念-17\"><a href=\"#概念-17\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>生成代表参数化曲面的几何模型</p>\n<h2 id=\"使用-16\"><a href=\"#使用-16\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParametricBufferGeometry(func : Function, slices : Integer, stacks : Integer)</span><br></pre></td></tr></table></figure>\n<p>func — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3<br>slices — 用于参数化函数的切片数量<br>stacks — 用于参数化函数的堆栈数量  </p>\n<h2 id=\"属性-20\"><a href=\"#属性-20\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-20\"><a href=\"#parameters-Object-20\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PlaneGeometry\"><a href=\"#PlaneGeometry\" class=\"headerlink\" title=\"PlaneGeometry\"></a>PlaneGeometry</h1><h2 id=\"概念-18\"><a href=\"#概念-18\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来生成平面几何模型的类</p>\n<h2 id=\"使用-17\"><a href=\"#使用-17\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width — 沿X轴宽度, 默认为1.<br>height — 沿Y轴高度，默认为1.<br>widthSegments — 可选参数，x方向的分段数，缺省为1<br>heightSegments — 可选参数，y方向的分段数，缺省为1 </p>\n<h2 id=\"属性-21\"><a href=\"#属性-21\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-21\"><a href=\"#parameters-Object-21\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PlaneBufferGeometry\"><a href=\"#PlaneBufferGeometry\" class=\"headerlink\" title=\"PlaneBufferGeometry\"></a>PlaneBufferGeometry</h1><h2 id=\"概念-19\"><a href=\"#概念-19\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来生成平面几何模型的类</p>\n<h2 id=\"使用-18\"><a href=\"#使用-18\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlaneBufferGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width — 沿X轴宽度, 默认为1.<br>height — 沿Y轴高度，默认为1.<br>widthSegments — 可选参数，x方向的分段数，缺省为1<br>heightSegments — 可选参数，y方向的分段数，缺省为1 </p>\n<h2 id=\"属性-22\"><a href=\"#属性-22\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-22\"><a href=\"#parameters-Object-22\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PolyhedronGeometry\"><a href=\"#PolyhedronGeometry\" class=\"headerlink\" title=\"PolyhedronGeometry\"></a>PolyhedronGeometry</h1><h2 id=\"概念-20\"><a href=\"#概念-20\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面</p>\n<h2 id=\"使用-19\"><a href=\"#使用-19\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>vertices — Array 以 [1,1,1, -1,-1,-1, … ] 这种形式出现的点的数组<br>faces — Array 以 [0,1,2, 2,3,0, … ] 这种形式出现的构成各个面的指数数组<br>radius — Float - 最终形状的半径<br>detail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  </p>\n<h2 id=\"属性-23\"><a href=\"#属性-23\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-23\"><a href=\"#parameters-Object-23\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PolyhedronBufferGeometry\"><a href=\"#PolyhedronBufferGeometry\" class=\"headerlink\" title=\"PolyhedronBufferGeometry\"></a>PolyhedronBufferGeometry</h1><h2 id=\"概念-21\"><a href=\"#概念-21\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面</p>\n<h2 id=\"使用-20\"><a href=\"#使用-20\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PolyhedronBufferGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>vertices — Array 以 [1,1,1, -1,-1,-1, … ] 这种形式出现的点的数组<br>faces — Array 以 [0,1,2, 2,3,0, … ] 这种形式出现的构成各个面的指数数组<br>radius — Float - 最终形状的半径<br>detail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  </p>\n<h2 id=\"属性-24\"><a href=\"#属性-24\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-24\"><a href=\"#parameters-Object-24\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"RingGeometry\"><a href=\"#RingGeometry\" class=\"headerlink\" title=\"RingGeometry\"></a>RingGeometry</h1><h2 id=\"概念-22\"><a href=\"#概念-22\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成二维环几何的类</p>\n<h2 id=\"使用-21\"><a href=\"#使用-21\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>innerRadius — 默认值为0.5.<br>outerRadius — 默认值为1.<br>thetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8.<br>phiSegments — 最小值为1. 默认值为8.<br>thetaStart — 开始角度. 默认值为0.<br>thetaLength — 圆心角. 默认值为Math.PI * 2.</p>\n<h2 id=\"属性-25\"><a href=\"#属性-25\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-25\"><a href=\"#parameters-Object-25\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"RingBufferGeometry\"><a href=\"#RingBufferGeometry\" class=\"headerlink\" title=\"RingBufferGeometry\"></a>RingBufferGeometry</h1><h2 id=\"概念-23\"><a href=\"#概念-23\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成二维环几何的类</p>\n<h2 id=\"使用-22\"><a href=\"#使用-22\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RingBufferGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>innerRadius — 默认值为0.5.<br>outerRadius — 默认值为1.<br>thetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8.<br>phiSegments — 最小值为1. 默认值为8.<br>thetaStart — 开始角度. 默认值为0.<br>thetaLength — 圆心角. 默认值为Math.PI * 2.</p>\n<h2 id=\"属性-26\"><a href=\"#属性-26\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-26\"><a href=\"#parameters-Object-26\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ShapeGeometry\"><a href=\"#ShapeGeometry\" class=\"headerlink\" title=\"ShapeGeometry\"></a>ShapeGeometry</h1><h2 id=\"概念-24\"><a href=\"#概念-24\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从一个或多个路径形状创建单面多边形几何</p>\n<h2 id=\"使用-23\"><a href=\"#使用-23\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShapeGeometry(shapes : Array, curveSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>shape - 形状数组或单个形状<br>curveSegments - 整数 - 每个形状的段数。 默认值为12   </p>\n<h2 id=\"属性-27\"><a href=\"#属性-27\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-27\"><a href=\"#parameters-Object-27\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ShapeBufferGeometry\"><a href=\"#ShapeBufferGeometry\" class=\"headerlink\" title=\"ShapeBufferGeometry\"></a>ShapeBufferGeometry</h1><h2 id=\"概念-25\"><a href=\"#概念-25\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从一个或多个路径形状创建单面多边形几何</p>\n<h2 id=\"使用-24\"><a href=\"#使用-24\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShapeBufferGeometry(shapes : Array, curveSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>shape - 形状数组或单个形状<br>curveSegments - 整数 - 每个形状的段数。 默认值为12   </p>\n<h2 id=\"属性-28\"><a href=\"#属性-28\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-28\"><a href=\"#parameters-Object-28\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"SphereGeometry\"><a href=\"#SphereGeometry\" class=\"headerlink\" title=\"SphereGeometry\"></a>SphereGeometry</h1><h2 id=\"概念-26\"><a href=\"#概念-26\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成球体几何的类</p>\n<h2 id=\"使用-25\"><a href=\"#使用-25\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 球体半径. 默认值为50<br>widthSegments — 水平分割面的数量. 最小值为3, 默认值为8<br>heightSegments — 垂直分割面的数量. 最小值为2, 默认值为6<br>phiStart — 指定水平起始角度. 默认值为0<br>phiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2<br>thetaStart — 指定垂直起始角度. 默认值为0<br>thetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  </p>\n<p>几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于’sphere slices’）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建</p>\n<h2 id=\"属性-29\"><a href=\"#属性-29\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-29\"><a href=\"#parameters-Object-29\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"SphereBufferGeometry\"><a href=\"#SphereBufferGeometry\" class=\"headerlink\" title=\"SphereBufferGeometry\"></a>SphereBufferGeometry</h1><h2 id=\"概念-27\"><a href=\"#概念-27\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成球体几何的类</p>\n<h2 id=\"使用-26\"><a href=\"#使用-26\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 球体半径. 默认值为50<br>widthSegments — 水平分割面的数量. 最小值为3, 默认值为8<br>heightSegments — 垂直分割面的数量. 最小值为2, 默认值为6<br>phiStart — 指定水平起始角度. 默认值为0<br>phiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2<br>thetaStart — 指定垂直起始角度. 默认值为0<br>thetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  </p>\n<p>几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于’sphere slices’）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建</p>\n<h2 id=\"属性-30\"><a href=\"#属性-30\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-30\"><a href=\"#parameters-Object-30\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TetrahedronGeometry\"><a href=\"#TetrahedronGeometry\" class=\"headerlink\" title=\"TetrahedronGeometry\"></a>TetrahedronGeometry</h1><h2 id=\"概念-28\"><a href=\"#概念-28\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成四面体几何的类</p>\n<h2 id=\"使用-27\"><a href=\"#使用-27\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TetrahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 四面体半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.</p>\n<h2 id=\"属性-31\"><a href=\"#属性-31\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-31\"><a href=\"#parameters-Object-31\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TetrahedronBufferGeometry\"><a href=\"#TetrahedronBufferGeometry\" class=\"headerlink\" title=\"TetrahedronBufferGeometry\"></a>TetrahedronBufferGeometry</h1><h2 id=\"概念-29\"><a href=\"#概念-29\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成四面体几何的类</p>\n<h2 id=\"使用-28\"><a href=\"#使用-28\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TetrahedronBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 四面体半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.</p>\n<h2 id=\"属性-32\"><a href=\"#属性-32\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-32\"><a href=\"#parameters-Object-32\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TextGeometry\"><a href=\"#TextGeometry\" class=\"headerlink\" title=\"TextGeometry\"></a>TextGeometry</h1><h2 id=\"概念-30\"><a href=\"#概念-30\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的</p>\n<h2 id=\"使用-29\"><a href=\"#使用-29\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextGeometry(text : String, parameters : Object)</span><br></pre></td></tr></table></figure>\n<p>text — 要显示的文字<br>parameters — 包含下面这些参数的对象  </p>\n<ul>\n<li>font — THREE.Font. 字体实例.</li>\n<li>size — Float. 文字大小， 默认为100.</li>\n<li>height — Float. 文字厚度. 默认值为50.   </li>\n<li>curveSegments — Integer. 曲线上点的数量. 默认值为12.</li>\n<li>bevelEnabled — Boolean. 是否打开斜面. 默认值为False.</li>\n<li>bevelThickness — Float. 文本斜面的深度. 默认值为10.</li>\n<li>bevelSize — Float. 斜面离轮廓的距离. 默认值为8.</li>\n<li>bevelSegments - Integer. 斜角段数. 默认值为3.</li>\n<li><h2 id=\"属性-33\"><a href=\"#属性-33\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-33\"><a href=\"#parameters-Object-33\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3></li>\n</ul>\n<p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TextBufferGeometry\"><a href=\"#TextBufferGeometry\" class=\"headerlink\" title=\"TextBufferGeometry\"></a>TextBufferGeometry</h1><h2 id=\"概念-31\"><a href=\"#概念-31\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的</p>\n<h2 id=\"使用-30\"><a href=\"#使用-30\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextBufferGeometry(text : String, parameters : Object)</span><br></pre></td></tr></table></figure>\n<p>text — 要显示的文字<br>parameters — 包含下面这些参数的对象  </p>\n<ul>\n<li>font — THREE.Font. 字体实例.</li>\n<li>size — Float. 文字大小， 默认为100.</li>\n<li>height — Float. 文字厚度. 默认值为50.   </li>\n<li>curveSegments — Integer. 曲线上点的数量. 默认值为12.</li>\n<li>bevelEnabled — Boolean. 是否打开斜面. 默认值为False.</li>\n<li>bevelThickness — Float. 文本斜面的深度. 默认值为10.</li>\n<li>bevelSize — Float. 斜面离轮廓的距离. 默认值为8.</li>\n<li>bevelSegments - Integer. 斜角段数. 默认值为3.</li>\n</ul>\n<h2 id=\"属性-34\"><a href=\"#属性-34\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-34\"><a href=\"#parameters-Object-34\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusGeometry\"><a href=\"#TorusGeometry\" class=\"headerlink\" title=\"TorusGeometry\"></a>TorusGeometry</h1><h2 id=\"概念-32\"><a href=\"#概念-32\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆环几何的类</p>\n<h2 id=\"使用-31\"><a href=\"#使用-31\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>radialSegments — 默认值为8<br>tubularSegments — 默认值为6.<br>arc — 圆心角. 默认值为Math.PI * 2.  </p>\n<h2 id=\"属性-35\"><a href=\"#属性-35\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-35\"><a href=\"#parameters-Object-35\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusBufferGeometry\"><a href=\"#TorusBufferGeometry\" class=\"headerlink\" title=\"TorusBufferGeometry\"></a>TorusBufferGeometry</h1><h2 id=\"概念-33\"><a href=\"#概念-33\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆环几何的类</p>\n<h2 id=\"使用-32\"><a href=\"#使用-32\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusBufferGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>radialSegments — 默认值为8<br>tubularSegments — 默认值为6.<br>arc — 圆心角. 默认值为Math.PI * 2.  </p>\n<h2 id=\"属性-36\"><a href=\"#属性-36\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-36\"><a href=\"#parameters-Object-36\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusKnotGeometry\"><a href=\"#TorusKnotGeometry\" class=\"headerlink\" title=\"TorusKnotGeometry\"></a>TorusKnotGeometry</h1><h2 id=\"概念-34\"><a href=\"#概念-34\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。</p>\n<h2 id=\"使用-33\"><a href=\"#使用-33\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusKnotGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>tubularSegments — 默认值为64.<br>radialSegments — 默认值为8.<br>p — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.<br>q — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3.  </p>\n<h2 id=\"属性-37\"><a href=\"#属性-37\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-37\"><a href=\"#parameters-Object-37\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusKnotBufferGeometry\"><a href=\"#TorusKnotBufferGeometry\" class=\"headerlink\" title=\"TorusKnotBufferGeometry\"></a>TorusKnotBufferGeometry</h1><h2 id=\"概念-35\"><a href=\"#概念-35\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。</p>\n<h2 id=\"使用-34\"><a href=\"#使用-34\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusKnotBufferGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>tubularSegments — 默认值为64.<br>radialSegments — 默认值为8.<br>p — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.<br>q — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3. </p>\n<h2 id=\"属性-38\"><a href=\"#属性-38\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-38\"><a href=\"#parameters-Object-38\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TubeGeometry\"><a href=\"#TubeGeometry\" class=\"headerlink\" title=\"TubeGeometry\"></a>TubeGeometry</h1><h2 id=\"概念-36\"><a href=\"#概念-36\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建一个沿3d曲线挤出的管子</p>\n<h2 id=\"使用-35\"><a href=\"#使用-35\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</span><br></pre></td></tr></table></figure>\n<p>path — Curve - 从 Curve 基本类继承而来的路径<br>segments — Integer - 组成管道的分割面数量, 默认值为64<br>radius — Float - 管道半径, 默认值为1<br>radiusSegments — Integer - 组成截面的分割面数量, 默认值为8<br>closed — Boolean 管道是开放的还是闭合的, 默认值为false   </p>\n<h2 id=\"属性-39\"><a href=\"#属性-39\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-39\"><a href=\"#parameters-Object-39\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TubeBufferGeometry\"><a href=\"#TubeBufferGeometry\" class=\"headerlink\" title=\"TubeBufferGeometry\"></a>TubeBufferGeometry</h1><h2 id=\"概念-37\"><a href=\"#概念-37\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建一个沿3d曲线挤出的管子</p>\n<h2 id=\"使用-36\"><a href=\"#使用-36\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TubeBufferGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</span><br></pre></td></tr></table></figure>\n<p>path — Curve - 从 Curve 基本类继承而来的路径<br>segments — Integer - 组成管道的分割面数量, 默认值为64<br>radius — Float - 管道半径, 默认值为1<br>radiusSegments — Integer - 组成截面的分割面数量, 默认值为8<br>closed — Boolean 管道是开放的还是闭合的, 默认值为false   </p>\n<h2 id=\"属性-40\"><a href=\"#属性-40\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-40\"><a href=\"#parameters-Object-40\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"WireframeGeometry\"><a href=\"#WireframeGeometry\" class=\"headerlink\" title=\"WireframeGeometry\"></a>WireframeGeometry</h1><h2 id=\"概念-38\"><a href=\"#概念-38\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>这可以用作辅助对象，从线框角度观察Geometry对象</p>\n<h2 id=\"使用-37\"><a href=\"#使用-37\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WireframeGeometry( geometry : Geometry )</span><br></pre></td></tr></table></figure>\n<p>geometry — 任何几何对象</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BoxGeometry\"><a href=\"#BoxGeometry\" class=\"headerlink\" title=\"BoxGeometry\"></a>BoxGeometry</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>盒子几何模型，长、宽、高可不等</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width - x轴上的宽度，默认为1<br>height - y轴上的高度，默认为1<br>depth - z轴上的深度，默认为1<br>widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1<br>heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1<br>depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  </p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object\"><a href=\"#parameters-Object\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<h1 id=\"BoxBufferGeometry\"><a href=\"#BoxBufferGeometry\" class=\"headerlink\" title=\"BoxBufferGeometry\"></a>BoxBufferGeometry</h1><p>##概念<br> BoxGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxBufferGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width - x轴上的宽度，默认为1<br>height - y轴上的高度，默认为1<br>depth - z轴上的深度，默认为1<br>widthSegments — 可选参数. 沿宽度面的分割面数量. 默认值为1<br>heightSegments — 可选参数. 沿高度面的分割面数量. 默认值为1<br>depthSegments — 可选参数. 沿深度面的分割面数量. 默认值为1  </p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-1\"><a href=\"#parameters-Object-1\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<p>#CircleGeometry</p>\n<p>##概念<br>CircleGeometry是一个简单的欧氏几何形。它是众多三角形面围绕一个中心点并延伸到给定的半径范围而组成。它是用一个开始角度和一个给定的中心角度逆时针建立。它可以用来创建规则的多边形模型，其中分割面的数量决定的面的数量。</p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>radius — 圆的半径, 默认为1.<br>segments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.<br>thetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-2\"><a href=\"#parameters-Object-2\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何</p>\n<p>#CircleBufferGeometry</p>\n<p>##概念<br> CircleGeometry 部分的 BufferGeometry </p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CircleBufferGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>radius — 圆的半径, 默认为1.<br>segments — 分割面数量 (三角形), 最小值为3, 默认值 = 8.<br>thetaStart — 第一个分割面的开始角度, 默认值为0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为 θ。默认为2 * Pi</p>\n<h2 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-3\"><a href=\"#parameters-Object-3\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ConeGeometry\"><a href=\"#ConeGeometry\" class=\"headerlink\" title=\"ConeGeometry\"></a>ConeGeometry</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成锥形几何的类</p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>adius — 锥底半径. 默认值为20<br>height — 锥体高度. 默认值为100<br>radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8<br>heightSegments — 沿圆锥高度的分割面数量. 默认值为1<br>openEnded — 指示锥底是否打开, 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.</p>\n<h2 id=\"属性-4\"><a href=\"#属性-4\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-4\"><a href=\"#parameters-Object-4\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ConeBufferGeometry\"><a href=\"#ConeBufferGeometry\" class=\"headerlink\" title=\"ConeBufferGeometry\"></a>ConeBufferGeometry</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>ConeGeometry 部分的 BufferGeometry </p>\n<p>##使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConeGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure></p>\n<p>adius — 锥底半径. 默认值为20<br>height — 锥体高度. 默认值为100<br>radiusSegments — 围绕圆锥周长的分割面数量. 默认值为8<br>heightSegments — 沿圆锥高度的分割面数量. 默认值为1<br>openEnded — 指示锥底是否打开, 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向)<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi.</p>\n<h2 id=\"属性-5\"><a href=\"#属性-5\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-5\"><a href=\"#parameters-Object-5\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"CylinderGeometry\"><a href=\"#CylinderGeometry\" class=\"headerlink\" title=\"CylinderGeometry\"></a>CylinderGeometry</h1><h2 id=\"概念-3\"><a href=\"#概念-3\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆柱几何的类</p>\n<h2 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radiusTop — 圆柱体顶端半径. 默认值为20.<br>radiusBottom — 圆柱体底端半径. 默认值为20.<br>height — 圆柱体高度. 默认值为100.<br>radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.<br>heightSegments — 沿圆柱体高度的分割面数量. 默认值为1.<br>openEnded — 指示圆柱体两端是否打开. 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi</p>\n<h2 id=\"属性-6\"><a href=\"#属性-6\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-6\"><a href=\"#parameters-Object-6\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"CylinderBufferGeometry\"><a href=\"#CylinderBufferGeometry\" class=\"headerlink\" title=\"CylinderBufferGeometry\"></a>CylinderBufferGeometry</h1><h2 id=\"概念-4\"><a href=\"#概念-4\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>CylinderGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radiusTop — 圆柱体顶端半径. 默认值为20.<br>radiusBottom — 圆柱体底端半径. 默认值为20.<br>height — 圆柱体高度. 默认值为100.<br>radiusSegments — 围绕圆柱体周长的分割面数量. 默认值为8.<br>heightSegments — 沿圆柱体高度的分割面数量. 默认值为1.<br>openEnded — 指示圆柱体两端是否打开. 默认值为false<br>thetaStart — 第一个分割面的开始角度, 默认值 = 0 (3点钟方向).<br>thetaLength — 圆形扇形的圆心角通常称为θ。默认为2 * Pi</p>\n<h2 id=\"属性-7\"><a href=\"#属性-7\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-7\"><a href=\"#parameters-Object-7\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"DodecahedronGeometry\"><a href=\"#DodecahedronGeometry\" class=\"headerlink\" title=\"DodecahedronGeometry\"></a>DodecahedronGeometry</h1><h2 id=\"概念-5\"><a href=\"#概念-5\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成十二面体几何的类</p>\n<h2 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DodecahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 十二面体的半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  </p>\n<h2 id=\"属性-8\"><a href=\"#属性-8\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-8\"><a href=\"#parameters-Object-8\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"DodecahedBufferronGeometry\"><a href=\"#DodecahedBufferronGeometry\" class=\"headerlink\" title=\"DodecahedBufferronGeometry\"></a>DodecahedBufferronGeometry</h1><h2 id=\"概念-6\"><a href=\"#概念-6\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>DodecahedonGeometry 部分的 BufferGeometry </p>\n<h2 id=\"使用-5\"><a href=\"#使用-5\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DodecahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 十二面体的半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个十二面体  </p>\n<h2 id=\"属性-9\"><a href=\"#属性-9\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-9\"><a href=\"#parameters-Object-9\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeGeometry\"><a href=\"#ExtrudeGeometry\" class=\"headerlink\" title=\"ExtrudeGeometry\"></a>ExtrudeGeometry</h1><h2 id=\"概念-7\"><a href=\"#概念-7\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>这可以用作辅助对象来查看Geometry对象的边缘</p>\n<h2 id=\"使用-6\"><a href=\"#使用-6\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EdgesGeometry( geometry : Geometry, thresholdAngle : Integer )</span><br></pre></td></tr></table></figure>\n<p>geometry - 任何几何对象<br>thresholdAngle - 仅当相邻面的面法线之间的角度（以度为单位）超过此值时，才会渲染边。 默认为1度</p>\n<h2 id=\"属性-10\"><a href=\"#属性-10\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-10\"><a href=\"#parameters-Object-10\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeGeometry-1\"><a href=\"#ExtrudeGeometry-1\" class=\"headerlink\" title=\"ExtrudeGeometry\"></a>ExtrudeGeometry</h1><h2 id=\"概念-8\"><a href=\"#概念-8\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从路径形状创建拉伸几何体</p>\n<h2 id=\"使用-7\"><a href=\"#使用-7\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtrudeGeometry(shapes : Array, options : Object)</span><br></pre></td></tr></table></figure>\n<p>shapes — 形状或形状数组<br>options — 包括下面这些参数的对象.  </p>\n<ul>\n<li>curveSegments — int. 曲线上点的个数  </li>\n<li>steps — int. 用于细分拉伸的样条段数量</li>\n<li>depth — int. 拉伸形状的深度</li>\n<li>bevelEnabled — bool. 打开斜面</li>\n<li>bevelThickness — float. 在原来的形状里面弄多深的斜面</li>\n<li>bevelSize — float. 斜面离形状轮廓的距离</li>\n<li>bevelSegments — int. 斜面层的数量</li>\n<li>extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状</li>\n<li>UVGenerator — Object. 提供UV生成器各功能的对象</li>\n</ul>\n<p>这个对象将一个2D图形拉伸为一个3D几何体.<br>在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面</p>\n<h2 id=\"属性-11\"><a href=\"#属性-11\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-11\"><a href=\"#parameters-Object-11\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ExtrudeBufferGeometry\"><a href=\"#ExtrudeBufferGeometry\" class=\"headerlink\" title=\"ExtrudeBufferGeometry\"></a>ExtrudeBufferGeometry</h1><h2 id=\"概念-9\"><a href=\"#概念-9\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从路径形状创建拉伸几何体</p>\n<h2 id=\"使用-8\"><a href=\"#使用-8\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtrudeBufferGeometry(shapes : Array, options : Object)</span><br></pre></td></tr></table></figure>\n<p>shapes — 形状或形状数组<br>options — 包括下面这些参数的对象.  </p>\n<ul>\n<li>curveSegments — int. 曲线上点的个数  </li>\n<li>steps — int. 用于细分拉伸的样条段数量</li>\n<li>depth — int. 拉伸形状的深度</li>\n<li>bevelEnabled — bool. 打开斜面</li>\n<li>bevelThickness — float. 在原来的形状里面弄多深的斜面</li>\n<li>bevelSize — float. 斜面离形状轮廓的距离</li>\n<li>bevelSegments — int. 斜面层的数量</li>\n<li>extrudePath — THREE.CurvePath. 沿3D样条路径拉伸形状</li>\n<li>UVGenerator — Object. 提供UV生成器各功能的对象</li>\n</ul>\n<p>这个对象将一个2D图形拉伸为一个3D几何体.<br>在使用此几何体创建网格时，如果您希望将单独的材质用于其面和其拉伸边，则可以使用一组材质。 第一种材料将涂在形状面; 第二种材料将应用于侧面</p>\n<h2 id=\"属性-12\"><a href=\"#属性-12\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-12\"><a href=\"#parameters-Object-12\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"IcosahedronGeometry\"><a href=\"#IcosahedronGeometry\" class=\"headerlink\" title=\"IcosahedronGeometry\"></a>IcosahedronGeometry</h1><h2 id=\"概念-10\"><a href=\"#概念-10\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建二十面体几何模型的类</p>\n<h2 id=\"使用-9\"><a href=\"#使用-9\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IcosahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.</p>\n<h2 id=\"属性-13\"><a href=\"#属性-13\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-13\"><a href=\"#parameters-Object-13\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"IcosahedronBufferGeometry\"><a href=\"#IcosahedronBufferGeometry\" class=\"headerlink\" title=\"IcosahedronBufferGeometry\"></a>IcosahedronBufferGeometry</h1><h2 id=\"概念-11\"><a href=\"#概念-11\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建二十面体几何模型的类</p>\n<h2 id=\"使用-10\"><a href=\"#使用-10\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IcosahedronBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个二十面体. 当值大于1时它就成了一个球体.</p>\n<h2 id=\"属性-14\"><a href=\"#属性-14\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-14\"><a href=\"#parameters-Object-14\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"LatheGeometry\"><a href=\"#LatheGeometry\" class=\"headerlink\" title=\"LatheGeometry\"></a>LatheGeometry</h1><h2 id=\"概念-12\"><a href=\"#概念-12\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。</p>\n<h2 id=\"使用-11\"><a href=\"#使用-11\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LatheGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)</span><br></pre></td></tr></table></figure>\n<p>points — Vector2s数组. X轴上每个点都必须大于0.<br>segments — 生成圆周段的数目. 默认值为12.<br>phiStart — 起始角度的弧度值. 默认值为0.<br>phiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.</p>\n<h2 id=\"属性-15\"><a href=\"#属性-15\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-15\"><a href=\"#parameters-Object-15\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"LatheBufferGeometry\"><a href=\"#LatheBufferGeometry\" class=\"headerlink\" title=\"LatheBufferGeometry\"></a>LatheBufferGeometry</h1><h2 id=\"概念-13\"><a href=\"#概念-13\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建具有轴对称性的网格，如花瓶。 车床绕Y轴旋转。</p>\n<h2 id=\"使用-12\"><a href=\"#使用-12\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LatheBufferGeometry(points : Array, segments : Integer, phiStart : Float, phiLength : Float)</span><br></pre></td></tr></table></figure>\n<p>points — Vector2s数组. X轴上每个点都必须大于0.<br>segments — 生成圆周段的数目. 默认值为12.<br>phiStart — 起始角度的弧度值. 默认值为0.<br>phiLength — 弧度范围在0到2PI间的，2PI是闭合车床, 小于2PI的是部分。默认值为2PI.</p>\n<h2 id=\"属性-16\"><a href=\"#属性-16\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-16\"><a href=\"#parameters-Object-16\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"OctahedBufferGeometry\"><a href=\"#OctahedBufferGeometry\" class=\"headerlink\" title=\"OctahedBufferGeometry\"></a>OctahedBufferGeometry</h1><h2 id=\"概念-14\"><a href=\"#概念-14\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建八面体几何模型的类</p>\n<h2 id=\"使用-13\"><a href=\"#使用-13\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OctahedGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.</p>\n<h2 id=\"属性-17\"><a href=\"#属性-17\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-17\"><a href=\"#parameters-Object-17\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"OctahedronBufferGeometry\"><a href=\"#OctahedronBufferGeometry\" class=\"headerlink\" title=\"OctahedronBufferGeometry\"></a>OctahedronBufferGeometry</h1><h2 id=\"概念-15\"><a href=\"#概念-15\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来创建八面体几何模型的类</p>\n<h2 id=\"使用-14\"><a href=\"#使用-14\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OctahedBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个八面体.</p>\n<h2 id=\"属性-18\"><a href=\"#属性-18\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-18\"><a href=\"#parameters-Object-18\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ParametricGeometry\"><a href=\"#ParametricGeometry\" class=\"headerlink\" title=\"ParametricGeometry\"></a>ParametricGeometry</h1><h2 id=\"概念-16\"><a href=\"#概念-16\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>生成代表参数化曲面的几何模型</p>\n<h2 id=\"使用-15\"><a href=\"#使用-15\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParametricGeometry(func : Function, slices : Integer, stacks : Integer)</span><br></pre></td></tr></table></figure>\n<p>func — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3<br>slices — 用于参数化函数的切片数量<br>stacks — 用于参数化函数的堆栈数量  </p>\n<h2 id=\"属性-19\"><a href=\"#属性-19\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-19\"><a href=\"#parameters-Object-19\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ParametricBufferGeometry\"><a href=\"#ParametricBufferGeometry\" class=\"headerlink\" title=\"ParametricBufferGeometry\"></a>ParametricBufferGeometry</h1><h2 id=\"概念-17\"><a href=\"#概念-17\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>生成代表参数化曲面的几何模型</p>\n<h2 id=\"使用-16\"><a href=\"#使用-16\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ParametricBufferGeometry(func : Function, slices : Integer, stacks : Integer)</span><br></pre></td></tr></table></figure>\n<p>func — 一个函数，接收介于0到1之间的 u 和 v 值，并返回一个 Vector3<br>slices — 用于参数化函数的切片数量<br>stacks — 用于参数化函数的堆栈数量  </p>\n<h2 id=\"属性-20\"><a href=\"#属性-20\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-20\"><a href=\"#parameters-Object-20\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PlaneGeometry\"><a href=\"#PlaneGeometry\" class=\"headerlink\" title=\"PlaneGeometry\"></a>PlaneGeometry</h1><h2 id=\"概念-18\"><a href=\"#概念-18\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来生成平面几何模型的类</p>\n<h2 id=\"使用-17\"><a href=\"#使用-17\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlaneGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width — 沿X轴宽度, 默认为1.<br>height — 沿Y轴高度，默认为1.<br>widthSegments — 可选参数，x方向的分段数，缺省为1<br>heightSegments — 可选参数，y方向的分段数，缺省为1 </p>\n<h2 id=\"属性-21\"><a href=\"#属性-21\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-21\"><a href=\"#parameters-Object-21\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PlaneBufferGeometry\"><a href=\"#PlaneBufferGeometry\" class=\"headerlink\" title=\"PlaneBufferGeometry\"></a>PlaneBufferGeometry</h1><h2 id=\"概念-19\"><a href=\"#概念-19\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用来生成平面几何模型的类</p>\n<h2 id=\"使用-18\"><a href=\"#使用-18\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PlaneBufferGeometry(width : Float, height : Float, widthSegments : Integer, heightSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>width — 沿X轴宽度, 默认为1.<br>height — 沿Y轴高度，默认为1.<br>widthSegments — 可选参数，x方向的分段数，缺省为1<br>heightSegments — 可选参数，y方向的分段数，缺省为1 </p>\n<h2 id=\"属性-22\"><a href=\"#属性-22\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-22\"><a href=\"#parameters-Object-22\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PolyhedronGeometry\"><a href=\"#PolyhedronGeometry\" class=\"headerlink\" title=\"PolyhedronGeometry\"></a>PolyhedronGeometry</h1><h2 id=\"概念-20\"><a href=\"#概念-20\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面</p>\n<h2 id=\"使用-19\"><a href=\"#使用-19\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PolyhedronGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>vertices — Array 以 [1,1,1, -1,-1,-1, … ] 这种形式出现的点的数组<br>faces — Array 以 [0,1,2, 2,3,0, … ] 这种形式出现的构成各个面的指数数组<br>radius — Float - 最终形状的半径<br>detail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  </p>\n<h2 id=\"属性-23\"><a href=\"#属性-23\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-23\"><a href=\"#parameters-Object-23\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"PolyhedronBufferGeometry\"><a href=\"#PolyhedronBufferGeometry\" class=\"headerlink\" title=\"PolyhedronBufferGeometry\"></a>PolyhedronBufferGeometry</h1><h2 id=\"概念-21\"><a href=\"#概念-21\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多面体是由多个平面形成的三维几何体,它将取一个顶点数组并将它们投射到一个球体上，然后将它们划分成所需的期望细节层面</p>\n<h2 id=\"使用-20\"><a href=\"#使用-20\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PolyhedronBufferGeometry(vertices : Array, indices : Array, radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>vertices — Array 以 [1,1,1, -1,-1,-1, … ] 这种形式出现的点的数组<br>faces — Array 以 [0,1,2, 2,3,0, … ] 这种形式出现的构成各个面的指数数组<br>radius — Float - 最终形状的半径<br>detail — Integer - 把几何模型细分成多少层. 层越多形状越光滑.  </p>\n<h2 id=\"属性-24\"><a href=\"#属性-24\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-24\"><a href=\"#parameters-Object-24\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"RingGeometry\"><a href=\"#RingGeometry\" class=\"headerlink\" title=\"RingGeometry\"></a>RingGeometry</h1><h2 id=\"概念-22\"><a href=\"#概念-22\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成二维环几何的类</p>\n<h2 id=\"使用-21\"><a href=\"#使用-21\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RingGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>innerRadius — 默认值为0.5.<br>outerRadius — 默认值为1.<br>thetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8.<br>phiSegments — 最小值为1. 默认值为8.<br>thetaStart — 开始角度. 默认值为0.<br>thetaLength — 圆心角. 默认值为Math.PI * 2.</p>\n<h2 id=\"属性-25\"><a href=\"#属性-25\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-25\"><a href=\"#parameters-Object-25\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"RingBufferGeometry\"><a href=\"#RingBufferGeometry\" class=\"headerlink\" title=\"RingBufferGeometry\"></a>RingBufferGeometry</h1><h2 id=\"概念-23\"><a href=\"#概念-23\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成二维环几何的类</p>\n<h2 id=\"使用-22\"><a href=\"#使用-22\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RingBufferGeometry(innerRadius : Float, outerRadius : Float, thetaSegments : Integer, phiSegments : Integer, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>innerRadius — 默认值为0.5.<br>outerRadius — 默认值为1.<br>thetaSegments — 分割面数量. 更高的值意味着更加的圆滑. 最小值为3. 默认值为8.<br>phiSegments — 最小值为1. 默认值为8.<br>thetaStart — 开始角度. 默认值为0.<br>thetaLength — 圆心角. 默认值为Math.PI * 2.</p>\n<h2 id=\"属性-26\"><a href=\"#属性-26\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-26\"><a href=\"#parameters-Object-26\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ShapeGeometry\"><a href=\"#ShapeGeometry\" class=\"headerlink\" title=\"ShapeGeometry\"></a>ShapeGeometry</h1><h2 id=\"概念-24\"><a href=\"#概念-24\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从一个或多个路径形状创建单面多边形几何</p>\n<h2 id=\"使用-23\"><a href=\"#使用-23\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShapeGeometry(shapes : Array, curveSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>shape - 形状数组或单个形状<br>curveSegments - 整数 - 每个形状的段数。 默认值为12   </p>\n<h2 id=\"属性-27\"><a href=\"#属性-27\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-27\"><a href=\"#parameters-Object-27\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"ShapeBufferGeometry\"><a href=\"#ShapeBufferGeometry\" class=\"headerlink\" title=\"ShapeBufferGeometry\"></a>ShapeBufferGeometry</h1><h2 id=\"概念-25\"><a href=\"#概念-25\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>从一个或多个路径形状创建单面多边形几何</p>\n<h2 id=\"使用-24\"><a href=\"#使用-24\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShapeBufferGeometry(shapes : Array, curveSegments : Integer)</span><br></pre></td></tr></table></figure>\n<p>shape - 形状数组或单个形状<br>curveSegments - 整数 - 每个形状的段数。 默认值为12   </p>\n<h2 id=\"属性-28\"><a href=\"#属性-28\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-28\"><a href=\"#parameters-Object-28\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"SphereGeometry\"><a href=\"#SphereGeometry\" class=\"headerlink\" title=\"SphereGeometry\"></a>SphereGeometry</h1><h2 id=\"概念-26\"><a href=\"#概念-26\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成球体几何的类</p>\n<h2 id=\"使用-25\"><a href=\"#使用-25\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 球体半径. 默认值为50<br>widthSegments — 水平分割面的数量. 最小值为3, 默认值为8<br>heightSegments — 垂直分割面的数量. 最小值为2, 默认值为6<br>phiStart — 指定水平起始角度. 默认值为0<br>phiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2<br>thetaStart — 指定垂直起始角度. 默认值为0<br>thetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  </p>\n<p>几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于’sphere slices’）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建</p>\n<h2 id=\"属性-29\"><a href=\"#属性-29\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-29\"><a href=\"#parameters-Object-29\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"SphereBufferGeometry\"><a href=\"#SphereBufferGeometry\" class=\"headerlink\" title=\"SphereBufferGeometry\"></a>SphereBufferGeometry</h1><h2 id=\"概念-27\"><a href=\"#概念-27\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成球体几何的类</p>\n<h2 id=\"使用-26\"><a href=\"#使用-26\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 球体半径. 默认值为50<br>widthSegments — 水平分割面的数量. 最小值为3, 默认值为8<br>heightSegments — 垂直分割面的数量. 最小值为2, 默认值为6<br>phiStart — 指定水平起始角度. 默认值为0<br>phiLength — 指定水平扫描角度大小. 默认值为 Math.PI * 2<br>thetaStart — 指定垂直起始角度. 默认值为0<br>thetaLength — 指定垂直扫描角度大小. 默认值为Math.PI  </p>\n<p>几何模型是通过扫描和计算绕Y轴（水平扫描）和Z轴（垂直扫描）的顶点创建而成。因此，不完整的球（类似于’sphere slices’）可以通过对phistart，philength，thetastart和thetalength使用不同的值来创建</p>\n<h2 id=\"属性-30\"><a href=\"#属性-30\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-30\"><a href=\"#parameters-Object-30\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TetrahedronGeometry\"><a href=\"#TetrahedronGeometry\" class=\"headerlink\" title=\"TetrahedronGeometry\"></a>TetrahedronGeometry</h1><h2 id=\"概念-28\"><a href=\"#概念-28\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成四面体几何的类</p>\n<h2 id=\"使用-27\"><a href=\"#使用-27\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TetrahedronGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 四面体半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.</p>\n<h2 id=\"属性-31\"><a href=\"#属性-31\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-31\"><a href=\"#parameters-Object-31\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TetrahedronBufferGeometry\"><a href=\"#TetrahedronBufferGeometry\" class=\"headerlink\" title=\"TetrahedronBufferGeometry\"></a>TetrahedronBufferGeometry</h1><h2 id=\"概念-29\"><a href=\"#概念-29\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成四面体几何的类</p>\n<h2 id=\"使用-28\"><a href=\"#使用-28\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TetrahedronBufferGeometry(radius : Float, detail : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 四面体半径. 默认值为1.<br>detail — 默认值为0. 设置为大于0的值将添加顶点使之不再是一个四面体.</p>\n<h2 id=\"属性-32\"><a href=\"#属性-32\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-32\"><a href=\"#parameters-Object-32\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TextGeometry\"><a href=\"#TextGeometry\" class=\"headerlink\" title=\"TextGeometry\"></a>TextGeometry</h1><h2 id=\"概念-30\"><a href=\"#概念-30\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的</p>\n<h2 id=\"使用-29\"><a href=\"#使用-29\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextGeometry(text : String, parameters : Object)</span><br></pre></td></tr></table></figure>\n<p>text — 要显示的文字<br>parameters — 包含下面这些参数的对象  </p>\n<ul>\n<li>font — THREE.Font. 字体实例.</li>\n<li>size — Float. 文字大小， 默认为100.</li>\n<li>height — Float. 文字厚度. 默认值为50.   </li>\n<li>curveSegments — Integer. 曲线上点的数量. 默认值为12.</li>\n<li>bevelEnabled — Boolean. 是否打开斜面. 默认值为False.</li>\n<li>bevelThickness — Float. 文本斜面的深度. 默认值为10.</li>\n<li>bevelSize — Float. 斜面离轮廓的距离. 默认值为8.</li>\n<li>bevelSegments - Integer. 斜角段数. 默认值为3.</li>\n<li><h2 id=\"属性-33\"><a href=\"#属性-33\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-33\"><a href=\"#parameters-Object-33\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3></li>\n</ul>\n<p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TextBufferGeometry\"><a href=\"#TextBufferGeometry\" class=\"headerlink\" title=\"TextBufferGeometry\"></a>TextBufferGeometry</h1><h2 id=\"概念-31\"><a href=\"#概念-31\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于将文本生成为单个几何的类。 它是文本和传入的属性对象创建的</p>\n<h2 id=\"使用-30\"><a href=\"#使用-30\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TextBufferGeometry(text : String, parameters : Object)</span><br></pre></td></tr></table></figure>\n<p>text — 要显示的文字<br>parameters — 包含下面这些参数的对象  </p>\n<ul>\n<li>font — THREE.Font. 字体实例.</li>\n<li>size — Float. 文字大小， 默认为100.</li>\n<li>height — Float. 文字厚度. 默认值为50.   </li>\n<li>curveSegments — Integer. 曲线上点的数量. 默认值为12.</li>\n<li>bevelEnabled — Boolean. 是否打开斜面. 默认值为False.</li>\n<li>bevelThickness — Float. 文本斜面的深度. 默认值为10.</li>\n<li>bevelSize — Float. 斜面离轮廓的距离. 默认值为8.</li>\n<li>bevelSegments - Integer. 斜角段数. 默认值为3.</li>\n</ul>\n<h2 id=\"属性-34\"><a href=\"#属性-34\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-34\"><a href=\"#parameters-Object-34\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusGeometry\"><a href=\"#TorusGeometry\" class=\"headerlink\" title=\"TorusGeometry\"></a>TorusGeometry</h1><h2 id=\"概念-32\"><a href=\"#概念-32\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆环几何的类</p>\n<h2 id=\"使用-31\"><a href=\"#使用-31\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>radialSegments — 默认值为8<br>tubularSegments — 默认值为6.<br>arc — 圆心角. 默认值为Math.PI * 2.  </p>\n<h2 id=\"属性-35\"><a href=\"#属性-35\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-35\"><a href=\"#parameters-Object-35\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusBufferGeometry\"><a href=\"#TorusBufferGeometry\" class=\"headerlink\" title=\"TorusBufferGeometry\"></a>TorusBufferGeometry</h1><h2 id=\"概念-33\"><a href=\"#概念-33\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用于生成圆环几何的类</p>\n<h2 id=\"使用-32\"><a href=\"#使用-32\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusBufferGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>radialSegments — 默认值为8<br>tubularSegments — 默认值为6.<br>arc — 圆心角. 默认值为Math.PI * 2.  </p>\n<h2 id=\"属性-36\"><a href=\"#属性-36\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-36\"><a href=\"#parameters-Object-36\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusKnotGeometry\"><a href=\"#TorusKnotGeometry\" class=\"headerlink\" title=\"TorusKnotGeometry\"></a>TorusKnotGeometry</h1><h2 id=\"概念-34\"><a href=\"#概念-34\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。</p>\n<h2 id=\"使用-33\"><a href=\"#使用-33\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusKnotGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>tubularSegments — 默认值为64.<br>radialSegments — 默认值为8.<br>p — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.<br>q — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3.  </p>\n<h2 id=\"属性-37\"><a href=\"#属性-37\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-37\"><a href=\"#parameters-Object-37\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TorusKnotBufferGeometry\"><a href=\"#TorusKnotBufferGeometry\" class=\"headerlink\" title=\"TorusKnotBufferGeometry\"></a>TorusKnotBufferGeometry</h1><h2 id=\"概念-35\"><a href=\"#概念-35\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建圆环结，其特定形状由一对互质整数p和q定义。 如果p和q不是互质的，则结果将是环面链接。</p>\n<h2 id=\"使用-34\"><a href=\"#使用-34\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TorusKnotBufferGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)</span><br></pre></td></tr></table></figure>\n<p>radius — 半径, 默认值为1.<br>tube — 管道直径. 默认值为 0.4.<br>tubularSegments — 默认值为64.<br>radialSegments — 默认值为8.<br>p — 这个值决定了几何体绕旋转对称轴绕了多少圈. 默认值为2.<br>q — 这个值决定了几何体绕环面的圆绕了多少圈. 默认值为3. </p>\n<h2 id=\"属性-38\"><a href=\"#属性-38\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-38\"><a href=\"#parameters-Object-38\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TubeGeometry\"><a href=\"#TubeGeometry\" class=\"headerlink\" title=\"TubeGeometry\"></a>TubeGeometry</h1><h2 id=\"概念-36\"><a href=\"#概念-36\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建一个沿3d曲线挤出的管子</p>\n<h2 id=\"使用-35\"><a href=\"#使用-35\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TubeGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</span><br></pre></td></tr></table></figure>\n<p>path — Curve - 从 Curve 基本类继承而来的路径<br>segments — Integer - 组成管道的分割面数量, 默认值为64<br>radius — Float - 管道半径, 默认值为1<br>radiusSegments — Integer - 组成截面的分割面数量, 默认值为8<br>closed — Boolean 管道是开放的还是闭合的, 默认值为false   </p>\n<h2 id=\"属性-39\"><a href=\"#属性-39\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-39\"><a href=\"#parameters-Object-39\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"TubeBufferGeometry\"><a href=\"#TubeBufferGeometry\" class=\"headerlink\" title=\"TubeBufferGeometry\"></a>TubeBufferGeometry</h1><h2 id=\"概念-37\"><a href=\"#概念-37\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>创建一个沿3d曲线挤出的管子</p>\n<h2 id=\"使用-36\"><a href=\"#使用-36\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TubeBufferGeometry(path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)</span><br></pre></td></tr></table></figure>\n<p>path — Curve - 从 Curve 基本类继承而来的路径<br>segments — Integer - 组成管道的分割面数量, 默认值为64<br>radius — Float - 管道半径, 默认值为1<br>radiusSegments — Integer - 组成截面的分割面数量, 默认值为8<br>closed — Boolean 管道是开放的还是闭合的, 默认值为false   </p>\n<h2 id=\"属性-40\"><a href=\"#属性-40\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"parameters-Object-40\"><a href=\"#parameters-Object-40\" class=\"headerlink\" title=\"parameters : Object\"></a>parameters : Object</h3><p>具有每个构造函数参数的属性的对象。 实例化后的任何修改都不会更改几何  </p>\n<h1 id=\"WireframeGeometry\"><a href=\"#WireframeGeometry\" class=\"headerlink\" title=\"WireframeGeometry\"></a>WireframeGeometry</h1><h2 id=\"概念-38\"><a href=\"#概念-38\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>这可以用作辅助对象，从线框角度观察Geometry对象</p>\n<h2 id=\"使用-37\"><a href=\"#使用-37\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WireframeGeometry( geometry : Geometry )</span><br></pre></td></tr></table></figure>\n<p>geometry — 任何几何对象</p>\n"},{"title":"webstrom 快捷键","_content":"\n# 快捷键\n\n## Editing\n\n### ^Space \n基础打代码自动补全\n对于路径补全，重复快捷键可选择上层路径\n\n### ⌥⏎\n显示意图动作快速修复\n\n### ⌘P\n查看调用方法的参数信息\n\n### ^J\n快速文档查找\n\n### ⌘ + mouse over code \n查看信息简介\n\n### ⌘F1\n在插入符号上显示错误或警告的描述\n\n### ^J⏎,⌘N\n生成代码......\n\n### ⌥⌘T\n添加包裹代码 (if..else, try..catch, for, etc.)\n\n### ⌘J\n插入当前语言模板\n\n### ⌘/\n取消/添加单行注释\n\n### ⌘⇧/\n取消/添加块级注释\n\n### ⌥↑\n选择连续增加的代码块\n\n### ⌥↓\n将当前选择减少到先前的状态\n\n### ^⇧Q\n上下文信息\n\n### ⌥⌘L\n格式化代码\n\n### ⌥⌘I\n自动缩进行\n\n### ⇥\n缩进选择行\n\n### ⇧⇥\n取消缩进选择行\n\n### ⌘⇧V\n从最近的缓冲区粘贴\n\n### ⌘D\n复制当前行或选定块\n\n### ⌘⌫\n在插入符号处删除行\n\n### ⌥⇧↑\n向上移动当前行\n\n### ⌥⇧↓\n向下移动当前行\n\n### ⌃⇧J\n合并行\n\n### ⌘↩︎\n分离行\n\n### ⇧↩︎\n创建新空白行\n\n### ⌘⇧U\n在插入符号或选定的块中切换单词的大小写\n\n### ⌥⌘⇧]\n选择直到代码块结束\n\n### ⌥⇧⌘[\n选择直到代码块开始\n\n### ⌥⌦\n删除到单词结束\n\n### ⌥⌫\n删除到单词开始\n\n### ⌘+/⌘-\n展开/折叠代码块\n\n### ⇧⌘+\n展开所有代码\n\n### ⇧⌘-\n折叠所有代码\n\n### ⌘W\n关闭当前tab\n\n##Multiple carets and selections\n\n### ⌥ + click\n添加或删除插入符号\n\n### ⌃⌘G\n选择所有出现\n\n### ⌃G\n选择下一个出现的\n\n### ⌃⇧G\n取消下一个出现的\n\n### ⎋\n取消选择所有出现或插入符号\n\n## Search/Replace\n###⌘F/⌘R\n查找/ 替换\n\n###⌘G/⇧⌘G\n查找下一个/上一个\n\n###⇧⌘F\n在当前文件路径下查找\n\n###⇧⌘R\n在当前文件路径下替换\n\n## General\n\n### Double ⇧\n全局查找\n\n### ⇧⌘A\n在action查找\n\n### ⌘0...⌘9\n打开相应的工具窗口\n\n### ⇧⌘F12\n切换最大化编辑器\n\n### ⌥⇧F\n添加到Favorites\n### ⌥⇧I\n使用当前配置文件检查当前文件\n\n### ⌃§,⌃`\n快速切换当前的scheme（切换主题、代码样式等）\n\n### ⌘,\n打开偏好设置\n\n### ⌃⇥\n在标签和工具窗口之间切换\n\n## Usage Search\n### ⌥F7\n查找使用\n\n### ⌘F7\n在文件内查找使用\n\n### ⇧⌘F7\n在文件内高亮使用\n\n### ⌥⌘F7\n显示用法\n\n## Refactoring\n\n### ⌃T\n重构这个\n\n### F5/F6\n复制/移动\n\n### ⌘⌦\n安全删除\n\n### ⇧F6\n重命名\n\n### ⌘F6\n更改函数签名\n\n### ⌥⌘N\n内联变量\n\n### ⌥⌘V\n提取变量\n\n### ⌥⌘C\n提取常量\n\n### ⌥⌘P\n提取参数\n\n## VCS/Local History\n### ⌃V\nvCS快速弹出\n\n### ⌘K\n提交项目到VCS\n\n### ⌘T\n从VCS更新项目\n\n### ⌥⇧C\n查看最近改动\n\n## Running\n### ⌃⌥R\n选择配置并运行\n\n### ⌃⌥D\n选择配置开始调试\n\n### ⌃R/⌃D\n运行/调试\n\n### ⌃⇧R,⌃⇧D\n从编辑器运行上下文配置\n\n### ⌃⌘R\n再运行测试\n\n### ⌥F11\n运行Gulp/Grunt/npm任务\n\n## Debugging\n### F8/F7\n跳过/ 跳入\n\n### ⇧F7\n智能挑入\n\n### ⇧F8\n跳出\n\n### ⌥F9\n运行到光标处\n\n### ⌥F8\n表达式 求知\n\n### ⌥⌘R\n重新开始\n\n### ⌘F8\n切换断点\n\n### ⇧⌘F8\n查看断点\n\nNavigation\n### ⌘B, ⌘click\n查找并定位到declaratior\n\n### ⌘O\n查找并定位到class\n\n### ⇧⌘O\n查找并打开文件\n\n### ⌥⌘O\n查找并定位到symbol\n\n### ⇧⌘]\n到下一个编辑标签页\n\n### ⇧⌘[\n到上一个编辑标签页\n\n### F12\n返回上一个工具窗口\n\n### ⎋\n跳转到编辑器（从工具窗口）\n\n### ⌘L\n打开行数跳转窗口\n\n### ⌘E\n弹出最近文件窗口\n\n### ⌥⌘←\n回退导航\n\n### ⌥⌘→\n向前导航\n\n### ⌘⇧⌫\n导航到上次编辑位置\n\n### ⌥F1\n在任何视图中选择当前文件或符号\n\n### ⌥⌘B\n转到实施\n\n### ⌥Space, ⌘Y\n打开快速定义查找\n\n### ⌃⇧B\n转到类型声明\n\n### ⌘U\n转到super方法/super类\n\n### ⌃↑\n转到上一个方法\n\n###⌃↓\n转到下一个方法\n\n### ⌥⌘]\n到代码块结尾\n\n### ⌥⌘[\n到代码块开头\n\n### ⌃M\n将插入符号移动到匹配的大括号\n\n### ⌘F12\n文件结构弹出窗口\n\n### ⌃H\n类型层次结构\n\n### ⌃⌥H\n调用层次结构\n\n### F2\n下一个高亮错误\n\n### ⇧F2\n上一个高亮错误\n\n### F4, ⌘↓\n跳转到源头\n\n### ⌘↑\n跳转到导航栏\n\n### F3\n切换书签\n\n### ⌥F3\n用助记符切换书签\n\n### ⌃0...⌃9\n转到编号书签\n\n### ⌘F3\n显示书签\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/webstrom- 快捷键.md","raw":"title:      \"webstrom 快捷键\"\ntags:\n    - webstrom IDE\n---\n\n# 快捷键\n\n## Editing\n\n### ^Space \n基础打代码自动补全\n对于路径补全，重复快捷键可选择上层路径\n\n### ⌥⏎\n显示意图动作快速修复\n\n### ⌘P\n查看调用方法的参数信息\n\n### ^J\n快速文档查找\n\n### ⌘ + mouse over code \n查看信息简介\n\n### ⌘F1\n在插入符号上显示错误或警告的描述\n\n### ^J⏎,⌘N\n生成代码......\n\n### ⌥⌘T\n添加包裹代码 (if..else, try..catch, for, etc.)\n\n### ⌘J\n插入当前语言模板\n\n### ⌘/\n取消/添加单行注释\n\n### ⌘⇧/\n取消/添加块级注释\n\n### ⌥↑\n选择连续增加的代码块\n\n### ⌥↓\n将当前选择减少到先前的状态\n\n### ^⇧Q\n上下文信息\n\n### ⌥⌘L\n格式化代码\n\n### ⌥⌘I\n自动缩进行\n\n### ⇥\n缩进选择行\n\n### ⇧⇥\n取消缩进选择行\n\n### ⌘⇧V\n从最近的缓冲区粘贴\n\n### ⌘D\n复制当前行或选定块\n\n### ⌘⌫\n在插入符号处删除行\n\n### ⌥⇧↑\n向上移动当前行\n\n### ⌥⇧↓\n向下移动当前行\n\n### ⌃⇧J\n合并行\n\n### ⌘↩︎\n分离行\n\n### ⇧↩︎\n创建新空白行\n\n### ⌘⇧U\n在插入符号或选定的块中切换单词的大小写\n\n### ⌥⌘⇧]\n选择直到代码块结束\n\n### ⌥⇧⌘[\n选择直到代码块开始\n\n### ⌥⌦\n删除到单词结束\n\n### ⌥⌫\n删除到单词开始\n\n### ⌘+/⌘-\n展开/折叠代码块\n\n### ⇧⌘+\n展开所有代码\n\n### ⇧⌘-\n折叠所有代码\n\n### ⌘W\n关闭当前tab\n\n##Multiple carets and selections\n\n### ⌥ + click\n添加或删除插入符号\n\n### ⌃⌘G\n选择所有出现\n\n### ⌃G\n选择下一个出现的\n\n### ⌃⇧G\n取消下一个出现的\n\n### ⎋\n取消选择所有出现或插入符号\n\n## Search/Replace\n###⌘F/⌘R\n查找/ 替换\n\n###⌘G/⇧⌘G\n查找下一个/上一个\n\n###⇧⌘F\n在当前文件路径下查找\n\n###⇧⌘R\n在当前文件路径下替换\n\n## General\n\n### Double ⇧\n全局查找\n\n### ⇧⌘A\n在action查找\n\n### ⌘0...⌘9\n打开相应的工具窗口\n\n### ⇧⌘F12\n切换最大化编辑器\n\n### ⌥⇧F\n添加到Favorites\n### ⌥⇧I\n使用当前配置文件检查当前文件\n\n### ⌃§,⌃`\n快速切换当前的scheme（切换主题、代码样式等）\n\n### ⌘,\n打开偏好设置\n\n### ⌃⇥\n在标签和工具窗口之间切换\n\n## Usage Search\n### ⌥F7\n查找使用\n\n### ⌘F7\n在文件内查找使用\n\n### ⇧⌘F7\n在文件内高亮使用\n\n### ⌥⌘F7\n显示用法\n\n## Refactoring\n\n### ⌃T\n重构这个\n\n### F5/F6\n复制/移动\n\n### ⌘⌦\n安全删除\n\n### ⇧F6\n重命名\n\n### ⌘F6\n更改函数签名\n\n### ⌥⌘N\n内联变量\n\n### ⌥⌘V\n提取变量\n\n### ⌥⌘C\n提取常量\n\n### ⌥⌘P\n提取参数\n\n## VCS/Local History\n### ⌃V\nvCS快速弹出\n\n### ⌘K\n提交项目到VCS\n\n### ⌘T\n从VCS更新项目\n\n### ⌥⇧C\n查看最近改动\n\n## Running\n### ⌃⌥R\n选择配置并运行\n\n### ⌃⌥D\n选择配置开始调试\n\n### ⌃R/⌃D\n运行/调试\n\n### ⌃⇧R,⌃⇧D\n从编辑器运行上下文配置\n\n### ⌃⌘R\n再运行测试\n\n### ⌥F11\n运行Gulp/Grunt/npm任务\n\n## Debugging\n### F8/F7\n跳过/ 跳入\n\n### ⇧F7\n智能挑入\n\n### ⇧F8\n跳出\n\n### ⌥F9\n运行到光标处\n\n### ⌥F8\n表达式 求知\n\n### ⌥⌘R\n重新开始\n\n### ⌘F8\n切换断点\n\n### ⇧⌘F8\n查看断点\n\nNavigation\n### ⌘B, ⌘click\n查找并定位到declaratior\n\n### ⌘O\n查找并定位到class\n\n### ⇧⌘O\n查找并打开文件\n\n### ⌥⌘O\n查找并定位到symbol\n\n### ⇧⌘]\n到下一个编辑标签页\n\n### ⇧⌘[\n到上一个编辑标签页\n\n### F12\n返回上一个工具窗口\n\n### ⎋\n跳转到编辑器（从工具窗口）\n\n### ⌘L\n打开行数跳转窗口\n\n### ⌘E\n弹出最近文件窗口\n\n### ⌥⌘←\n回退导航\n\n### ⌥⌘→\n向前导航\n\n### ⌘⇧⌫\n导航到上次编辑位置\n\n### ⌥F1\n在任何视图中选择当前文件或符号\n\n### ⌥⌘B\n转到实施\n\n### ⌥Space, ⌘Y\n打开快速定义查找\n\n### ⌃⇧B\n转到类型声明\n\n### ⌘U\n转到super方法/super类\n\n### ⌃↑\n转到上一个方法\n\n###⌃↓\n转到下一个方法\n\n### ⌥⌘]\n到代码块结尾\n\n### ⌥⌘[\n到代码块开头\n\n### ⌃M\n将插入符号移动到匹配的大括号\n\n### ⌘F12\n文件结构弹出窗口\n\n### ⌃H\n类型层次结构\n\n### ⌃⌥H\n调用层次结构\n\n### F2\n下一个高亮错误\n\n### ⇧F2\n上一个高亮错误\n\n### F4, ⌘↓\n跳转到源头\n\n### ⌘↑\n跳转到导航栏\n\n### F3\n切换书签\n\n### ⌥F3\n用助记符切换书签\n\n### ⌃0...⌃9\n转到编号书签\n\n### ⌘F3\n显示书签\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"webstrom- 快捷键","published":1,"date":"2019-01-01T14:10:03.019Z","updated":"2019-01-01T14:10:03.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqdty1l30000cyjfz0zvsv4k","content":"<h1 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h1><h2 id=\"Editing\"><a href=\"#Editing\" class=\"headerlink\" title=\"Editing\"></a>Editing</h2><h3 id=\"Space\"><a href=\"#Space\" class=\"headerlink\" title=\"^Space\"></a>^Space</h3><p>基础打代码自动补全<br>对于路径补全，重复快捷键可选择上层路径</p>\n<h3 id=\"⌥⏎\"><a href=\"#⌥⏎\" class=\"headerlink\" title=\"⌥⏎\"></a>⌥⏎</h3><p>显示意图动作快速修复</p>\n<h3 id=\"⌘P\"><a href=\"#⌘P\" class=\"headerlink\" title=\"⌘P\"></a>⌘P</h3><p>查看调用方法的参数信息</p>\n<h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"^J\"></a>^J</h3><p>快速文档查找</p>\n<h3 id=\"⌘-mouse-over-code\"><a href=\"#⌘-mouse-over-code\" class=\"headerlink\" title=\"⌘ + mouse over code\"></a>⌘ + mouse over code</h3><p>查看信息简介</p>\n<h3 id=\"⌘F1\"><a href=\"#⌘F1\" class=\"headerlink\" title=\"⌘F1\"></a>⌘F1</h3><p>在插入符号上显示错误或警告的描述</p>\n<h3 id=\"J⏎-⌘N\"><a href=\"#J⏎-⌘N\" class=\"headerlink\" title=\"^J⏎,⌘N\"></a>^J⏎,⌘N</h3><p>生成代码……</p>\n<h3 id=\"⌥⌘T\"><a href=\"#⌥⌘T\" class=\"headerlink\" title=\"⌥⌘T\"></a>⌥⌘T</h3><p>添加包裹代码 (if..else, try..catch, for, etc.)</p>\n<h3 id=\"⌘J\"><a href=\"#⌘J\" class=\"headerlink\" title=\"⌘J\"></a>⌘J</h3><p>插入当前语言模板</p>\n<h3 id=\"⌘\"><a href=\"#⌘\" class=\"headerlink\" title=\"⌘/\"></a>⌘/</h3><p>取消/添加单行注释</p>\n<h3 id=\"⌘⇧\"><a href=\"#⌘⇧\" class=\"headerlink\" title=\"⌘⇧/\"></a>⌘⇧/</h3><p>取消/添加块级注释</p>\n<h3 id=\"⌥↑\"><a href=\"#⌥↑\" class=\"headerlink\" title=\"⌥↑\"></a>⌥↑</h3><p>选择连续增加的代码块</p>\n<h3 id=\"⌥↓\"><a href=\"#⌥↓\" class=\"headerlink\" title=\"⌥↓\"></a>⌥↓</h3><p>将当前选择减少到先前的状态</p>\n<h3 id=\"⇧Q\"><a href=\"#⇧Q\" class=\"headerlink\" title=\"^⇧Q\"></a>^⇧Q</h3><p>上下文信息</p>\n<h3 id=\"⌥⌘L\"><a href=\"#⌥⌘L\" class=\"headerlink\" title=\"⌥⌘L\"></a>⌥⌘L</h3><p>格式化代码</p>\n<h3 id=\"⌥⌘I\"><a href=\"#⌥⌘I\" class=\"headerlink\" title=\"⌥⌘I\"></a>⌥⌘I</h3><p>自动缩进行</p>\n<h3 id=\"⇥\"><a href=\"#⇥\" class=\"headerlink\" title=\"⇥\"></a>⇥</h3><p>缩进选择行</p>\n<h3 id=\"⇧⇥\"><a href=\"#⇧⇥\" class=\"headerlink\" title=\"⇧⇥\"></a>⇧⇥</h3><p>取消缩进选择行</p>\n<h3 id=\"⌘⇧V\"><a href=\"#⌘⇧V\" class=\"headerlink\" title=\"⌘⇧V\"></a>⌘⇧V</h3><p>从最近的缓冲区粘贴</p>\n<h3 id=\"⌘D\"><a href=\"#⌘D\" class=\"headerlink\" title=\"⌘D\"></a>⌘D</h3><p>复制当前行或选定块</p>\n<h3 id=\"⌘⌫\"><a href=\"#⌘⌫\" class=\"headerlink\" title=\"⌘⌫\"></a>⌘⌫</h3><p>在插入符号处删除行</p>\n<h3 id=\"⌥⇧↑\"><a href=\"#⌥⇧↑\" class=\"headerlink\" title=\"⌥⇧↑\"></a>⌥⇧↑</h3><p>向上移动当前行</p>\n<h3 id=\"⌥⇧↓\"><a href=\"#⌥⇧↓\" class=\"headerlink\" title=\"⌥⇧↓\"></a>⌥⇧↓</h3><p>向下移动当前行</p>\n<h3 id=\"⌃⇧J\"><a href=\"#⌃⇧J\" class=\"headerlink\" title=\"⌃⇧J\"></a>⌃⇧J</h3><p>合并行</p>\n<h3 id=\"⌘↩︎\"><a href=\"#⌘↩︎\" class=\"headerlink\" title=\"⌘↩︎\"></a>⌘↩︎</h3><p>分离行</p>\n<h3 id=\"⇧↩︎\"><a href=\"#⇧↩︎\" class=\"headerlink\" title=\"⇧↩︎\"></a>⇧↩︎</h3><p>创建新空白行</p>\n<h3 id=\"⌘⇧U\"><a href=\"#⌘⇧U\" class=\"headerlink\" title=\"⌘⇧U\"></a>⌘⇧U</h3><p>在插入符号或选定的块中切换单词的大小写</p>\n<h3 id=\"⌥⌘⇧\"><a href=\"#⌥⌘⇧\" class=\"headerlink\" title=\"⌥⌘⇧]\"></a>⌥⌘⇧]</h3><p>选择直到代码块结束</p>\n<h3 id=\"⌥⇧⌘\"><a href=\"#⌥⇧⌘\" class=\"headerlink\" title=\"⌥⇧⌘[\"></a>⌥⇧⌘[</h3><p>选择直到代码块开始</p>\n<h3 id=\"⌥⌦\"><a href=\"#⌥⌦\" class=\"headerlink\" title=\"⌥⌦\"></a>⌥⌦</h3><p>删除到单词结束</p>\n<h3 id=\"⌥⌫\"><a href=\"#⌥⌫\" class=\"headerlink\" title=\"⌥⌫\"></a>⌥⌫</h3><p>删除到单词开始</p>\n<h3 id=\"⌘-⌘\"><a href=\"#⌘-⌘\" class=\"headerlink\" title=\"⌘+/⌘-\"></a>⌘+/⌘-</h3><p>展开/折叠代码块</p>\n<h3 id=\"⇧⌘\"><a href=\"#⇧⌘\" class=\"headerlink\" title=\"⇧⌘+\"></a>⇧⌘+</h3><p>展开所有代码</p>\n<h3 id=\"⇧⌘-1\"><a href=\"#⇧⌘-1\" class=\"headerlink\" title=\"⇧⌘-\"></a>⇧⌘-</h3><p>折叠所有代码</p>\n<h3 id=\"⌘W\"><a href=\"#⌘W\" class=\"headerlink\" title=\"⌘W\"></a>⌘W</h3><p>关闭当前tab</p>\n<p>##Multiple carets and selections</p>\n<h3 id=\"⌥-click\"><a href=\"#⌥-click\" class=\"headerlink\" title=\"⌥ + click\"></a>⌥ + click</h3><p>添加或删除插入符号</p>\n<h3 id=\"⌃⌘G\"><a href=\"#⌃⌘G\" class=\"headerlink\" title=\"⌃⌘G\"></a>⌃⌘G</h3><p>选择所有出现</p>\n<h3 id=\"⌃G\"><a href=\"#⌃G\" class=\"headerlink\" title=\"⌃G\"></a>⌃G</h3><p>选择下一个出现的</p>\n<h3 id=\"⌃⇧G\"><a href=\"#⌃⇧G\" class=\"headerlink\" title=\"⌃⇧G\"></a>⌃⇧G</h3><p>取消下一个出现的</p>\n<h3 id=\"⎋\"><a href=\"#⎋\" class=\"headerlink\" title=\"⎋\"></a>⎋</h3><p>取消选择所有出现或插入符号</p>\n<h2 id=\"Search-Replace\"><a href=\"#Search-Replace\" class=\"headerlink\" title=\"Search/Replace\"></a>Search/Replace</h2><p>###⌘F/⌘R<br>查找/ 替换</p>\n<p>###⌘G/⇧⌘G<br>查找下一个/上一个</p>\n<p>###⇧⌘F<br>在当前文件路径下查找</p>\n<p>###⇧⌘R<br>在当前文件路径下替换</p>\n<h2 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h2><h3 id=\"Double-⇧\"><a href=\"#Double-⇧\" class=\"headerlink\" title=\"Double ⇧\"></a>Double ⇧</h3><p>全局查找</p>\n<h3 id=\"⇧⌘A\"><a href=\"#⇧⌘A\" class=\"headerlink\" title=\"⇧⌘A\"></a>⇧⌘A</h3><p>在action查找</p>\n<h3 id=\"⌘0…⌘9\"><a href=\"#⌘0…⌘9\" class=\"headerlink\" title=\"⌘0…⌘9\"></a>⌘0…⌘9</h3><p>打开相应的工具窗口</p>\n<h3 id=\"⇧⌘F12\"><a href=\"#⇧⌘F12\" class=\"headerlink\" title=\"⇧⌘F12\"></a>⇧⌘F12</h3><p>切换最大化编辑器</p>\n<h3 id=\"⌥⇧F\"><a href=\"#⌥⇧F\" class=\"headerlink\" title=\"⌥⇧F\"></a>⌥⇧F</h3><p>添加到Favorites</p>\n<h3 id=\"⌥⇧I\"><a href=\"#⌥⇧I\" class=\"headerlink\" title=\"⌥⇧I\"></a>⌥⇧I</h3><p>使用当前配置文件检查当前文件</p>\n<h3 id=\"⌃§-⌃\"><a href=\"#⌃§-⌃\" class=\"headerlink\" title=\"⌃§,⌃`\"></a>⌃§,⌃`</h3><p>快速切换当前的scheme（切换主题、代码样式等）</p>\n<h3 id=\"⌘-1\"><a href=\"#⌘-1\" class=\"headerlink\" title=\"⌘,\"></a>⌘,</h3><p>打开偏好设置</p>\n<h3 id=\"⌃⇥\"><a href=\"#⌃⇥\" class=\"headerlink\" title=\"⌃⇥\"></a>⌃⇥</h3><p>在标签和工具窗口之间切换</p>\n<h2 id=\"Usage-Search\"><a href=\"#Usage-Search\" class=\"headerlink\" title=\"Usage Search\"></a>Usage Search</h2><h3 id=\"⌥F7\"><a href=\"#⌥F7\" class=\"headerlink\" title=\"⌥F7\"></a>⌥F7</h3><p>查找使用</p>\n<h3 id=\"⌘F7\"><a href=\"#⌘F7\" class=\"headerlink\" title=\"⌘F7\"></a>⌘F7</h3><p>在文件内查找使用</p>\n<h3 id=\"⇧⌘F7\"><a href=\"#⇧⌘F7\" class=\"headerlink\" title=\"⇧⌘F7\"></a>⇧⌘F7</h3><p>在文件内高亮使用</p>\n<h3 id=\"⌥⌘F7\"><a href=\"#⌥⌘F7\" class=\"headerlink\" title=\"⌥⌘F7\"></a>⌥⌘F7</h3><p>显示用法</p>\n<h2 id=\"Refactoring\"><a href=\"#Refactoring\" class=\"headerlink\" title=\"Refactoring\"></a>Refactoring</h2><h3 id=\"⌃T\"><a href=\"#⌃T\" class=\"headerlink\" title=\"⌃T\"></a>⌃T</h3><p>重构这个</p>\n<h3 id=\"F5-F6\"><a href=\"#F5-F6\" class=\"headerlink\" title=\"F5/F6\"></a>F5/F6</h3><p>复制/移动</p>\n<h3 id=\"⌘⌦\"><a href=\"#⌘⌦\" class=\"headerlink\" title=\"⌘⌦\"></a>⌘⌦</h3><p>安全删除</p>\n<h3 id=\"⇧F6\"><a href=\"#⇧F6\" class=\"headerlink\" title=\"⇧F6\"></a>⇧F6</h3><p>重命名</p>\n<h3 id=\"⌘F6\"><a href=\"#⌘F6\" class=\"headerlink\" title=\"⌘F6\"></a>⌘F6</h3><p>更改函数签名</p>\n<h3 id=\"⌥⌘N\"><a href=\"#⌥⌘N\" class=\"headerlink\" title=\"⌥⌘N\"></a>⌥⌘N</h3><p>内联变量</p>\n<h3 id=\"⌥⌘V\"><a href=\"#⌥⌘V\" class=\"headerlink\" title=\"⌥⌘V\"></a>⌥⌘V</h3><p>提取变量</p>\n<h3 id=\"⌥⌘C\"><a href=\"#⌥⌘C\" class=\"headerlink\" title=\"⌥⌘C\"></a>⌥⌘C</h3><p>提取常量</p>\n<h3 id=\"⌥⌘P\"><a href=\"#⌥⌘P\" class=\"headerlink\" title=\"⌥⌘P\"></a>⌥⌘P</h3><p>提取参数</p>\n<h2 id=\"VCS-Local-History\"><a href=\"#VCS-Local-History\" class=\"headerlink\" title=\"VCS/Local History\"></a>VCS/Local History</h2><h3 id=\"⌃V\"><a href=\"#⌃V\" class=\"headerlink\" title=\"⌃V\"></a>⌃V</h3><p>vCS快速弹出</p>\n<h3 id=\"⌘K\"><a href=\"#⌘K\" class=\"headerlink\" title=\"⌘K\"></a>⌘K</h3><p>提交项目到VCS</p>\n<h3 id=\"⌘T\"><a href=\"#⌘T\" class=\"headerlink\" title=\"⌘T\"></a>⌘T</h3><p>从VCS更新项目</p>\n<h3 id=\"⌥⇧C\"><a href=\"#⌥⇧C\" class=\"headerlink\" title=\"⌥⇧C\"></a>⌥⇧C</h3><p>查看最近改动</p>\n<h2 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h2><h3 id=\"⌃⌥R\"><a href=\"#⌃⌥R\" class=\"headerlink\" title=\"⌃⌥R\"></a>⌃⌥R</h3><p>选择配置并运行</p>\n<h3 id=\"⌃⌥D\"><a href=\"#⌃⌥D\" class=\"headerlink\" title=\"⌃⌥D\"></a>⌃⌥D</h3><p>选择配置开始调试</p>\n<h3 id=\"⌃R-⌃D\"><a href=\"#⌃R-⌃D\" class=\"headerlink\" title=\"⌃R/⌃D\"></a>⌃R/⌃D</h3><p>运行/调试</p>\n<h3 id=\"⌃⇧R-⌃⇧D\"><a href=\"#⌃⇧R-⌃⇧D\" class=\"headerlink\" title=\"⌃⇧R,⌃⇧D\"></a>⌃⇧R,⌃⇧D</h3><p>从编辑器运行上下文配置</p>\n<h3 id=\"⌃⌘R\"><a href=\"#⌃⌘R\" class=\"headerlink\" title=\"⌃⌘R\"></a>⌃⌘R</h3><p>再运行测试</p>\n<h3 id=\"⌥F11\"><a href=\"#⌥F11\" class=\"headerlink\" title=\"⌥F11\"></a>⌥F11</h3><p>运行Gulp/Grunt/npm任务</p>\n<h2 id=\"Debugging\"><a href=\"#Debugging\" class=\"headerlink\" title=\"Debugging\"></a>Debugging</h2><h3 id=\"F8-F7\"><a href=\"#F8-F7\" class=\"headerlink\" title=\"F8/F7\"></a>F8/F7</h3><p>跳过/ 跳入</p>\n<h3 id=\"⇧F7\"><a href=\"#⇧F7\" class=\"headerlink\" title=\"⇧F7\"></a>⇧F7</h3><p>智能挑入</p>\n<h3 id=\"⇧F8\"><a href=\"#⇧F8\" class=\"headerlink\" title=\"⇧F8\"></a>⇧F8</h3><p>跳出</p>\n<h3 id=\"⌥F9\"><a href=\"#⌥F9\" class=\"headerlink\" title=\"⌥F9\"></a>⌥F9</h3><p>运行到光标处</p>\n<h3 id=\"⌥F8\"><a href=\"#⌥F8\" class=\"headerlink\" title=\"⌥F8\"></a>⌥F8</h3><p>表达式 求知</p>\n<h3 id=\"⌥⌘R\"><a href=\"#⌥⌘R\" class=\"headerlink\" title=\"⌥⌘R\"></a>⌥⌘R</h3><p>重新开始</p>\n<h3 id=\"⌘F8\"><a href=\"#⌘F8\" class=\"headerlink\" title=\"⌘F8\"></a>⌘F8</h3><p>切换断点</p>\n<h3 id=\"⇧⌘F8\"><a href=\"#⇧⌘F8\" class=\"headerlink\" title=\"⇧⌘F8\"></a>⇧⌘F8</h3><p>查看断点</p>\n<p>Navigation</p>\n<h3 id=\"⌘B-⌘click\"><a href=\"#⌘B-⌘click\" class=\"headerlink\" title=\"⌘B, ⌘click\"></a>⌘B, ⌘click</h3><p>查找并定位到declaratior</p>\n<h3 id=\"⌘O\"><a href=\"#⌘O\" class=\"headerlink\" title=\"⌘O\"></a>⌘O</h3><p>查找并定位到class</p>\n<h3 id=\"⇧⌘O\"><a href=\"#⇧⌘O\" class=\"headerlink\" title=\"⇧⌘O\"></a>⇧⌘O</h3><p>查找并打开文件</p>\n<h3 id=\"⌥⌘O\"><a href=\"#⌥⌘O\" class=\"headerlink\" title=\"⌥⌘O\"></a>⌥⌘O</h3><p>查找并定位到symbol</p>\n<h3 id=\"⇧⌘-2\"><a href=\"#⇧⌘-2\" class=\"headerlink\" title=\"⇧⌘]\"></a>⇧⌘]</h3><p>到下一个编辑标签页</p>\n<h3 id=\"⇧⌘-3\"><a href=\"#⇧⌘-3\" class=\"headerlink\" title=\"⇧⌘[\"></a>⇧⌘[</h3><p>到上一个编辑标签页</p>\n<h3 id=\"F12\"><a href=\"#F12\" class=\"headerlink\" title=\"F12\"></a>F12</h3><p>返回上一个工具窗口</p>\n<h3 id=\"⎋-1\"><a href=\"#⎋-1\" class=\"headerlink\" title=\"⎋\"></a>⎋</h3><p>跳转到编辑器（从工具窗口）</p>\n<h3 id=\"⌘L\"><a href=\"#⌘L\" class=\"headerlink\" title=\"⌘L\"></a>⌘L</h3><p>打开行数跳转窗口</p>\n<h3 id=\"⌘E\"><a href=\"#⌘E\" class=\"headerlink\" title=\"⌘E\"></a>⌘E</h3><p>弹出最近文件窗口</p>\n<h3 id=\"⌥⌘←\"><a href=\"#⌥⌘←\" class=\"headerlink\" title=\"⌥⌘←\"></a>⌥⌘←</h3><p>回退导航</p>\n<h3 id=\"⌥⌘→\"><a href=\"#⌥⌘→\" class=\"headerlink\" title=\"⌥⌘→\"></a>⌥⌘→</h3><p>向前导航</p>\n<h3 id=\"⌘⇧⌫\"><a href=\"#⌘⇧⌫\" class=\"headerlink\" title=\"⌘⇧⌫\"></a>⌘⇧⌫</h3><p>导航到上次编辑位置</p>\n<h3 id=\"⌥F1\"><a href=\"#⌥F1\" class=\"headerlink\" title=\"⌥F1\"></a>⌥F1</h3><p>在任何视图中选择当前文件或符号</p>\n<h3 id=\"⌥⌘B\"><a href=\"#⌥⌘B\" class=\"headerlink\" title=\"⌥⌘B\"></a>⌥⌘B</h3><p>转到实施</p>\n<h3 id=\"⌥Space-⌘Y\"><a href=\"#⌥Space-⌘Y\" class=\"headerlink\" title=\"⌥Space, ⌘Y\"></a>⌥Space, ⌘Y</h3><p>打开快速定义查找</p>\n<h3 id=\"⌃⇧B\"><a href=\"#⌃⇧B\" class=\"headerlink\" title=\"⌃⇧B\"></a>⌃⇧B</h3><p>转到类型声明</p>\n<h3 id=\"⌘U\"><a href=\"#⌘U\" class=\"headerlink\" title=\"⌘U\"></a>⌘U</h3><p>转到super方法/super类</p>\n<h3 id=\"⌃↑\"><a href=\"#⌃↑\" class=\"headerlink\" title=\"⌃↑\"></a>⌃↑</h3><p>转到上一个方法</p>\n<p>###⌃↓<br>转到下一个方法</p>\n<h3 id=\"⌥⌘\"><a href=\"#⌥⌘\" class=\"headerlink\" title=\"⌥⌘]\"></a>⌥⌘]</h3><p>到代码块结尾</p>\n<h3 id=\"⌥⌘-1\"><a href=\"#⌥⌘-1\" class=\"headerlink\" title=\"⌥⌘[\"></a>⌥⌘[</h3><p>到代码块开头</p>\n<h3 id=\"⌃M\"><a href=\"#⌃M\" class=\"headerlink\" title=\"⌃M\"></a>⌃M</h3><p>将插入符号移动到匹配的大括号</p>\n<h3 id=\"⌘F12\"><a href=\"#⌘F12\" class=\"headerlink\" title=\"⌘F12\"></a>⌘F12</h3><p>文件结构弹出窗口</p>\n<h3 id=\"⌃H\"><a href=\"#⌃H\" class=\"headerlink\" title=\"⌃H\"></a>⌃H</h3><p>类型层次结构</p>\n<h3 id=\"⌃⌥H\"><a href=\"#⌃⌥H\" class=\"headerlink\" title=\"⌃⌥H\"></a>⌃⌥H</h3><p>调用层次结构</p>\n<h3 id=\"F2\"><a href=\"#F2\" class=\"headerlink\" title=\"F2\"></a>F2</h3><p>下一个高亮错误</p>\n<h3 id=\"⇧F2\"><a href=\"#⇧F2\" class=\"headerlink\" title=\"⇧F2\"></a>⇧F2</h3><p>上一个高亮错误</p>\n<h3 id=\"F4-⌘↓\"><a href=\"#F4-⌘↓\" class=\"headerlink\" title=\"F4, ⌘↓\"></a>F4, ⌘↓</h3><p>跳转到源头</p>\n<h3 id=\"⌘↑\"><a href=\"#⌘↑\" class=\"headerlink\" title=\"⌘↑\"></a>⌘↑</h3><p>跳转到导航栏</p>\n<h3 id=\"F3\"><a href=\"#F3\" class=\"headerlink\" title=\"F3\"></a>F3</h3><p>切换书签</p>\n<h3 id=\"⌥F3\"><a href=\"#⌥F3\" class=\"headerlink\" title=\"⌥F3\"></a>⌥F3</h3><p>用助记符切换书签</p>\n<h3 id=\"⌃0…⌃9\"><a href=\"#⌃0…⌃9\" class=\"headerlink\" title=\"⌃0…⌃9\"></a>⌃0…⌃9</h3><p>转到编号书签</p>\n<h3 id=\"⌘F3\"><a href=\"#⌘F3\" class=\"headerlink\" title=\"⌘F3\"></a>⌘F3</h3><p>显示书签</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h1><h2 id=\"Editing\"><a href=\"#Editing\" class=\"headerlink\" title=\"Editing\"></a>Editing</h2><h3 id=\"Space\"><a href=\"#Space\" class=\"headerlink\" title=\"^Space\"></a>^Space</h3><p>基础打代码自动补全<br>对于路径补全，重复快捷键可选择上层路径</p>\n<h3 id=\"⌥⏎\"><a href=\"#⌥⏎\" class=\"headerlink\" title=\"⌥⏎\"></a>⌥⏎</h3><p>显示意图动作快速修复</p>\n<h3 id=\"⌘P\"><a href=\"#⌘P\" class=\"headerlink\" title=\"⌘P\"></a>⌘P</h3><p>查看调用方法的参数信息</p>\n<h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"^J\"></a>^J</h3><p>快速文档查找</p>\n<h3 id=\"⌘-mouse-over-code\"><a href=\"#⌘-mouse-over-code\" class=\"headerlink\" title=\"⌘ + mouse over code\"></a>⌘ + mouse over code</h3><p>查看信息简介</p>\n<h3 id=\"⌘F1\"><a href=\"#⌘F1\" class=\"headerlink\" title=\"⌘F1\"></a>⌘F1</h3><p>在插入符号上显示错误或警告的描述</p>\n<h3 id=\"J⏎-⌘N\"><a href=\"#J⏎-⌘N\" class=\"headerlink\" title=\"^J⏎,⌘N\"></a>^J⏎,⌘N</h3><p>生成代码……</p>\n<h3 id=\"⌥⌘T\"><a href=\"#⌥⌘T\" class=\"headerlink\" title=\"⌥⌘T\"></a>⌥⌘T</h3><p>添加包裹代码 (if..else, try..catch, for, etc.)</p>\n<h3 id=\"⌘J\"><a href=\"#⌘J\" class=\"headerlink\" title=\"⌘J\"></a>⌘J</h3><p>插入当前语言模板</p>\n<h3 id=\"⌘\"><a href=\"#⌘\" class=\"headerlink\" title=\"⌘/\"></a>⌘/</h3><p>取消/添加单行注释</p>\n<h3 id=\"⌘⇧\"><a href=\"#⌘⇧\" class=\"headerlink\" title=\"⌘⇧/\"></a>⌘⇧/</h3><p>取消/添加块级注释</p>\n<h3 id=\"⌥↑\"><a href=\"#⌥↑\" class=\"headerlink\" title=\"⌥↑\"></a>⌥↑</h3><p>选择连续增加的代码块</p>\n<h3 id=\"⌥↓\"><a href=\"#⌥↓\" class=\"headerlink\" title=\"⌥↓\"></a>⌥↓</h3><p>将当前选择减少到先前的状态</p>\n<h3 id=\"⇧Q\"><a href=\"#⇧Q\" class=\"headerlink\" title=\"^⇧Q\"></a>^⇧Q</h3><p>上下文信息</p>\n<h3 id=\"⌥⌘L\"><a href=\"#⌥⌘L\" class=\"headerlink\" title=\"⌥⌘L\"></a>⌥⌘L</h3><p>格式化代码</p>\n<h3 id=\"⌥⌘I\"><a href=\"#⌥⌘I\" class=\"headerlink\" title=\"⌥⌘I\"></a>⌥⌘I</h3><p>自动缩进行</p>\n<h3 id=\"⇥\"><a href=\"#⇥\" class=\"headerlink\" title=\"⇥\"></a>⇥</h3><p>缩进选择行</p>\n<h3 id=\"⇧⇥\"><a href=\"#⇧⇥\" class=\"headerlink\" title=\"⇧⇥\"></a>⇧⇥</h3><p>取消缩进选择行</p>\n<h3 id=\"⌘⇧V\"><a href=\"#⌘⇧V\" class=\"headerlink\" title=\"⌘⇧V\"></a>⌘⇧V</h3><p>从最近的缓冲区粘贴</p>\n<h3 id=\"⌘D\"><a href=\"#⌘D\" class=\"headerlink\" title=\"⌘D\"></a>⌘D</h3><p>复制当前行或选定块</p>\n<h3 id=\"⌘⌫\"><a href=\"#⌘⌫\" class=\"headerlink\" title=\"⌘⌫\"></a>⌘⌫</h3><p>在插入符号处删除行</p>\n<h3 id=\"⌥⇧↑\"><a href=\"#⌥⇧↑\" class=\"headerlink\" title=\"⌥⇧↑\"></a>⌥⇧↑</h3><p>向上移动当前行</p>\n<h3 id=\"⌥⇧↓\"><a href=\"#⌥⇧↓\" class=\"headerlink\" title=\"⌥⇧↓\"></a>⌥⇧↓</h3><p>向下移动当前行</p>\n<h3 id=\"⌃⇧J\"><a href=\"#⌃⇧J\" class=\"headerlink\" title=\"⌃⇧J\"></a>⌃⇧J</h3><p>合并行</p>\n<h3 id=\"⌘↩︎\"><a href=\"#⌘↩︎\" class=\"headerlink\" title=\"⌘↩︎\"></a>⌘↩︎</h3><p>分离行</p>\n<h3 id=\"⇧↩︎\"><a href=\"#⇧↩︎\" class=\"headerlink\" title=\"⇧↩︎\"></a>⇧↩︎</h3><p>创建新空白行</p>\n<h3 id=\"⌘⇧U\"><a href=\"#⌘⇧U\" class=\"headerlink\" title=\"⌘⇧U\"></a>⌘⇧U</h3><p>在插入符号或选定的块中切换单词的大小写</p>\n<h3 id=\"⌥⌘⇧\"><a href=\"#⌥⌘⇧\" class=\"headerlink\" title=\"⌥⌘⇧]\"></a>⌥⌘⇧]</h3><p>选择直到代码块结束</p>\n<h3 id=\"⌥⇧⌘\"><a href=\"#⌥⇧⌘\" class=\"headerlink\" title=\"⌥⇧⌘[\"></a>⌥⇧⌘[</h3><p>选择直到代码块开始</p>\n<h3 id=\"⌥⌦\"><a href=\"#⌥⌦\" class=\"headerlink\" title=\"⌥⌦\"></a>⌥⌦</h3><p>删除到单词结束</p>\n<h3 id=\"⌥⌫\"><a href=\"#⌥⌫\" class=\"headerlink\" title=\"⌥⌫\"></a>⌥⌫</h3><p>删除到单词开始</p>\n<h3 id=\"⌘-⌘\"><a href=\"#⌘-⌘\" class=\"headerlink\" title=\"⌘+/⌘-\"></a>⌘+/⌘-</h3><p>展开/折叠代码块</p>\n<h3 id=\"⇧⌘\"><a href=\"#⇧⌘\" class=\"headerlink\" title=\"⇧⌘+\"></a>⇧⌘+</h3><p>展开所有代码</p>\n<h3 id=\"⇧⌘-1\"><a href=\"#⇧⌘-1\" class=\"headerlink\" title=\"⇧⌘-\"></a>⇧⌘-</h3><p>折叠所有代码</p>\n<h3 id=\"⌘W\"><a href=\"#⌘W\" class=\"headerlink\" title=\"⌘W\"></a>⌘W</h3><p>关闭当前tab</p>\n<p>##Multiple carets and selections</p>\n<h3 id=\"⌥-click\"><a href=\"#⌥-click\" class=\"headerlink\" title=\"⌥ + click\"></a>⌥ + click</h3><p>添加或删除插入符号</p>\n<h3 id=\"⌃⌘G\"><a href=\"#⌃⌘G\" class=\"headerlink\" title=\"⌃⌘G\"></a>⌃⌘G</h3><p>选择所有出现</p>\n<h3 id=\"⌃G\"><a href=\"#⌃G\" class=\"headerlink\" title=\"⌃G\"></a>⌃G</h3><p>选择下一个出现的</p>\n<h3 id=\"⌃⇧G\"><a href=\"#⌃⇧G\" class=\"headerlink\" title=\"⌃⇧G\"></a>⌃⇧G</h3><p>取消下一个出现的</p>\n<h3 id=\"⎋\"><a href=\"#⎋\" class=\"headerlink\" title=\"⎋\"></a>⎋</h3><p>取消选择所有出现或插入符号</p>\n<h2 id=\"Search-Replace\"><a href=\"#Search-Replace\" class=\"headerlink\" title=\"Search/Replace\"></a>Search/Replace</h2><p>###⌘F/⌘R<br>查找/ 替换</p>\n<p>###⌘G/⇧⌘G<br>查找下一个/上一个</p>\n<p>###⇧⌘F<br>在当前文件路径下查找</p>\n<p>###⇧⌘R<br>在当前文件路径下替换</p>\n<h2 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h2><h3 id=\"Double-⇧\"><a href=\"#Double-⇧\" class=\"headerlink\" title=\"Double ⇧\"></a>Double ⇧</h3><p>全局查找</p>\n<h3 id=\"⇧⌘A\"><a href=\"#⇧⌘A\" class=\"headerlink\" title=\"⇧⌘A\"></a>⇧⌘A</h3><p>在action查找</p>\n<h3 id=\"⌘0…⌘9\"><a href=\"#⌘0…⌘9\" class=\"headerlink\" title=\"⌘0…⌘9\"></a>⌘0…⌘9</h3><p>打开相应的工具窗口</p>\n<h3 id=\"⇧⌘F12\"><a href=\"#⇧⌘F12\" class=\"headerlink\" title=\"⇧⌘F12\"></a>⇧⌘F12</h3><p>切换最大化编辑器</p>\n<h3 id=\"⌥⇧F\"><a href=\"#⌥⇧F\" class=\"headerlink\" title=\"⌥⇧F\"></a>⌥⇧F</h3><p>添加到Favorites</p>\n<h3 id=\"⌥⇧I\"><a href=\"#⌥⇧I\" class=\"headerlink\" title=\"⌥⇧I\"></a>⌥⇧I</h3><p>使用当前配置文件检查当前文件</p>\n<h3 id=\"⌃§-⌃\"><a href=\"#⌃§-⌃\" class=\"headerlink\" title=\"⌃§,⌃`\"></a>⌃§,⌃`</h3><p>快速切换当前的scheme（切换主题、代码样式等）</p>\n<h3 id=\"⌘-1\"><a href=\"#⌘-1\" class=\"headerlink\" title=\"⌘,\"></a>⌘,</h3><p>打开偏好设置</p>\n<h3 id=\"⌃⇥\"><a href=\"#⌃⇥\" class=\"headerlink\" title=\"⌃⇥\"></a>⌃⇥</h3><p>在标签和工具窗口之间切换</p>\n<h2 id=\"Usage-Search\"><a href=\"#Usage-Search\" class=\"headerlink\" title=\"Usage Search\"></a>Usage Search</h2><h3 id=\"⌥F7\"><a href=\"#⌥F7\" class=\"headerlink\" title=\"⌥F7\"></a>⌥F7</h3><p>查找使用</p>\n<h3 id=\"⌘F7\"><a href=\"#⌘F7\" class=\"headerlink\" title=\"⌘F7\"></a>⌘F7</h3><p>在文件内查找使用</p>\n<h3 id=\"⇧⌘F7\"><a href=\"#⇧⌘F7\" class=\"headerlink\" title=\"⇧⌘F7\"></a>⇧⌘F7</h3><p>在文件内高亮使用</p>\n<h3 id=\"⌥⌘F7\"><a href=\"#⌥⌘F7\" class=\"headerlink\" title=\"⌥⌘F7\"></a>⌥⌘F7</h3><p>显示用法</p>\n<h2 id=\"Refactoring\"><a href=\"#Refactoring\" class=\"headerlink\" title=\"Refactoring\"></a>Refactoring</h2><h3 id=\"⌃T\"><a href=\"#⌃T\" class=\"headerlink\" title=\"⌃T\"></a>⌃T</h3><p>重构这个</p>\n<h3 id=\"F5-F6\"><a href=\"#F5-F6\" class=\"headerlink\" title=\"F5/F6\"></a>F5/F6</h3><p>复制/移动</p>\n<h3 id=\"⌘⌦\"><a href=\"#⌘⌦\" class=\"headerlink\" title=\"⌘⌦\"></a>⌘⌦</h3><p>安全删除</p>\n<h3 id=\"⇧F6\"><a href=\"#⇧F6\" class=\"headerlink\" title=\"⇧F6\"></a>⇧F6</h3><p>重命名</p>\n<h3 id=\"⌘F6\"><a href=\"#⌘F6\" class=\"headerlink\" title=\"⌘F6\"></a>⌘F6</h3><p>更改函数签名</p>\n<h3 id=\"⌥⌘N\"><a href=\"#⌥⌘N\" class=\"headerlink\" title=\"⌥⌘N\"></a>⌥⌘N</h3><p>内联变量</p>\n<h3 id=\"⌥⌘V\"><a href=\"#⌥⌘V\" class=\"headerlink\" title=\"⌥⌘V\"></a>⌥⌘V</h3><p>提取变量</p>\n<h3 id=\"⌥⌘C\"><a href=\"#⌥⌘C\" class=\"headerlink\" title=\"⌥⌘C\"></a>⌥⌘C</h3><p>提取常量</p>\n<h3 id=\"⌥⌘P\"><a href=\"#⌥⌘P\" class=\"headerlink\" title=\"⌥⌘P\"></a>⌥⌘P</h3><p>提取参数</p>\n<h2 id=\"VCS-Local-History\"><a href=\"#VCS-Local-History\" class=\"headerlink\" title=\"VCS/Local History\"></a>VCS/Local History</h2><h3 id=\"⌃V\"><a href=\"#⌃V\" class=\"headerlink\" title=\"⌃V\"></a>⌃V</h3><p>vCS快速弹出</p>\n<h3 id=\"⌘K\"><a href=\"#⌘K\" class=\"headerlink\" title=\"⌘K\"></a>⌘K</h3><p>提交项目到VCS</p>\n<h3 id=\"⌘T\"><a href=\"#⌘T\" class=\"headerlink\" title=\"⌘T\"></a>⌘T</h3><p>从VCS更新项目</p>\n<h3 id=\"⌥⇧C\"><a href=\"#⌥⇧C\" class=\"headerlink\" title=\"⌥⇧C\"></a>⌥⇧C</h3><p>查看最近改动</p>\n<h2 id=\"Running\"><a href=\"#Running\" class=\"headerlink\" title=\"Running\"></a>Running</h2><h3 id=\"⌃⌥R\"><a href=\"#⌃⌥R\" class=\"headerlink\" title=\"⌃⌥R\"></a>⌃⌥R</h3><p>选择配置并运行</p>\n<h3 id=\"⌃⌥D\"><a href=\"#⌃⌥D\" class=\"headerlink\" title=\"⌃⌥D\"></a>⌃⌥D</h3><p>选择配置开始调试</p>\n<h3 id=\"⌃R-⌃D\"><a href=\"#⌃R-⌃D\" class=\"headerlink\" title=\"⌃R/⌃D\"></a>⌃R/⌃D</h3><p>运行/调试</p>\n<h3 id=\"⌃⇧R-⌃⇧D\"><a href=\"#⌃⇧R-⌃⇧D\" class=\"headerlink\" title=\"⌃⇧R,⌃⇧D\"></a>⌃⇧R,⌃⇧D</h3><p>从编辑器运行上下文配置</p>\n<h3 id=\"⌃⌘R\"><a href=\"#⌃⌘R\" class=\"headerlink\" title=\"⌃⌘R\"></a>⌃⌘R</h3><p>再运行测试</p>\n<h3 id=\"⌥F11\"><a href=\"#⌥F11\" class=\"headerlink\" title=\"⌥F11\"></a>⌥F11</h3><p>运行Gulp/Grunt/npm任务</p>\n<h2 id=\"Debugging\"><a href=\"#Debugging\" class=\"headerlink\" title=\"Debugging\"></a>Debugging</h2><h3 id=\"F8-F7\"><a href=\"#F8-F7\" class=\"headerlink\" title=\"F8/F7\"></a>F8/F7</h3><p>跳过/ 跳入</p>\n<h3 id=\"⇧F7\"><a href=\"#⇧F7\" class=\"headerlink\" title=\"⇧F7\"></a>⇧F7</h3><p>智能挑入</p>\n<h3 id=\"⇧F8\"><a href=\"#⇧F8\" class=\"headerlink\" title=\"⇧F8\"></a>⇧F8</h3><p>跳出</p>\n<h3 id=\"⌥F9\"><a href=\"#⌥F9\" class=\"headerlink\" title=\"⌥F9\"></a>⌥F9</h3><p>运行到光标处</p>\n<h3 id=\"⌥F8\"><a href=\"#⌥F8\" class=\"headerlink\" title=\"⌥F8\"></a>⌥F8</h3><p>表达式 求知</p>\n<h3 id=\"⌥⌘R\"><a href=\"#⌥⌘R\" class=\"headerlink\" title=\"⌥⌘R\"></a>⌥⌘R</h3><p>重新开始</p>\n<h3 id=\"⌘F8\"><a href=\"#⌘F8\" class=\"headerlink\" title=\"⌘F8\"></a>⌘F8</h3><p>切换断点</p>\n<h3 id=\"⇧⌘F8\"><a href=\"#⇧⌘F8\" class=\"headerlink\" title=\"⇧⌘F8\"></a>⇧⌘F8</h3><p>查看断点</p>\n<p>Navigation</p>\n<h3 id=\"⌘B-⌘click\"><a href=\"#⌘B-⌘click\" class=\"headerlink\" title=\"⌘B, ⌘click\"></a>⌘B, ⌘click</h3><p>查找并定位到declaratior</p>\n<h3 id=\"⌘O\"><a href=\"#⌘O\" class=\"headerlink\" title=\"⌘O\"></a>⌘O</h3><p>查找并定位到class</p>\n<h3 id=\"⇧⌘O\"><a href=\"#⇧⌘O\" class=\"headerlink\" title=\"⇧⌘O\"></a>⇧⌘O</h3><p>查找并打开文件</p>\n<h3 id=\"⌥⌘O\"><a href=\"#⌥⌘O\" class=\"headerlink\" title=\"⌥⌘O\"></a>⌥⌘O</h3><p>查找并定位到symbol</p>\n<h3 id=\"⇧⌘-2\"><a href=\"#⇧⌘-2\" class=\"headerlink\" title=\"⇧⌘]\"></a>⇧⌘]</h3><p>到下一个编辑标签页</p>\n<h3 id=\"⇧⌘-3\"><a href=\"#⇧⌘-3\" class=\"headerlink\" title=\"⇧⌘[\"></a>⇧⌘[</h3><p>到上一个编辑标签页</p>\n<h3 id=\"F12\"><a href=\"#F12\" class=\"headerlink\" title=\"F12\"></a>F12</h3><p>返回上一个工具窗口</p>\n<h3 id=\"⎋-1\"><a href=\"#⎋-1\" class=\"headerlink\" title=\"⎋\"></a>⎋</h3><p>跳转到编辑器（从工具窗口）</p>\n<h3 id=\"⌘L\"><a href=\"#⌘L\" class=\"headerlink\" title=\"⌘L\"></a>⌘L</h3><p>打开行数跳转窗口</p>\n<h3 id=\"⌘E\"><a href=\"#⌘E\" class=\"headerlink\" title=\"⌘E\"></a>⌘E</h3><p>弹出最近文件窗口</p>\n<h3 id=\"⌥⌘←\"><a href=\"#⌥⌘←\" class=\"headerlink\" title=\"⌥⌘←\"></a>⌥⌘←</h3><p>回退导航</p>\n<h3 id=\"⌥⌘→\"><a href=\"#⌥⌘→\" class=\"headerlink\" title=\"⌥⌘→\"></a>⌥⌘→</h3><p>向前导航</p>\n<h3 id=\"⌘⇧⌫\"><a href=\"#⌘⇧⌫\" class=\"headerlink\" title=\"⌘⇧⌫\"></a>⌘⇧⌫</h3><p>导航到上次编辑位置</p>\n<h3 id=\"⌥F1\"><a href=\"#⌥F1\" class=\"headerlink\" title=\"⌥F1\"></a>⌥F1</h3><p>在任何视图中选择当前文件或符号</p>\n<h3 id=\"⌥⌘B\"><a href=\"#⌥⌘B\" class=\"headerlink\" title=\"⌥⌘B\"></a>⌥⌘B</h3><p>转到实施</p>\n<h3 id=\"⌥Space-⌘Y\"><a href=\"#⌥Space-⌘Y\" class=\"headerlink\" title=\"⌥Space, ⌘Y\"></a>⌥Space, ⌘Y</h3><p>打开快速定义查找</p>\n<h3 id=\"⌃⇧B\"><a href=\"#⌃⇧B\" class=\"headerlink\" title=\"⌃⇧B\"></a>⌃⇧B</h3><p>转到类型声明</p>\n<h3 id=\"⌘U\"><a href=\"#⌘U\" class=\"headerlink\" title=\"⌘U\"></a>⌘U</h3><p>转到super方法/super类</p>\n<h3 id=\"⌃↑\"><a href=\"#⌃↑\" class=\"headerlink\" title=\"⌃↑\"></a>⌃↑</h3><p>转到上一个方法</p>\n<p>###⌃↓<br>转到下一个方法</p>\n<h3 id=\"⌥⌘\"><a href=\"#⌥⌘\" class=\"headerlink\" title=\"⌥⌘]\"></a>⌥⌘]</h3><p>到代码块结尾</p>\n<h3 id=\"⌥⌘-1\"><a href=\"#⌥⌘-1\" class=\"headerlink\" title=\"⌥⌘[\"></a>⌥⌘[</h3><p>到代码块开头</p>\n<h3 id=\"⌃M\"><a href=\"#⌃M\" class=\"headerlink\" title=\"⌃M\"></a>⌃M</h3><p>将插入符号移动到匹配的大括号</p>\n<h3 id=\"⌘F12\"><a href=\"#⌘F12\" class=\"headerlink\" title=\"⌘F12\"></a>⌘F12</h3><p>文件结构弹出窗口</p>\n<h3 id=\"⌃H\"><a href=\"#⌃H\" class=\"headerlink\" title=\"⌃H\"></a>⌃H</h3><p>类型层次结构</p>\n<h3 id=\"⌃⌥H\"><a href=\"#⌃⌥H\" class=\"headerlink\" title=\"⌃⌥H\"></a>⌃⌥H</h3><p>调用层次结构</p>\n<h3 id=\"F2\"><a href=\"#F2\" class=\"headerlink\" title=\"F2\"></a>F2</h3><p>下一个高亮错误</p>\n<h3 id=\"⇧F2\"><a href=\"#⇧F2\" class=\"headerlink\" title=\"⇧F2\"></a>⇧F2</h3><p>上一个高亮错误</p>\n<h3 id=\"F4-⌘↓\"><a href=\"#F4-⌘↓\" class=\"headerlink\" title=\"F4, ⌘↓\"></a>F4, ⌘↓</h3><p>跳转到源头</p>\n<h3 id=\"⌘↑\"><a href=\"#⌘↑\" class=\"headerlink\" title=\"⌘↑\"></a>⌘↑</h3><p>跳转到导航栏</p>\n<h3 id=\"F3\"><a href=\"#F3\" class=\"headerlink\" title=\"F3\"></a>F3</h3><p>切换书签</p>\n<h3 id=\"⌥F3\"><a href=\"#⌥F3\" class=\"headerlink\" title=\"⌥F3\"></a>⌥F3</h3><p>用助记符切换书签</p>\n<h3 id=\"⌃0…⌃9\"><a href=\"#⌃0…⌃9\" class=\"headerlink\" title=\"⌃0…⌃9\"></a>⌃0…⌃9</h3><p>转到编号书签</p>\n<h3 id=\"⌘F3\"><a href=\"#⌘F3\" class=\"headerlink\" title=\"⌘F3\"></a>⌘F3</h3><p>显示书签</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjosppz0t0000ggjgaewxck5n","tag_id":"cjospibx80002edjgwje2id81","_id":"cjosppz110001ggjgsb2jbusg"},{"post_id":"cjosppz0t0000ggjgaewxck5n","tag_id":"cjospibx90003edjgkux2ruoq","_id":"cjosppz110002ggjghqqcw9xr"},{"post_id":"cjosppz0t0000ggjgaewxck5n","tag_id":"cjospibxb0004edjg1a0om9bq","_id":"cjosppz110003ggjgcg6uwcgm"},{"post_id":"cjoztpcqa00002jjgqwxyq0u8","tag_id":"cjoztpcqm00012jjg23a7yuob","_id":"cjoztpcqp00022jjgz6fiv4c3"},{"post_id":"cjp8g36rk0000ntji9mvtv4cs","tag_id":"cjoztpcqm00012jjg23a7yuob","_id":"cjp8g36rs0001ntji21mtqfjd"},{"post_id":"cjp9ssssn000050ji7jo2pidl","tag_id":"cjp9ssssr000150jiy2gqkgev","_id":"cjp9ssssv000250jidi4by2bk"},{"post_id":"cjpba9hbq0000qkjini862bdy","tag_id":"cjospibx80002edjgwje2id81","_id":"cjpba9hbv0001qkji1wds62y7"},{"post_id":"cjou118i20000xijgczp7dy6a","tag_id":"cjpcrcqyg0000bljiehwdqoz7","_id":"cjpcrcqyo0001blji75ap3qpe"},{"post_id":"cjpgxwr8w00007gjizq4xa710","tag_id":"cjpgxwr9100017gjim45wlko6","_id":"cjpgxwr9500027gjiepwrvmox"},{"post_id":"cjpie0t5i0000rsjinaoc4c3g","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjpie0t5s0002rsji4bj0vhhy"},{"post_id":"cjpjvf0e500005yjihv9nn3h4","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjpjvf0ec00015yjig0yftclz"},{"post_id":"cjpqj2xnl0000yrji9bzomw33","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjpqj2xns0001yrji4vb948rr"},{"post_id":"cjpsfcjzc0000yiji53zzxcdx","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjpsfcjzm0001yijihyctm0hq"},{"post_id":"cjq2hxq7q0000ggjgr5ondkxg","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjq2hxq7z0001ggjgtyxxt106"},{"post_id":"cjq6q5hu500000tjgat2n555k","tag_id":"cjpie0t5n0001rsjioipebpxj","_id":"cjq6q5hue00010tjg8gnmqx57"},{"post_id":"cjqdty1l30000cyjfz0zvsv4k","tag_id":"cjqdty1la0001cyjfn75ylyja","_id":"cjqdty1ll0002cyjfz2etv8vm"}],"Tag":[{"name":"前端开发","_id":"cjospibx30001edjgqgex1r1q"},{"name":"css","_id":"cjospibx80002edjgwje2id81"},{"name":"flex","_id":"cjospibx90003edjgkux2ruoq"},{"name":"grid","_id":"cjospibxb0004edjg1a0om9bq"},{"name":"浏览器","_id":"cjoztpcqm00012jjg23a7yuob"},{"name":"freemark 模板","_id":"cjp9ssssr000150jiy2gqkgev"},{"name":"head","_id":"cjpcrcqyg0000bljiehwdqoz7"},{"name":"javascript","_id":"cjpgxwr9100017gjim45wlko6"},{"name":"js threejs","_id":"cjpie0t5n0001rsjioipebpxj"},{"name":"webstrom IDE","_id":"cjqdty1la0001cyjfn75ylyja"}]}}